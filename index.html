<!DOCT<YPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Mitharia</title>
<script src="storage.min.js"></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');
    /* altezza piena per lo sfondo + niente margini */
html, body {
  height: 100%;
  margin: 0;              /* elimina l‚Äô8px di margine di default */
}

/* sfondo epico + velo scuro */
body{
  font-family: 'MedievalSharp', cursive;
  color: #2c1e10;
  text-align: center;

  overflow-y: hidden;     /* rimuove la scrollbar verticale globale */

  /* fallback universale: JPG */
  background-image:
    radial-gradient(120% 160% at 50% 10%, rgba(0,0,0,0.18) 0%, rgba(0,0,0,0.45) 100%),
    url('imgbg-mitharia-heroes.jpg');
  background-position: center 20%;
  background-size: cover;
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-color: #efe3c4;
}

/* se il browser supporta image-set, usa il WEBP (pi√π leggero) */
@supports (background-image: image-set(url('x.webp') type('image/webp') 1x)) {
  body{
    background-image:
      radial-gradient(120% 160% at 50% 10%, rgba(0,0,0,0.18) 0%, rgba(0,0,0,0.45) 100%),
      image-set(
        url('imgbg-mitharia-heroes.webp') type('image/webp') 1x,
        url('imgbg-mitharia-heroes.jpg')  type('image/jpeg') 1x
      );
  }
}

/* mobile: niente fixed per evitare scatti */
@media (max-width: 768px){
  body{
    background-attachment: scroll;
    background-position: center top;
  }
}


.owned-item {
  opacity: 0.85;
  border-style: dashed;
}

.magic-button {
  font-size: 18px;
  padding: 10px;
  margin: 8px 0;
  background-color: #8B4513; /* marrone caldo */
  color: #fff8dc;            /* testo chiaro */
  border: 2px solid #6b4226;
  border-radius: 8px;
  cursor: pointer;
  width: 100%;
  text-align: center;
  transition: background-color 0.2s;
}
.tiny-btn{
  display:inline-block;
  padding:0 8px;
  line-height:1.2;
  font-size:0.9em;
  border:1px solid #6b4226;
  background:#d1c2a4;      /* marrone chiaro */
  color:#000;              /* + nero */
  cursor:pointer;
  margin-left:6px;
  width:auto;
  vertical-align:baseline;
}
/* Evita che l'hover globale cambi il colore */
.tiny-btn:hover{ background:#d1c2a4; color:#000; }

.tiny-btn.minus{
  background:#d1c2a4;      /* stesso fondo */
  color:#b03030;           /* ‚àí rosso */
  border-color:#6b4226;
}
.tiny-btn.minus:hover{ background:#d1c2a4; color:#b03030; }

/* Disabilitato */
.tiny-btn:disabled {
  opacity: 0.6;
  cursor: default;
}

.close-button {
  background-color: #6b4226; /* stesso marrone scuro usato in magia */
  margin-top: 8px;          /* stessa spaziatura verticale tra i bottoni */
}

.magic-button:hover {
  background-color: #a0522d; /* marrone leggermente pi√π chiaro su hover */
}

.magic-detail-box {
  margin-top: 20px;
  background: #fff8dc;
  border: 2px solid #6b4226;
  padding: 12px;
  border-radius: 8px;
}

    .container {
      margin: 30px auto;
      max-width: 500px;
      background: #f5f1e1;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 18px #000000a0;
    }
/* === Pergamene laterali (3) === */
#scrolls-panel{
  position: fixed;
  left: 0;                 /* lo posizioniamo via JS vicino al container */
top: 0;                  /* lo posizioniamo via JS vicino al container */
transform: translateY(-50%);
  width: 240px;             /* verr√† ridimensionata via JS in base allo spazio reale */
  display: grid;
  grid-template-rows: 1fr 1fr 1fr;
  gap: 12px;
  z-index: 1200;
  pointer-events: none;     /* decorative */
}
#scrolls-panel img.scroll-img{
  width: 100%;
  height: auto;
  display: block;
  object-fit: contain;
  border-radius: 8px;
  filter: drop-shadow(0 6px 14px rgba(0,0,0,.35));
}
/* nascondi su schermi stretti */
@media (max-width: 1100px){
  #scrolls-panel{ display:none; }
}
/* --- Testo dentro le pergamene --- */
#scrolls-panel .scroll-box{
  position: relative;
}

#scrolls-panel .scroll-text{
  position: absolute;
  /* margini interni della pergamena */
  top: 17%;
  bottom: 14%;
  left: 13%;
  right: 12%;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: stretch;
  text-align: center;
  font-family: 'MedievalSharp', cursive;
  color: #3a2a1f;
  text-shadow: 0 1px 0 #f5e9c9;
  pointer-events: none; /* resta decorativo */
}

#scrolls-panel .rank-title{
  font-size: 20px;
  letter-spacing: .5px;
  margin-top: 18px;
  margin-bottom: 8px;
}

#scrolls-panel .rank-list{
  margin: 0;
  padding-left: 20px;
  list-style: none;
  text-align: left;
  font-size: 16px;
  line-height: 1.25;
}

#scrolls-panel .rank-list li{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#scrolls-panel .rank-list .pts{
  opacity: .8;
  font-size: 90%;
  margin-left: 6px;
}


    input, select {
      padding: 10px;
      margin: 5px;
      width: 90%;
      border-radius: 6px;
      border: none;
      font-family: Arial, sans-serif;
    }
/* Contenitore centrale sempre dentro la viewport, con scroll interno */
:root{ --container-vpad: 30px; } /* = margine verticale del container */

html, body { height: 100%; } /* gi√† presente, lascio per completezza */

/* PATCH */
.container{
  /* dimensioni ‚Äúfluide‚Äù ma vincolate all‚Äôaltezza della finestra */
  max-height: calc(100vh - 60px);
  max-height: calc(100dvh - 60px); /* o il valore che usi per i margini verticali */
  overflow: auto;                  /* attiva la scrollbar interna */
  overscroll-behavior: contain;    /* evita rimbalzi sulla pagina */
  box-sizing: border-box;          /* sicurezza col padding */
}

/* Mobile: un po‚Äô meno margine e pi√π spazio utile */
@media (max-width: 600px){
  :root{ --container-vpad: 16px; }
  .container{
    margin: 16px auto;                  /* coerente con il nuovo var */
    max-height: calc(100dvh - 32px);    /* 2 * 16px */
    width: min(94vw, 520px);            /* evita di sfiorare i bordi */
  }
}

.menu-button {
  font-family: 'MedievalSharp', cursive;
  font-size: 22px;
  background-color: #6b4226;
  color: #fff8dc;
  border: none;
  border-radius: 8px;
  padding: 12px 16px;
  margin: 8px 0;
  width: 100%;
  text-align: left;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.2s ease;
}

.menu-button:hover {
  background-color: #8c5a3c;
  transform: scale(1.02);
}

    button {
      padding: 10px;
      margin: 5px 0;
      border-radius: 6px;
      border: none;
      font-family: 'MedievalSharp', cursive;
      font-size: 18px;
      background-color: #6b4226;
      color: #fff8dc;
      cursor: pointer;
      display: block;
      width: 100%;
    }
    button:hover {
      background-color: #8c5a3c;
    }
    h1 { color: #b5914a; }
    h2, h3 { color: #3c2d1e; }
    .hidden { display: none; }
    #magic-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #f5f1e1;
      border: 3px solid #6b4226;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px #00000088;
      z-index: 1000;
      width: 300px;
    }
/* Magie: voci sempre contenute nel popup, niente overflow orizzontale */
#magic-popup .magic-option,
#magic-popup .magic-options-dynamic .magic-option {
  display: block;
  width: 100%;
  box-sizing: border-box;
  white-space: normal;        /* consente il ‚Äúa capo‚Äù */
  overflow-wrap: anywhere;    /* spezza parole lunghissime (es. con [Leggendaria]) */
  padding: 6px 10px;          /* pi√π sottili in altezza */
  font-size: 14px;
  line-height: 1.2;
}

#hand-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 300px;
}
#mission-detail {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 340px;
  text-align: left;
}
#mission-detail h3 { margin-top: 0; text-align:center; }
#mission-detail p { margin: 6px 0; }

/* backdrop scuro dietro il popup (NUOVO) */
#message-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  z-index: 2000;
}
/* Overlay scuro per il popup creature */
#creature-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.45);
  z-index: 999;
}

/* Modale dettaglio creatura */
#creature-detail {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 360px;
  text-align: left;
}
#creature-detail h3 { margin-top: 0; text-align: center; }
#creature-detail p { margin: 6px 0; }

#message-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 2001;
  width: 340px;
  text-align: left;
}
#message-popup h3 { margin-top: 0; text-align:center; }
#message-popup p { margin: 6px 0; }

    .magic-option {
      margin: 8px 0;
      cursor: pointer;
      padding: 6px 12px;
      background: #e4d6b5;
      border-radius: 6px;
    }
    .magic-option:hover {
      background: #d1c2a4;
    }
    .inline-button {
      display: inline-block;
      margin-left: 10px;
    }
    .magic-equipped {
      font-weight: bold;
      text-shadow: 1px 1px 5px gold;
    }
    .magic-Fuoco { color: #e25822; }
    .magic-Acqua { color: #1e90ff; }
    .magic-Vento { color: #9fd3c7; }
    .magic-Ghiaccio { color: #a3e4f5; }
    .magic-Fulmine { color: #ffd700; }
    .magic-Terra { color: #8b4513; }
    .magic-Luce { color: #fffacd; }
    .magic-Oscurit√† { color: #4b0082; }
    .magic-label-button {
      background: none;
      border: none;
      font-family: 'MedievalSharp', cursive;
      font-size: 1em;
      cursor: pointer;
      color: #2c1e10;
      text-decoration: underline;
      font-weight: bold;
    }
/* Riga Scudo nel profilo eroe */
.shield-row {
  display: flex;
  width: 100%;
  justify-content: center;

  margin-top: 2px;     /* meno spazio sopra */
  margin-bottom: 8px;  /* pi√π respiro sotto */
}
/* PROFILO EROE: stringi lo spazio tra "Tipo Eroe" e "Scudo" */
#hero-profile .my-hero-card p { 
  margin-top: 6px;
  margin-bottom: 6px;
}

/* ma lo scudo lo vogliamo pi√π vicino sopra e un po' pi√π lontano sotto */
#hero-profile .shield-row{
  margin-top: 0px !important;   /* riduce distanza da Tipo Eroe */
  margin-bottom: 10px !important; /* aumenta distanza verso Salute */
}

    .magic-line {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
.pill-badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 999px;
  background: #8B4513;
  color: #fff8dc;
  font-weight: bold;
  font-size: 0.85em;
}

    /* Lista eroi con altezza maggiore */
    #hero-choice-list {
      text-align: left;
      max-height: 500px;
      overflow-y: auto;
      padding: 0;
      margin: 15px 0;
      list-style: none;
    }
    #hero-choice-list li {
      background: #e4d6b5;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      box-shadow: 1px 1px 5px #a88c54;
      transition: background-color 0.3s;
    }
    #hero-choice-list li:hover {
      background-color: #d1c2a4;
    }
    #hero-choice-list li.selected {
      background-color: #b5914a;
      color: #fff8dc;
      font-weight: bold;
      box-shadow: 0 0 10px gold;
    }
    #hero-description {
      font-style: italic;
      margin-top: 10px;
      min-height: 60px;
      color: #3c2d1e;
    }

   #mission-detail-desc {
     font-style: normal;
   }

    #hero-confirm-btn {
      margin-top: 15px;
      width: 100%;
    }
/* Bottone "Elimina" (stesso colore della Magia) */
.btn-danger{
  background-color: #b03030 !important;  /* identico alla Magia */
  border-color: #8a2626 !important;
  color: #fff8dc !important;
}
.btn-danger:hover{
  background-color: #c03a3a !important;
}

.message-item {
  background: #e4d6b5;
  border-radius: 8px;
  padding: 10px 12px;
  margin: 8px 0;
  cursor: pointer;
  box-shadow: 1px 1px 5px #a88c54;
  text-align: left;
}
/* variante "stack" come nel popup magia */
.modal-actions--stack{
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 5px;                     /* come il ‚Äúcollapsing margin‚Äù del popup Magia */
}
/* bottoni full-width, senza margini (usa il gap) */
.modal-actions--stack .magic-button{
  width: 100%;
  margin: 0;
}
/* spazio tra la lista creature e i bottoni, come il <br/> del popup magia */
#creature-choice-list{
  margin-bottom: 10px;
}
/* Colore titolo popup selezione creatura (marrone chiaro come H1) */
#creature-select-title{
  color: #b5914a;
}

/* Pulsante Elimina in fucsia (come nel popup magie) */
.btn-fuchsia{
  background-color: #b03090 !important;
  border-color: #8a2671 !important;
}
.btn-fuchsia:hover{
  background-color: #c23aa0 !important;
}

/* Assicura che i bottoni dentro i popup non ereditino larghezze strane */
#creature-select-popup .magic-button{
  display: block;
}


.modal-actions--stack button {
  width: 100%;
}

.message-item:hover { background-color: #d1c2a4; }
.message-title { font-weight: 700; }
.message-title.read { font-weight: 400; opacity: 0.85; }
.muted { font-size: 0.9em; opacity: 0.8; }

/* Thumb creatura nel popup */
#creature-popup img.creature-thumb{
  display:block;
  width:160px; height:160px;
  object-fit:cover;
  border-radius:10px;
  margin:8px auto 12px;
  box-shadow:0 0 10px rgba(0,0,0,.25);
}
.creature-thumb {
  display: block;
  margin: 0 auto 10px auto;
  width: 120px;   /* circa 4 cm */
  height: 120px;  /* circa 4 cm */
  object-fit: cover;
  border-radius: 8px;
}
/* Overlay/modale riutilizzabili */
.overlay-common{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.45);
  z-index: 999;
}
/* === Creature: immagine che riempie la cornice del popup === */
img.weapon-thumb.creature-thumb--frame{
  display: block;
  width: 140px;
  height: 140px;

  /* IMPORTANTISSIMO: elimina lo spazio interno della cornice */
  padding: 0 !important;

  /* riempie bene (taglia un po‚Äô se serve) */
  object-fit: cover;

  margin: 6px auto 10px auto;

  /* resta coerente con la cornice */
  border-radius: 14px;

  /* evita sorprese con bordo/padding */
  box-sizing: border-box;
}



.modal-common{
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 360px;
  text-align: left;
}
.modal-common h3{
  margin-top: 0;
  text-align: center;
}
/* container dei bottoni */
.modal-actions{
  margin-top: 0;                /* niente extra sopra: lo gestiamo sotto */
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

/* Lista scroll nel popup */
.scroll-area{
  max-height: 300px;
  overflow-y: auto;
  margin-top: 10px;
}

/* Bottoni lista creature nel popup di selezione */
.creature-choice-btn {
  font-family: 'MedievalSharp', cursive;
  font-size: 18px;
  background-color: #6b4226;
  color: #fff8dc;
  border: none;
  border-radius: 8px;
  padding: 10px 12px;
  margin: 8px 0;
  width: 100%;
  text-align: left;
  cursor: pointer;
  transition: background-color .2s ease, transform .15s ease;
}
.creature-choice-btn:hover {
  background-color: #8c5a3c;
  transform: scale(1.01);
}

/* Miniatura immagine nel dettaglio creatura */
.creature-thumb {
  display: block;
  margin: 0 auto 10px auto;
  width: 120px;
  height: 120px;
  object-fit: cover;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0,0,0,.25);
}
.traits-block {
  background: #f5f0e6;
  border: 1px solid #c0a98a;
  padding: 8px;
  margin-bottom: 8px;
  font-size: 0.95em;
}
.traits-block .title {
  font-weight: bold;
  margin-bottom: 4px;
}
.traits-grid { display: block; }
.traits-grid > div { margin: 2px 0; }
/* Bottoni elenco SOLO nelle botteghe: pi√π compatti */
#magic-buttons-list > button.magic-button,
#weapon-buttons-list > button.magic-button,
#armor-buttons-list > button.magic-button,
#creature-buttons-list > button.magic-button {
  padding: 6px 10px;    /* meno ‚Äúcicciotti‚Äù */
  font-size: 0.95em;    /* testo un filo pi√π piccolo */
  line-height: 1.2;     /* pi√π snelli in altezza */
}

/* (facoltativo) riduci un pelo anche lo spazio verticale tra i pulsanti */
#magic-buttons-list > button.magic-button,
#weapon-buttons-list > button.magic-button,
#armor-buttons-list > button.magic-button,
#creature-buttons-list > button.magic-button {
  margin: 4px 0;
}
/* Inventari: stessi pulsanti sottili della bottega */
#weapon-list button.magic-button,
#magic-list button.magic-button,
#armor-list button.magic-button,
#creature-list button.magic-button {
  padding: 6px 10px !important;
  font-size: 14px !important;
  width: 100%;
}
/* === Scelte dal profilo Eroe: allinea ai pulsanti Inventario === */
#hand-weapon-options .magic-button,
#armor-choice-list .magic-button,
#creature-choice-list .magic-button,
#magic-popup .magic-options-dynamic .magic-option {
  padding: 6px 10px !important;
  font-size: 14px !important;
  width: 100%;
  line-height: 1.2;
}

/* Le voci dinamiche delle magie (.magic-option) le rendiamo ‚Äúpulsanti‚Äù */
#magic-popup .magic-options-dynamic .magic-option {
  background-color: #8B4513;
  color: #fff8dc;
  border: 2px solid #6b4226;
  border-radius: 8px;
  margin: 4px 0;
  cursor: pointer;
  text-align: left;
  transition: background-color .2s ease;
}
#magic-popup .magic-options-dynamic .magic-option:hover {
  background-color: #A45A2A;
}

/* Togli i pallini delle UL negli inventari */
#weapon-list,
#magic-list,
#armor-list,
#creature-list,
#potion-list {
  list-style: none !important;
  padding-left: 0 !important;
  margin-left: 0 !important;
}

/* === Uniforma tutti i popup "dettaglio" alle creature === */
#weapon-detail,
#armor-detail,
#magic-detail,
#creature-detail,
#crystals-modal {
  position: fixed;
  /* top ‚Äúdi default‚Äù, se non lo settiamo via JS resta a met√† schermo */
  top: var(--modal-top, 50%);
  left: 50%;
  /* niente translateY: la quota la decidiamo noi in px */
  transform: translate(-50%, 0);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;

  width: 360px;       /* come #creature-detail */
  text-align: left;

  /* popup scrollabile ma ‚Äúsafe‚Äù su mobile */
  max-height: calc(88vh - env(safe-area-inset-bottom) - 16px);
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

#weapon-detail h3,
#armor-detail h3,
#magic-detail h3,
#creature-detail h3 {
  margin-top: 0;
  text-align: center;
}

/* disattiva scroll interno dei body dei popup dettaglio */
#weapon-detail-body,
#armor-detail-body,
#magic-detail-body,
#creature-detail-body {
  max-height: none !important;
  overflow: visible !important;
}

/* se per caso qualche contenitore interno usa .scroll-area, neutralizzala qui */
#weapon-detail .scroll-area,
#armor-detail .scroll-area,
#magic-detail .scroll-area,
#creature-detail .scroll-area {
  max-height: none !important;
  overflow: visible !important;
}

/* overlay coerenti per tutti i popup dettaglio */
#weapon-overlay,
#armor-overlay,
#magic-overlay,
#creature-overlay,
#crystals-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.45);
  z-index: 999;
}
/* link cliccabile per "Effetto Extra" */
.extra-effect-link { cursor: pointer; }

/* mini-popup scelta effetto */
#extra-effect-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.45); z-index: 999;
}
#extra-effect-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: #f5f1e1; border: 3px solid #6b4226; padding: 16px; border-radius: 12px;
  box-shadow: 0 0 15px #0008; width: 360px; z-index: 1000; text-align: left;
}
#extra-effect-popup.hidden, #extra-effect-overlay.hidden { display: none; }
#extra-effect-popup h3 { margin: 0 0 8px; text-align: center; }
#extra-effect-popup .effect-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

  .simple-list {
    list-style: none;   /* üîπ niente puntini */
    margin: 0;
    padding: 0;
  }

  .simple-list li {
    padding: 6px 0;     /* üîπ ogni effetto su una riga */
  }
/* Solo per il bottone "Cristalli di Potenziamento" */
.crystal-btn{
  display: flex;
  align-items: center;   /* allineamento verticale perfetto */
  gap: 6px;
}

/* Icona dedicata ai cristalli (niente offset verticale) */
.crystal-icon{
  width: 32px;  /* regola liberamente 24/28/32 */
  height: 32px;
  margin: 0;
  vertical-align: middle;  /* ininfluente con flex ma innocuo */
  position: static;        /* rimuove il top:2px della versione precedente */
}

/* Etichetta (opzionale, ma utile se vuoi forzare la riga) */
.crystal-label{
  line-height: 1;          /* evita che ‚Äútiri su‚Äù rispetto all‚Äôicona */
}

/* Popup Cristalli */
.crystals-info-box {
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 8px 12px;
  margin-top: 10px;
  background: #f9f9f9;
}

.crystals-info-box .title {
  font-weight: bold;
  margin-bottom: 6px;
}
/* bottone piccolo (scuro sempre) */
.mini-button{
  font-size: 0.9rem;
  padding: 4px 8px;
  border: 2px solid #6b4226;
  background: #6b4226;   /* üîπ sempre scuro */
  color: #fff;           /* üîπ testo chiaro */
  border-radius: 8px;
  cursor: pointer;
}
.mini-button:hover{
  filter: brightness(0.95);
}

/* righe di potenziamento */
.up-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:6px 0;
  border-bottom:1px solid #6b422620;
}
.up-row:last-child{ border-bottom:none; }
.up-ctrls{
  display:flex;
  align-items:center;
  gap:6px;
}
.up-val{
  min-width: 64px;
  text-align:center;
  display:inline-block;
}

/* includi il nuovo modal/overlay nella tua famiglia di popup */
#crystal-spend-modal{
  /* eredita lo stile degli altri popup; se hai gi√† un blocco con #weapon-detail, aggiungi qui (o includilo in quel blocco) */
  position: fixed; top: var(--modal-top, 50%); left:50%; transform: translate(-50%, 0);
  background:#f5f1e1; border:3px solid #6b4226; padding:20px; border-radius:12px;
  box-shadow:0 0 15px #00000088; z-index:1000; width:360px; max-height:88vh; overflow:auto;
}
#crystal-spend-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:999; }

.bonus {
  color: #2e7d32;   /* verde */
  font-weight: bold; /* grassetto */
}
/* evidenzia l‚Äôopzione scelta */
.extra-effect-option.selected {
  outline: 2px solid #6b4226;
}

/* allinea i bottoncini del footer del modal */
#extra-effect-footer .magic-button {
  margin: 0;
}
/* === Popup "Effetto Extra" (sopra gli altri modali) === */
#extra-effect-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.55);
  z-index: 4000;              /* > di weapon/magic/armor */
}

#extra-effect-modal {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: #f7ece1;
  border: 2px solid #6b4226;
  border-radius: 12px;
  padding: 14px;
  width: min(90vw, 620px);    /* coerente con gli altri popup */
  max-height: 80vh;
  overflow: auto;
  box-shadow: 0 10px 30px rgba(0,0,0,.40);
  z-index: 4001;              /* sopra al suo overlay */
}

/* evidenzia la scelta effetto */
.extra-effect-option.selected {
  outline: 2px solid #6b4226;
}

/* opzionale, uniforma i bottoni del footer */
#extra-effect-footer .magic-button { margin: 0; }

.tab-button {
  background-color: #3a2a1f; /* scuro sempre */
  color: #fff;              /* testo chiaro leggibile */
  border: 2px solid transparent;
  padding: 6px 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.tab-button.active {
  border: 2px solid #d4af37; /* contorno oro quando attivo */
}

/* Badge puntino rosso per il tab Quest */
.dot {
  display:inline-block;
  width:10px; height:10px;
  border-radius:50%;
  background:#e53935;
  margin-left:6px;
  vertical-align:middle;
}
.hidden { display:none; }

/* UI quest semplice */
.quest-list { display:grid; gap:8px; }
/* Quest: stesso colore dei bottoni missioni */
.quest-item {
  border: 2px solid #6b4226;
  border-radius: 10px;
  padding: 10px;
  background: #8B4513;     /* come i .magic-button */
  color: #fff8dc;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
}
.quest-item:hover,
.quest-item:focus {
  background-color: #a0522d; /* hover come i .magic-button */
  outline: none;
  box-shadow: 0 0 0 2px #f7ece1 inset;
}
.quest-item .meta { font-size:12px; opacity:.8; }
.quest-item .name {
  font-weight: bold;
  font-size: 0.9em;  /* un pelo pi√π piccolo */
  line-height: 1.2;
}

.quest-item .claimable{
  font-weight:700;
  font-size:.85em;
  color:#fff8dc;
  border:1px solid #d4af37;     /* bordo dorato sottile */
  border-radius:999px;           /* pill */
  padding:3px 10px;
  background:transparent;        /* non √® un bottone pieno */
}

.quest-button {
  display: block;
  width: 100%;
  padding: 8px 12px;
  margin: 6px 0;
  text-align: left;
  border: 2px solid #6b4226;
  border-radius: 10px;
  background: #6b4226;   /* sempre scuro */
  color: #f7ece1;        /* testo chiaro */
  font-weight: bold;
  cursor: pointer;
}
/* Colonna sinistra: titolo + ricompensa (sotto) */
.quest-item .left{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  text-align: left;
  gap:2px;
}
.quest-item .reward{
  font-size:12px;
  opacity:.85;
}

.quest-button:hover {
  background: #8c5a32;   /* scuro pi√π chiaro al passaggio */
}
.back-button-container {
  margin-top:12px;
  text-align:right;
}
/* ==== Dungeon: popup "Battaglia in corso" ==== */
#dungeon-battle-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;              /* diventa flex quando lo mostriamo */
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
.dbo-card {
  background: #2b1d12;        /* marrone scuro in tema */
  color: #fff;
  padding: 24px 28px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  max-width: 420px;
}
.dbo-icon {
  font-size: 42px;
  display: inline-block;
  animation: swordsPulse 1s infinite ease-in-out;
}
@keyframes swordsPulse {
  0%   { transform: scale(1) rotate(0deg); }
  50%  { transform: scale(1.15) rotate(-10deg); }
  100% { transform: scale(1) rotate(0deg); }
}
.dbo-title { font-size: 18px; margin-top: 10px; font-weight: 700; }
.dbo-sub   { font-size: 14px; opacity: .85; }
/* ==== Dungeon: Energia ==== */
#dungeon-energy {
  margin-bottom: 12px;
}
#dungeon-energy .label {
  font-weight: 700;
  margin-bottom: 6px;
  color: #000;
}
#dungeon-energy .bar {
  height: 14px;
  background: #4a3b2f;        /* sfondo scuro */
  border-radius: 999px;
  overflow: hidden;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
}
#dungeon-energy .fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #3adb76, #2ecc71); /* verde energia */
  transition: width .25s ease;
}
#dungeon-energy .fill.yellow {
  background: linear-gradient(90deg, #FFD700, #FFA500); /* giallo/arancio */
}
#dungeon-energy .fill.red {
  background: linear-gradient(90deg, #FF4500, #FF0000); /* rosso acceso */
}
#dungeon-energy .meta {
  margin-top: 6px;
  font-size: 0.9em;
  color: #222;   /* scuro, molto pi√π leggibile */
  font-weight: bold;
}
/* ==== Sfide: Energia ==== */
#sfide-energy { margin-bottom: 12px; }
#sfide-energy .label {
  font-weight: 700;
  margin-bottom: 6px;
  color: #000;
  font-size: 17px;
}
#sfide-energy .bar {
  height: 14px;
  background: #4a3b2f;
  border-radius: 999px;
  overflow: hidden;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
}
#sfide-energy .fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #3adb76, #2ecc71); /* verde */
  transition: width .25s ease;
}
#sfide-energy .fill.yellow {
  background: linear-gradient(90deg, #FFD700, #FFA500);
}
#sfide-energy .fill.red {
  background: linear-gradient(90deg, #FF5F6D, #DE3163);
}
#sfide-energy .meta {
  margin-top: 6px;
  font-size: 0.9em;    /* come Dungeon */
  color: #000;         /* nero, come richiesto */
  font-weight: bold;   /* in grassetto, come Dungeon */
}

#sfide-energy .meta .regen-timer {
  opacity: 1;
}

.magic-button.disabled-look {
  opacity: 0.55;
  cursor: not-allowed;
  filter: grayscale(0.3);
}
#quests-badge.dot {
  vertical-align: super; /* lo sposta verso l‚Äôalto rispetto al testo */
  margin-left: 2px;      /* piccolo spazio dal testo */
}
#weekly-badge.dot {
  vertical-align: super; /* alza il pallino come per le giornaliere */
  margin-left: 2px;      /* stesso distacco dal testo */
}
#main-badge.dot {
vertical-align: super; /* alza il pallino come per le giornaliere */
  margin-left: 2px;      /* stesso distacco dal testo */
}
#btn-missions {
  position: relative;
}

#missions-badge.dot {
  position: absolute;
  top: 6px;     
  right: 6px;   
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: red;
  display: inline-block !important; /* forza sempre visibile */
  pointer-events: none;             /* cos√¨ non interferisce col click del bottone */
}
/* Il bottone Missioni & Quest fa da riferimento */
button.menu-button[onclick="showMissions()"] {
  position: relative;
}

/* Badge posizionato sul bottone Missioni, ma visibile solo quando NON ha .hidden */
button.menu-button[onclick="showMissions()"] #missions-badge.dot {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: red;
  z-index: 2;
  pointer-events: none;
}

/* Mostra il badge solo quando non √® .hidden (vincendo su eventuali regole hover) */
button.menu-button[onclick="showMissions()"] #missions-badge.dot:not(.hidden) {
  display: inline-block !important;
  opacity: 1 !important;
  visibility: visible !important;
}

/* Nasconde SEMPRE quando .hidden √® presente */
#missions-badge.hidden {
  display: none !important;
  opacity: 0 !important;
  visibility: hidden !important;
}
/* Assicura che il puntino sul bottone menu scompaia quando c'√® .hidden */
.menu-button .dot.hidden,
#missions-badge.hidden { display: none !important; }

:root{
  --rarity-common: #2aa44f;   /* verde "comune" */
  --rarity-rare:   #3b82f6;   /* blu */
  --rarity-epic:   #a855f7;   /* viola */
  --rarity-legend: #f59e0b;   /* oro/arancio */
  --rarity-mythic: #ef4444;   /* rosso */
}
.rarity{ font-weight:700; }
.rarity--comune     { color: var(--rarity-common); }
.rarity--rara       { color: var(--rarity-rare); }
.rarity--epica      { color: var(--rarity-epic); }
.rarity--leggendaria{ color: var(--rarity-legend); }
.rarity--mitica     { color: var(--rarity-mythic); }

/* --- BADGE "Gilda" nel menu --- */
button.menu-button[onclick="showGuildScreen()"]{ position:relative; }
button.menu-button[onclick="showGuildScreen()"] #guild-badge.dot{
  position:absolute; top:6px; right:6px; width:10px; height:10px; border-radius:50%;
  background:red; display:block;
}
button.menu-button[onclick="showGuildScreen()"] #guild-badge.hidden{ display:none !important; }

/* --- BADGE "Negozio della Gilda" dentro la schermata Gilda --- */
#g-shop-btn{ position:relative; }
#g-shop-btn #g-shop-badge.dot{
  position:absolute; top:6px; right:6px; width:10px; height:10px; border-radius:50%;
  background:red; display:block;
}
#g-shop-btn #g-shop-badge.hidden{ display:none !important; }

/* --- BADGE del pulsante "Oggetto segreto" nella finestra Negozio --- */
.guild-shop-secret-btn{ position:relative; }
.guild-shop-secret-btn #gs-secret-dot.dot{
  position:absolute; top:6px; right:6px; width:10px; height:10px; border-radius:50%;
  background:red; display:block;
}
.guild-shop-secret-btn #gs-secret-dot.hidden{ display:none !important; }


/* ===== Decorazioni visive per Rarit√† (banda top + underline titolo) ===== */

/* 1) I contenitori dei popup diventano "relativi" e clippono gli interni */
#weapon-detail,
#armor-detail,
#magic-detail,
#creature-detail {
  overflow-y: auto;   /* scroll verticale */
  overflow-x: hidden; /* niente scroll orizzontale */
}


/* 2) Banda alta di 3mm, subito sotto al bordo superiore */
#weapon-detail::before,
#armor-detail::before,
#magic-detail::before,
#creature-detail::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3mm;
  background: transparent; /* verr√† colorata dalle regole qui sotto */
  pointer-events: none;
}

/* 3) Mapping colore per la banda in base a data-rarity */
#weapon-detail[data-rarity="comune"]::before,
#armor-detail[data-rarity="comune"]::before,
#magic-detail[data-rarity="comune"]::before,
#creature-detail[data-rarity="comune"]::before { background: var(--rarity-common); }

#weapon-detail[data-rarity="rara"]::before,
#armor-detail[data-rarity="rara"]::before,
#magic-detail[data-rarity="rara"]::before,
#creature-detail[data-rarity="rara"]::before { background: var(--rarity-rare); }

#weapon-detail[data-rarity="epica"]::before,
#armor-detail[data-rarity="epica"]::before,
#magic-detail[data-rarity="epica"]::before,
#creature-detail[data-rarity="epica"]::before { background: var(--rarity-epic); }

#weapon-detail[data-rarity="leggendaria"]::before,
#armor-detail[data-rarity="leggendaria"]::before,
#magic-detail[data-rarity="leggendaria"]::before,
#creature-detail[data-rarity="leggendaria"]::before { background: var(--rarity-legend); }

#weapon-detail[data-rarity="mitica"]::before,
#armor-detail[data-rarity="mitica"]::before,
#magic-detail[data-rarity="mitica"]::before,
#creature-detail[data-rarity="mitica"]::before { background: var(--rarity-mythic); }

/* 4) Titolo centrato con underline custom (contenuto resto a sinistra) */
#weapon-detail h3,
#armor-detail h3,
#magic-detail h3,
#creature-detail h3 {
  position: relative;
  display: table;       /* larghezza = contenuto, comodo da centrare */
  margin: 0.25rem auto; /* centra orizzontalmente il titolo */
  padding-bottom: 6px;  /* piccolo spazio sopra la linea */
  text-align: center;   /* se il titolo va a capo, resta centrato */
}

/* Pseudo-elemento che fa da "sottolineatura estesa" */
#weapon-detail h3::after,
#armor-detail h3::after,
#magic-detail h3::after,
#creature-detail h3::after {
  content: "";
  position: absolute;
  left: 50%;
  transform: translateX(-50%); /* centra la linea sotto il testo */
  bottom: 0;
  height: 2px;                 /* spessore della sottolineatura */
  width: var(--title-underline-width, 0); /* la settiamo via JS = (larghezza testo + 2cm) */
  background: currentColor;    /* default; viene sovrascritto sotto coi colori rarit√† */
  pointer-events: none;
}

/* Colori underline per rarit√† (stesse tinte della banda) */
#weapon-detail[data-rarity="comune"] h3::after,
#armor-detail[data-rarity="comune"] h3::after,
#magic-detail[data-rarity="comune"] h3::after,
#creature-detail[data-rarity="comune"] h3::after { background: var(--rarity-common); }

#weapon-detail[data-rarity="rara"] h3::after,
#armor-detail[data-rarity="rara"] h3::after,
#magic-detail[data-rarity="rara"] h3::after,
#creature-detail[data-rarity="rara"] h3::after { background: var(--rarity-rare); }

#weapon-detail[data-rarity="epica"] h3::after,
#armor-detail[data-rarity="epica"] h3::after,
#magic-detail[data-rarity="epica"] h3::after,
#creature-detail[data-rarity="epica"] h3::after { background: var(--rarity-epic); }

#weapon-detail[data-rarity="leggendaria"] h3::after,
#armor-detail[data-rarity="leggendaria"] h3::after,
#magic-detail[data-rarity="leggendaria"] h3::after,
#creature-detail[data-rarity="leggendaria"] h3::after { background: var(--rarity-legend); }

#weapon-detail[data-rarity="mitica"] h3::after,
#armor-detail[data-rarity="mitica"] h3::after,
#magic-detail[data-rarity="mitica"] h3::after,
#creature-detail[data-rarity="mitica"] h3::after { background: var(--rarity-mythic); }

/* Mappa un'unica variabile --rarity-accent per evitare ripetizioni */
#weapon-detail[data-rarity="comune"],
#armor-detail[data-rarity="comune"],
#magic-detail[data-rarity="comune"],
#creature-detail[data-rarity="comune"] { --rarity-accent: var(--rarity-common); }

#weapon-detail[data-rarity="rara"],
#armor-detail[data-rarity="rara"],
#magic-detail[data-rarity="rara"],
#creature-detail[data-rarity="rara"] { --rarity-accent: var(--rarity-rare); }

#weapon-detail[data-rarity="epica"],
#armor-detail[data-rarity="epica"],
#magic-detail[data-rarity="epica"],
#creature-detail[data-rarity="epica"] { --rarity-accent: var(--rarity-epic); }

#weapon-detail[data-rarity="leggendaria"],
#armor-detail[data-rarity="leggendaria"],
#magic-detail[data-rarity="leggendaria"],
#creature-detail[data-rarity="leggendaria"] { --rarity-accent: var(--rarity-legend); }

#weapon-detail[data-rarity="mitica"],
#armor-detail[data-rarity="mitica"],
#magic-detail[data-rarity="mitica"],
#creature-detail[data-rarity="mitica"] { --rarity-accent: var(--rarity-mythic); }

/* Glow esterno + sottile bordo interno */
#weapon-detail[data-rarity],
#armor-detail[data-rarity],
#magic-detail[data-rarity],
#creature-detail[data-rarity] {
  box-shadow:
    0 0 0 2px var(--rarity-accent) inset,   /* cornice interna */
    0 0 18px var(--rarity-accent);          /* alone esterno */
}

/* <hr> dentro i popup = tinta rarit√†, pi√π soft */
#weapon-detail[data-rarity] hr,
#armor-detail[data-rarity] hr,
#magic-detail[data-rarity] hr,
#creature-detail[data-rarity] hr {
  border: 0; height: 2px;
  background: var(--rarity-accent);
  opacity: 0.45;
  margin: 10px 0;
}

/* Titolino della sezione caratteristiche (se hai .traits-block .title) */
#weapon-detail[data-rarity] .traits-block .title,
#armor-detail[data-rarity] .traits-block .title,
#magic-detail[data-rarity] .traits-block .title,
#creature-detail[data-rarity] .traits-block .title {
  color: var(--rarity-accent);
  letter-spacing: .02em;
}

/* Ribbon ‚ÄúRarit√†‚Äù in alto a destra ‚Äî versione corretta (abbassato, no wrap) */
#weapon-detail[data-rarity]::after,
#armor-detail[data-rarity]::after,
#magic-detail[data-rarity]::after,
#creature-detail[data-rarity]::after {
  content: attr(data-rarity);
  position: absolute;
  top: 22px;               /* <- prima era 6px: lo abbassiamo per evitare il taglio */
  right: -40px;            /* <- leggermente meno negativo rispetto a -44px */
  transform: rotate(45deg);
  transform-origin: 50% 50%;
  background: var(--rarity-accent);
  color: #fff;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .08em;
  white-space: nowrap;     /* <- evita che ‚Äúleggendaria‚Äù vada a capo */
  padding: 3px 64px;       /* <- prima 2px 56px: un po‚Äô pi√π largo e spesso */
  font-size: 11px;
  line-height: 1.2;
  box-shadow: 0 2px 8px rgba(0,0,0,.25);
  pointer-events: none;
  z-index: 2;              /* sopra la banda (::before) che ha z-index:1 */
}

/* Glow band pi√π visibile per Leggendaria / Mitica */
@keyframes rarityBandGlow {
  0%, 100% { opacity: .55; box-shadow: inset 0 -6px 0 rgba(0,0,0,0); }
  50%      { opacity: 1;   box-shadow: inset 0 -6px 12px rgba(0,0,0,.08); }
}

/* assicura che la banda stia sopra lo sfondo del modal */
#weapon-detail::before,
#armor-detail::before,
#magic-detail::before,
#creature-detail::before {
  z-index: 1; /* sopra il contenuto di background, comunque sotto il testo */
}

/* applica l‚Äôanimazione solo a leggendaria/mitica */
#weapon-detail[data-rarity="leggendaria"]::before,
#armor-detail[data-rarity="leggendaria"]::before,
#magic-detail[data-rarity="leggendaria"]::before,
#creature-detail[data-rarity="leggendaria"]::before,
#weapon-detail[data-rarity="mitica"]::before,
#armor-detail[data-rarity="mitica"]::before,
#magic-detail[data-rarity="mitica"]::before,
#creature-detail[data-rarity="mitica"]::before {
  animation: rarityBandGlow 2.2s ease-in-out infinite;
}

/* ===== Popup Cambia Tipo Eroe ===== */

/* Radio-card come nella scelta iniziale */
#hero-change-list { list-style: none; padding: 0; margin: 10px 0; }
#hero-change-list li {
  background-color: #e8dab8;
  border: 1px solid #b5914a;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  box-shadow: 1px 1px 5px #a88c54;
  transition: background-color 0.3s;
}
#hero-change-list li:hover { background-color: #d1c2a4; }
#hero-change-list li.selected {
  background-color: #b5914a;
  color: #fff8dc;
  font-weight: bold;
  box-shadow: 0 0 10px gold;
}

#hero-change-description {
  font-style: italic;
  margin-top: 10px;
  min-height: 60px;
  color: #3c2d1e;
}

/* Riga costo/oro */
.hero-change-meta {
  display: flex; gap: 12px; align-items: baseline; flex-wrap: wrap;
  margin: 8px 0 4px;
}
.hero-change-meta .cost { font-weight: 700; }
.hero-change-meta .gold { opacity: 0.9; }

/* Messaggi inline (errore/info) */
#hero-change-status { margin-top: 8px; min-height: 20px; }
#hero-change-status .err { color: #b03030; font-weight: 600; }
#hero-change-status .ok  { color: #2f6b2f; font-weight: 600; }

/* ===== Override solo per il modal "Cambia tipo eroe" ===== */
#hero-change-modal {
  /* posizionato un po' pi√π in alto */
  top: 12vh;
  left: 50%;
  transform: translate(-50%, 0); /* niente -50% verticale */

  /* pi√π largo e senza limiti di altezza (niente scroll bar interna) */
  width: min(90vw, 520px);
  max-height: none;
  overflow: visible;
}

/* niente scroll nell'area contenuto del modal eroe */
#hero-change-modal .scroll-area {
  max-height: none !important;
  overflow: visible !important;
}

/* ===== Headline epica per il cambio tipo eroe ===== */
.hero-change-headline {
  margin: 0 0 10px 0;
  text-align: center;
  font-size: 1.15rem;              /* un filo pi√π grande del testo base */
  font-weight: 800;
  letter-spacing: .02em;
  color: #b5914a;                  /* oro caldo come il tema */
  text-shadow: 0 1px 0 #fff8dc, 0 2px 3px rgba(0,0,0,.25);
  border-bottom: 2px solid #b5914a;
  padding-bottom: 6px;
}

/* Pannello conferma (secondo step) */
.confirm-panel {
  margin-top: 12px;
  background: #efe3c4;
  border: 1px solid #b5914a;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 1px 1px 6px rgba(0,0,0,.15) inset;
}
.confirm-panel p {
  margin: 0 0 10px 0;
}
.confirm-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
.hidden { display: none !important; } /* ci serve per mostrare/nascondere il pannello */

/* ===== Modal "Riassetta Abilit√†" ===== */
#abilities-respec-modal {
  position: fixed;
  top: 10vh;               /* stesso posizionamento alto dell'eroe */
  left: 50%;
  transform: translate(-50%, 0);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 18px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 3000;
  width: min(90vw, 520px);
  max-height: none;
  overflow: visible;
  text-align: left;
}
#abilities-respec-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.45);
  z-index: 2500;
}

/* Headline epica (riuso lo stesso stile del cambio eroe) */
#abilities-respec-modal .hero-change-headline {
  margin: 0 0 10px 0;
  text-align: center;
  font-size: 1.15rem;
  font-weight: 800;
  letter-spacing: .02em;
  color: #b5914a;
  text-shadow: 0 1px 0 #fff8dc, 0 2px 3px rgba(0,0,0,.25);
  border-bottom: 2px solid #b5914a;
  padding-bottom: 6px;
}

/* Riga costo/oro come nel cambio eroe */
#abilities-respec-body .hero-change-meta {
  display: flex; gap: 12px; align-items: baseline; flex-wrap: wrap;
  margin: 8px 0 4px;
}
#abilities-respec-body .cost { font-weight: 700; }
#abilities-respec-body .gold { opacity: 0.9; }
#abilities-respec-status { margin-top: 8px; min-height: 20px; }
#abilities-respec-status .err { color: #b03030; font-weight: 600; }
#abilities-respec-status .ok  { color: #2f6b2f; font-weight: 600; }

/* Layer di conferma sopra il modal (come per eroe) */
#abilities-respec-confirm-layer.hidden { display: none !important; }
#abilities-respec-confirm-layer {
  position: absolute;
  inset: 0;
  z-index: 100;            /* sopra i contenuti del modal */
  display: flex;
  align-items: center;
  justify-content: center;
}
#abilities-respec-confirm-layer .confirm-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.45);
}
#abilities-respec-confirm-layer .confirm-dialog {
  position: relative;
  width: min(92vw, 480px);
  background: #efe3c4;
  border: 1px solid #b5914a;
  border-radius: 10px;
  padding: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.4);
}
#abilities-respec-confirm-layer .confirm-dialog p { margin: 0 0 10px 0; }
#abilities-respec-confirm-layer .confirm-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
/* ===== Card "Rituale di riassetto" (sottile, bordo dorato) ===== */
/* Pill "Rituale di riassetto" (piccola, centrata) */
#abilities-respec-card {
  display: block;                 /* cos√¨ possiamo centrarla con auto */
  width: fit-content;             /* si adatta al testo */
  margin: 6px auto 14px;          /* centrata sotto i Punti Abilit√† */
  padding: 6px 14px;
  background: #efe3c4;
  border: 1px solid #b5914a;      /* bordo dorato */
  border-radius: 9999px;          /* pill */
  font-weight: 700;
  font-size: 0.95rem;
  letter-spacing: .02em;
  color: #3c2d1e;
  box-shadow: 0 1px 3px rgba(0,0,0,.15);
  cursor: pointer;
  user-select: none;
  text-align: center;
}
#abilities-respec-card:hover {
  background: #e6d7b2;
  box-shadow: 0 0 10px rgba(218,165,32,.4);
}

/* ===== Sala dei Forzieri ‚Äî versione brillante (come il mock) ===== */
#chest-portal-btn{
  /* layout */
  display: flex;                     /* runa + testo centrati come gruppo */
  align-items: center;
  justify-content: center;
  gap: 12px;
  width: 100%;
  padding: 14px 20px;
  text-align: center;

  /* aspetto base: viola pi√π CHIARO e luminoso */
  background:
    radial-gradient(120% 220% at 50% 0%, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 55%),
    linear-gradient(180deg, #5f49e0 0%, #3d2b8f 60%, #2e2069 100%);
  border: 2px solid #cbb8ff;         /* bordo chiaro */
  border-radius: 18px;                /* pill grande */
  color: #fff6d5 !important;
  font-weight: 800;
  letter-spacing: .02em;
  text-shadow: 0 1px 0 rgba(0,0,0,.55), 0 0 8px rgba(250,238,255,.35);

  /* doppio bordo + glow esterno deciso */
  box-shadow:
    0 0 22px rgba(152,118,255,.55),    /* alone esterno */
    0 0 36px rgba(88,48,255,.35),
    inset 0 0 0 2px rgba(255,255,255,.08),  /* filetto chiaro interno */
    inset 0 2px 0 rgba(0,0,0,.35);          /* lieve incavo alto */

  position: relative;
  transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease, background .12s ease;
}

/* anello interno separato, per il ‚Äúdoppio bordo‚Äù del mock */
#chest-portal-btn::after{
  content: "";
  position: absolute; inset: 4px;
  border: 2px solid rgba(255,255,255,.18);
  border-radius: 14px;
  pointer-events: none;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
}

/* runa: pi√π SOTTILE e molto luminosa */
#chest-portal-btn::before{
  content: '·õü';
  display: inline-block;
  font-size: 1.15em;
  font-weight: 400;                   /* ‚Üê pi√π sottile */
  line-height: 1;
  color: #d9f2ff;                     /* ciano chiaro */
  text-shadow:
    0 0 10px rgba(80,220,255,1),
    0 0 20px rgba(160,130,255,.95),
    0 0 28px rgba(160,130,255,.75);
  filter: saturate(1.2);
}

/* hover: ancora pi√π brillante e leggero sollevamento */
#chest-portal-btn:hover{
  border-color: #e6dbff;
  background:
    radial-gradient(120% 220% at 50% 0%, rgba(255,255,255,.28) 0%, rgba(255,255,255,0) 55%),
    linear-gradient(180deg, #6b55f0 0%, #4a35b5 60%, #362786 100%);
  box-shadow:
    0 0 26px rgba(168,140,255,.62),
    0 0 40px rgba(98,60,255,.40),
    inset 0 0 0 2px rgba(255,255,255,.10),
    inset 0 2px 0 rgba(0,0,0,.35);
  transform: translateY(-1px);
}

/* active: premuto ma sempre brillante */
#chest-portal-btn:active{
  transform: translateY(0);
  box-shadow:
    0 0 20px rgba(156,128,255,.50),
    0 0 32px rgba(88,48,255,.30),
    inset 0 0 0 2px rgba(255,255,255,.06),
    inset 0 2px 0 rgba(0,0,0,.45);
}

/* (facoltativo) respiro di luce molto leggero */
@keyframes mysticPulse {
  0%, 100% {
    box-shadow:
      0 0 22px rgba(152,118,255,.55),
      0 0 36px rgba(88,48,255,.35),
      inset 0 0 0 2px rgba(255,255,255,.08),
      inset 0 2px 0 rgba(0,0,0,.35);
  }
  50% {
    box-shadow:
      0 0 28px rgba(176,150,255,.70),
      0 0 44px rgba(98,60,255,.45),
      inset 0 0 0 2px rgba(255,255,255,.10),
      inset 0 2px 0 rgba(0,0,0,.35);
  }
}
#chest-portal-btn{ animation: mysticPulse 3.8s ease-in-out infinite; }
/* ===== Fascia chiavi Sala dei Forzieri ===== */
.key-belt{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  padding: 10px;
  margin: 6px 0 14px;
  background: rgba(239,227,196,.55);
  border: 1px solid #b5914a;
  border-radius: 10px;
  box-shadow: 0 1px 4px rgba(0,0,0,.12) inset;
}
.key-slot{
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 2px 8px;
}
.key-ico{
  width: 46px;          /* grandezza icona */
  height: auto;
  transform: rotate(38deg);        /* diagonale: ‚Üó */
  transform-origin: 50% 50%;
  filter: drop-shadow(0 1px 1px rgba(0,0,0,.35));
  image-rendering: auto;
}
.key-count{
  position: absolute;
  top: 6px; right: 12px;
  min-width: 22px;
  padding: 1px 6px;
  font-size: 12px;
  text-align: center;
  color: #fff8dc;
  background: #2b1f14;
  border: 1px solid #b5914a;
  border-radius: 999px;
  box-shadow: 0 1px 3px rgba(0,0,0,.25);
  z-index: 2; 
}
.key-label{
  margin-top: 6px;
  font-size: 12px;
  opacity: .9;
}

/* ‚Äî Colorazioni (partendo da un'unica immagine) ‚Äî */
/* === Palette distinta: Verdigris / Argento / Oro / Rubino === */

/* Ottone antico (verdigris) ‚Äì verde ramato */
.key--rame{
  filter:
    sepia(1) hue-rotate(140deg) saturate(2.6) brightness(1.15) contrast(1.05)
    drop-shadow(0 1px 1px rgba(0,0,0,.60))
    drop-shadow(0 0 8px rgba(88,140,96,.55)); /* alone verde */
}

/* Argento azzurrato brillante */
.key--argento{
  filter:
    grayscale(.9) hue-rotate(210deg) saturate(1.2) brightness(1.55) contrast(1.30)
    drop-shadow(0 1px 1px rgba(0,0,0,.60))
    drop-shadow(0 0 8px rgba(150,190,255,.50)); /* alone azzurro */
}

/* Oro reale, caldo e saturo */
.key--oro{
  filter:
    sepia(1) hue-rotate(15deg) saturate(2.9) brightness(1.22) contrast(1.10)
    drop-shadow(0 1px 1px rgba(0,0,0,.60))
    drop-shadow(0 0 10px rgba(255,210,90,.55)); /* alone dorato */
}

/* Rubino arcano (usiamo la classe 'runica' gi√† presente) */
.key--runica{
  filter:
    sepia(1) hue-rotate(335deg) saturate(2.7) brightness(1.20) contrast(1.10)
    drop-shadow(0 1px 1px rgba(0,0,0,.60))
    drop-shadow(0 0 10px rgba(255,110,110,.55)); /* alone rosso */
}


/* Responsivo: su schermi stretti, 2 colonne */
@media (max-width: 540px){
  .key-belt{ grid-template-columns: repeat(2, 1fr); }
}
/* Alone/Glow dietro alla chiave (per contrasto) */
.key-slot{ position: relative; }
.key-ico{ position: relative; z-index: 1; }   /* sopra all'alone */

.key-slot::before{
  content:"";
  position: absolute;
  top: 8px;
  left: 50%;
  width: 56px;
  height: 28px;
  border-radius: 28px;
  transform: translateX(-50%) rotate(35deg);
  filter: blur(6px);
  opacity: .48;
  pointer-events: none;
  z-index: 0;
}

/* Bagliore di sfondo coordinato */
.key-slot[data-key="ottone"]::before{
  background: radial-gradient(closest-side, rgba(88,140,96,.55), rgba(88,140,96,0));
}
.key-slot[data-key="argento"]::before{
  background: radial-gradient(closest-side, rgba(150,190,255,.55), rgba(150,190,255,0));
}
.key-slot[data-key="oro"]::before{
  background: radial-gradient(closest-side, rgba(255,210,90,.60), rgba(255,210,90,0));
}
.key-slot[data-key="runica"]::before{
  background: radial-gradient(closest-side, rgba(255,110,110,.60), rgba(255,110,110,0));
}
/* compattiamo la fascia chiavi */
.key-belt{ padding: 6px 10px; margin: 4px 0 10px; }   /* prima era 10px e 6/14 */
.key-slot{ padding: 2px 2px 4px; }                    /* prima 6px 2px 8px */
.key-label{ margin-top: 2px; font-size: 11px; }      /* meno aria verticale */

/* Layout Sala dei Forzieri: una colonna (niente aside) */
.chests-layout{ display: grid; grid-template-columns: 1fr; gap: 12px; }
.chests-left{ min-width: 0; }

/* Tabs categoria (2√ó2, scuri e leggibili) */
.chest-tabs{
  display: grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: 8px;
  margin: 6px 0 12px;
}
.chest-tab{
  width: 100%;
  padding: 8px 14px;
  border: 1px solid #b5914a;
  border-radius: 999px;
  background: #4a3a27;
  color: #fff8dc;
  cursor: pointer;
  font-weight: 700;
  letter-spacing: .02em;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);
  transition: background .12s ease, box-shadow .12s ease, transform .1s ease;
}
.chest-tab:hover{
  background: #5a4630;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 0 8px rgba(181,145,74,.25);
  transform: translateY(-1px);
}
.chest-tab.is-active{
  background: linear-gradient(180deg, #6b55f0 0%, #3d2b8f 100%);
  border-color: #cbb8ff;
  color: #fff6d5;
  box-shadow:
    inset 0 0 0 2px rgba(255,255,255,.10),
    0 0 12px rgba(156,128,255,.40);
}
@media (max-width: 420px){
  .chest-tabs{ grid-template-columns: 1fr; }
}

/* Griglia forzieri: 2 per riga su desktop, 1 su mobile */
.chest-grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap:12px;
}
@media (max-width: 640px){
  .chest-grid{ grid-template-columns: 1fr; }
}
/* Evita overflow orizzontale nelle due colonne del layout */
.chests-left, .chests-aside{ min-width: 0; }

/* Card forziere ‚Äì equal height e pi√π ‚Äúampie‚Äù */
.chest-card{
  position: relative;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  border: 1px solid #b5914a;
  border-radius: 12px;
  padding: 12px;
  background: #f6ecd1;
  box-shadow: 0 1px 4px rgba(0,0,0,.1);
  min-height: 210px;           /* forza altezze uniformi */
}
.chest-card .head{
  display:flex; align-items:center; justify-content:space-between;
  gap:10px; margin-bottom:8px;
}
.chest-card .name{ font-weight:800; }
.chest-card .keys{ font-size:12px; opacity:.9; }
.chest-card .req{ font-size:12px; opacity:.85; margin:8px 0; }
.rarity-bars{ display:grid; gap:4px; margin:6px 0 8px; font-size:12px; }

/* CTA in fondo per allineare le altezze */
.chest-cta{
  margin-top:auto;
  display:flex; gap:8px; align-items:center; justify-content:space-between;
}

/* Icona forziere base */
.chest-ico{
  width:56px; height:36px; position:relative; border-radius:6px;
  background:#4b3a26;
  box-shadow: inset 0 3px 0 rgba(0,0,0,.35), 0 1px 2px rgba(0,0,0,.25);
}
.chest-ico::before{ /* coperchio */
  content:""; position:absolute; left:0; right:0; top:-8px; height:14px;
  border-radius:6px 6px 0 0; background:#3b2c1b; box-shadow: inset 0 -2px 0 rgba(0,0,0,.35);
}
.chest-ico::after{ /* serratura */
  content:""; position:absolute; left:50%; top:10px; width:10px; height:14px; transform:translateX(-50%);
  background:#e9d8a6; border-radius:2px; box-shadow: inset 0 0 0 1px rgba(0,0,0,.35);
}

/* ‚Äî‚Äî Colori per tier, allineati alle chiavi ‚Äî‚Äî */
/* Mercante (verdigris) */
.tier-mercante .chest-ico{
  background: linear-gradient(180deg,#3f5d4a,#2f4839);
  box-shadow: inset 0 3px 0 rgba(0,0,0,.35), 0 0 10px rgba(88,140,96,.35);
  outline: 2px solid #588c60;
}
.tier-mercante .chest-ico::before{ background:#4f7a62; }
.tier-mercante .chest-ico::after{ background:#d9e6c8; }

/* Avventuriero (ARGENTO) ‚Äî meno blu, pi√π metal */
.tier-avventuriero .chest-ico{
  background: linear-gradient(180deg, #adb3bf 0%, #8e95a2 55%, #6e7582 100%);
  box-shadow:
    inset 0 3px 0 rgba(0,0,0,.35),
    0 0 10px rgba(150,190,255,.28);  /* alone freddo leggero, come la chiave */
  outline: 2px solid #ccd6ea;        /* bordo argento, non blu */
}
.tier-avventuriero .chest-ico::before{ background:#c0c6d2; } /* coperchio pi√π chiaro */
.tier-avventuriero .chest-ico::after{  background:#f2f6ff; } /* serratura argentata */

/* Re (oro) */
.tier-re .chest-ico{
  background: linear-gradient(180deg,#6b4d1b,#5a3f16);
  box-shadow: inset 0 3px 0 rgba(0,0,0,.35), 0 0 10px rgba(255,210,90,.45);
  outline: 2px solid #ffd25a;
}
.tier-re .chest-ico::before{ background:#8a6a2e; }
.tier-re .chest-ico::after{ background:#ffe4a6; }

/* Arcano (rubino) */
.tier-arcano .chest-ico{
  background: linear-gradient(180deg,#5c1e1e,#461313);
  box-shadow: inset 0 3px 0 rgba(0,0,0,.35), 0 0 10px rgba(255,110,110,.55);
  outline: 2px solid #ff6e6e;
}
.tier-arcano .chest-ico::before{ background:#7a2c2c; }
.tier-arcano .chest-ico::after{ background:#ffc9c9; }

/* Barre percentuali rarit√† */
.rarity-bars{ display:grid; gap:4px; margin:6px 0 8px; font-size:12px; }
.rbar{ display:flex; align-items:center; gap:6px; }
.rbar .lab{ width:88px; text-align:right; }
.rbar .bar{ flex:1; height:8px; border-radius:999px; background:#e2d4b1; overflow:hidden; }
.rbar .fill{ height:100%; border-radius:999px; }
.fill.rara{ background:#7aa66c; }
.fill.epica{ background:#7760c6; }
.fill.leggendaria{ background:#d4a33a; }
.fill.mitica{ background:#c24a4a; }

/* CTA e Mostra Drop */
.chest-cta{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
.chest-cta .open-btn{
  padding:6px 10px; border:1px solid #b5914a; border-radius:8px; background:#e6d7b2; cursor:pointer;
}
.chest-cta .open-btn[disabled]{ opacity:.5; cursor:not-allowed; }
.chest-cta .drops-link{ font-size:12px; text-decoration:underline; cursor:pointer; }

/* Badge livello bloccato */
.locked{
  position:absolute; inset:0; background:rgba(0,0,0,.35); border-radius:12px; color:#fff;
  display:flex; align-items:center; justify-content:center; font-weight:800;
}

/* Legend & polvere */
.rarity-legend{ padding:10px; background:rgba(239,227,196,.6); border:1px solid #b5914a; border-radius:10px; margin-bottom:10px; }
.rarity-legend .lg-title{ font-weight:800; margin-bottom:6px; }
.rarity-legend .dot{ display:inline-block; width:10px; height:10px; border-radius:999px; margin-right:6px; vertical-align:-1px; }
.rarity-legend .rarity--rara{ background:#7aa66c; }
.rarity-legend .rarity--epica{ background:#7760c6; }
.rarity-legend .rarity--leggendaria{ background:#d4a33a; }
.rarity-legend .rarity--mitica{ background:#c24a4a; }

.dust-box{ padding:10px; background:rgba(239,227,196,.6); border:1px solid #b5914a; border-radius:10px; }
.dust-box #dust-counter{ font-weight:800; font-size:18px; }

.chest-hint{
  margin: 6px 0 10px;
  font-weight: 800;
  letter-spacing: .02em;
  color: #3c2b18;
  text-shadow: 0 1px 0 rgba(255,255,255,.55);
}
.chest-desc{
  margin: -4px 0 14px;
  font-size: 0.92rem;
  font-weight: 600;
  color: #3c2b18;
  opacity: .9;
  text-shadow: 0 1px 0 rgba(255,255,255,.45);
  max-width: 820px;
}

/* Badge pity progressivo (anello) */
/* Badge pity progressivo (anello) ‚Äì niente pi√π ‚Äúpallino‚Äù al centro */
.chest-card .pity-badge{
  position:absolute; right:10px; top:44px;
  width:40px; height:40px; border-radius:50%;
  --thickness: 6px;

  /* 1) strato sopra: riempie il centro con il fondo della card (#f6ecd1)
     2) strato sotto: l‚Äôanello progressivo */
  background:
    radial-gradient(closest-side, #f6ecd1 calc(50% - var(--thickness)), transparent 0) no-repeat,
    conic-gradient(var(--ring,#4b5563) var(--deg,0deg), transparent 0);

  border:2px solid rgba(0,0,0,.25);
  color:#1f2937;
  font-weight:800; font-size:11px;
  display:flex; align-items:center; justify-content:center;
  text-shadow:none;
  box-shadow:0 0 6px rgba(0,0,0,.2);
}

/* Bottoni Apri: testo scuro e leggibile */
.open-btn{
  color:#2c1e10 !important;
  text-shadow:none !important;
  font-weight:800;
}
.open-btn[disabled]{
  color:#6f6a60 !important;
  opacity:.7;
}
/* Colori barre drop = colori rarit√† dei popup */
.rarity-bars .fill.rara{         background: var(--rarity-rare); }
.rarity-bars .fill.epica{        background: var(--rarity-epic); }
.rarity-bars .fill.leggendaria{  background: var(--rarity-legend); }
.rarity-bars .fill.mitica{       background: var(--rarity-mythic); }

/* === Chest Reward modal: stesso look dei popup inventario === */
#chest-reward-modal {
  position: fixed;
  top: var(--modal-top, 50%);
  left: 50%;
  transform: translate(-50%, 0);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 360px;          /* come gli altri popup dettaglio */
  text-align: left;
  max-height: 88vh;
  overflow: auto;
}
/* come gli altri: clip per la banda alta */
#chest-reward-modal { overflow: hidden; }

/* Titolo centrato con underline calcolata via --title-underline-width */
#chest-reward-modal h3{
  position: relative;
  display: table;
  margin: 0.25rem auto;
  padding-bottom: 6px;
  text-align: center;
}
#chest-reward-modal h3::after{
  content:"";
  position:absolute;
  left:50%; transform:translateX(-50%);
  bottom:0; height:2px; width:var(--title-underline-width,0);
  background: currentColor;
  pointer-events:none;
}

/* Mappo un'unica variabile --rarity-accent come negli altri popup */
#chest-reward-modal[data-rarity="comune"]      { --rarity-accent: var(--rarity-common); }
#chest-reward-modal[data-rarity="rara"]        { --rarity-accent: var(--rarity-rare); }
#chest-reward-modal[data-rarity="epica"]       { --rarity-accent: var(--rarity-epic); }
#chest-reward-modal[data-rarity="leggendaria"] { --rarity-accent: var(--rarity-legend); }
#chest-reward-modal[data-rarity="mitica"]      { --rarity-accent: var(--rarity-mythic); }

/* Banda colorata in alto (3mm) */
#chest-reward-modal::before{
  content:"";
  position:absolute; top:0; left:0; right:0; height:3mm;
  background: var(--rarity-accent);
  pointer-events:none; z-index:1;
}

/* Underline del titolo nel colore della rarit√† */
#chest-reward-modal[data-rarity] h3::after { background: var(--rarity-accent); }

/* Glow esterno + sottile bordo interno come gli altri popup */
#chest-reward-modal[data-rarity]{
  box-shadow:
    0 0 0 2px var(--rarity-accent) inset,
    0 0 18px var(--rarity-accent);
}

/* Ribbon in alto a destra con etichetta della rarit√† */
#chest-reward-modal[data-rarity]::after{
  content: attr(data-rarity);
  position: absolute;
  top: 22px; right: -40px;
  transform: rotate(45deg);
  background: var(--rarity-accent);
  color: #fff; font-weight: 700; text-transform: uppercase;
  letter-spacing: .08em; white-space: nowrap;
  padding: 3px 64px; font-size: 11px; line-height: 1.2;
  box-shadow: 0 2px 8px rgba(0,0,0,.25); pointer-events: none; z-index: 2;
}

/* <hr> e titolino "Caratteristiche" nel colore della rarit√† */
#chest-reward-modal[data-rarity] hr{
  border:0; height:2px; background: var(--rarity-accent); opacity: .45; margin: 10px 0;
}
#chest-reward-modal[data-rarity] .traits-block .title{
  color: var(--rarity-accent);
  letter-spacing: .02em;
}

/* (facoltativo) effetto glow banda per leggendaria/mitica */
@keyframes rarityBandGlow {
  0%,100%{ opacity:.55; box-shadow: inset 0 -6px 0 rgba(0,0,0,0); }
  50%     { opacity:1;   box-shadow: inset 0 -6px 12px rgba(0,0,0,.08); }
}
#chest-reward-modal[data-rarity="leggendaria"]::before,
#chest-reward-modal[data-rarity="mitica"]::before {
  animation: rarityBandGlow 2.2s ease-in-out infinite;
}
/* Popup "Seleziona Creatura": rimuovi la scrollbar interna */
#creature-select-popup .scroll-area {
  max-height: none !important;
  overflow: visible !important;
}
/* === Bottega Arcana === */
.arcane-grid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(180px,1fr));
  gap:12px;
  margin:10px 0;
}
.key-shop-card{
  background:#f6ecd1;
  border:1px solid #b5914a;
  border-radius:12px;
  padding:10px;
  text-align:center;
  box-shadow:0 6px 18px rgba(0,0,0,.12);
}
.key-shop-card .key-ico{
  width:56px; height:auto;
  margin:4px auto 8px auto;
  transform: rotate(38deg);
  transform-origin: 50% 50%;
}
.key-name-btn{
  width:100%;
  margin-top:6px;
}
/* Reset Cristalli: usa le stesse dimensioni dei pulsanti inventario */
#crystal-reset-body .reset-list button.magic-button {
  padding: 6px 10px !important;
  font-size: 14px !important;
  width: 100%;
  margin: 4px 0;
}
/* === Gilda / Stendardo === */
.guild-banner {
  width:min(260px, 92vw);
  height:140px;
  border:1px solid #6b4226;
  border-radius:12px;
  background:#f6ecd1;
  display:flex; align-items:center; justify-content:center;
  box-shadow:0 6px 16px rgba(0,0,0,.25);
}
.guild-banner svg { width: 96%; height: 96%; display:block; }
.guild-actions-grid { display:grid; grid-template-columns:1fr; gap:8px; }
@media (min-width:720px){ .guild-actions-grid { grid-template-columns:1fr 1fr; } }


#guild-screen .magic-button--slim{
  padding: 6px 10px;
  font-size: 14px;
  line-height: 1.1;
}
.linklike{
  background:none;
  border:none;
  padding:0;
  margin:0;
  cursor:pointer;
  font: inherit;
  color: inherit;
}
.linklike:focus{ outline: none; }

/* === Lista Gilde: pulsanti compatti e uniformi === */
.magic-button.guild-mini {
  padding: 6px 10px !important;
  font-size: 13px !important;
  line-height: 1.1;
  min-width: 120px; /* stessa larghezza per "Unisciti" / "Richiedi accesso" */
}
/* === Crea Gilda: input con bordo come la descrizione === */
.guild-input {
  border: 1px solid #6b4226;
  background: #f6ecd1;
  border-radius: 10px;
  padding: 6px 8px;
  width: 100%;
  box-sizing: border-box;
}
/* === Negozio della Gilda (pulsanti split) === */
.guild-shop-list{
  display:grid;
  grid-template-columns:1fr;
  gap:8px;
}
.magic-button.guild-shop-btn{
  display:flex;
  align-items:stretch;
  justify-content:space-between;
  padding:0;               /* gestiamo il padding nelle due sezioni */
  text-align:left;
  font-size: inherit;      /* stesso font-size dei bottoni bottega (magic-button: 18px) */
  line-height:1.2;
}
.guild-shop-btn .label{
  flex:1;
  padding:10px 12px;       /* coerente con magic-button base */
}
.guild-shop-btn .cost{
  min-width:140px;
  padding:8px 12px;
  border-left:1px solid #6b4226; /* separatore */
  background:#d1c2a4;            /* tono leggermente diverso */
  color:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  border-top-right-radius:8px;
  border-bottom-right-radius:8px;
}
.guild-shop-btn:disabled{
  opacity:0.7;
  cursor:default;
}
/* Riga oro del negozio: leggermente pi√π grande (stile botteghe) */
#guild-shop-gold-line{
  font-size:18px;
}
/* Etichetta non in grassetto; il prezzo a destra resta evidenziato */
.guild-shop-btn,
.guild-shop-btn .label{
  font-weight:400;
}
/* Pulsante "Oggetto segreto" del Negozio Gilda */
.guild-shop-secret-btn{
  position: relative;
  outline: 2px solid #e53935;
  box-shadow: 0 0 8px rgba(229,57,53,.6), inset 0 0 0 1px rgba(0,0,0,.15);
  animation: gs-pulse 1.8s ease-in-out infinite;
}
.guild-shop-secret-btn .label{
  font-weight:400; /* il segreto pu√≤ essere in evidenza */
}
@keyframes gs-pulse{
  0%{ box-shadow: 0 0 6px rgba(229,57,53,.5), inset 0 0 0 1px rgba(0,0,0,.15); }
  50%{ box-shadow: 0 0 16px rgba(229,57,53,.85), inset 0 0 0 1px rgba(0,0,0,.15); }
  100%{ box-shadow: 0 0 6px rgba(229,57,53,.5), inset 0 0 0 1px rgba(0,0,0,.15); }
}
/* Barra Salute compattissima accanto al testo */
.hero-health-row{
  display:inline-flex;
  align-items:center;        /* centra verticalmente con il ‚Äú100‚Äù */
  gap:8px;
  flex-wrap:wrap;            /* va a capo su schermi stretti */
}
.hero-health-row strong{ margin-right:4px; }

/* Lunga quanto ‚ÄúCategoria‚Äù ‚âà 9 caratteri */
.hp-bar{
  display:inline-block;
  width:9ch;
  height:0.6em;
  background:rgba(0,0,0,.15);
  border:1px solid #000;          /* ‚Üê bordino nero sottile sull‚Äôintera barra */
  border-radius:9999px;
  overflow:hidden;
  vertical-align:middle;
}
.hp-fill{
  display:block;
  height:100%;
  width:0%;
  transition:width .25s linear, background-color .25s linear;
}
.hp-fill.hp-green  { background:#2ecc71; }
.hp-fill.hp-yellow { background:#f1c40f; }
.hp-fill.hp-orange { background:#e67e22; }
.hp-fill.hp-red    { background:#e74c3c; }
#potion-buttons-list > button.magic-button {
  padding: 6px 10px;
  font-size: 0.95em;
  line-height: 1.2;
  margin: 4px 0;
}
#potion-list button.magic-button {
  padding: 6px 10px !important;
  font-size: 14px !important;
  width: 100%;
}
/* Bottoni inventario: stesso look&size dei bottoni di bottega (full width) */
#inventory .magic-button.magic-button--compact {
  padding: 8px !important;     /* come i bottoni standard */
  font-size: 18px !important;   /* come i bottoni standard */
  line-height: 1.2 !important;

  display: block !important;    /* uno sotto l‚Äôaltro */
  width: 100% !important;
  box-sizing: border-box !important;
}

/* Spaziatura verticale tra i bottoni */
#inventory .magic-button.magic-button--compact + .magic-button.magic-button--compact {
  margin-top: 6px;
}

}
/* Sala degli Eroi */
.table-wrap { overflow:auto; max-height: 60vh; border: 1px solid #000; }
.hero-table { width: 100%; border-collapse: collapse; }
.hero-table th, .hero-table td { padding: 8px; border-bottom: 1px solid #222; text-align: left; }
/* Header chiaro e testo scuro per la Sala degli Eroi */
.hero-table thead th {
  position: sticky;
  top: 0;
  background: #efe3c6;   /* beige chiaro in tema */
  color: #111;           /* testo quasi nero */
  z-index: 1;
  font-weight: 700;
  border-bottom: 2px solid #c9b48c; /* leggero contrasto */
}

.pager {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 10px 0 16px;
}
#hero-hall-pageinfo { flex: 1; text-align: center; }
.link-button {
  background: none;
  border: none;
  color: inherit;
  text-decoration: underline;
  cursor: pointer;
  font: inherit;
  padding: 0;
}
.link-button:hover { text-decoration: none; }
/* ====== Profilo Eroe ====== */

/* Finestra dati */
.hero-card {
  background: #efe3c6;        /* beige chiaro in tema */
  border: 1px solid #c9b48c;
  border-radius: 8px;
  padding: 12px;
  margin-top: 12px;
  box-shadow: 0 1px 0 rgba(0,0,0,0.25);
}
.hero-profile-info > div { margin: 6px 0; }

/* Pulsante top "‚Üê Indietro" (uguale misura al torna indietro in bottega) */
.hero-back-line {
  display: block;
  width: 100%;
  box-sizing: border-box;
  padding: 10px;
  font-size: 18px;
  line-height: 1.2;
  text-align: center;
  margin-top: 8px;
}

/* Contenitore azioni e bottoni azione (stessa logica dei 'torna indietro' bottega) */
.hero-profile-actions {
  margin-top: 20px;
}
.hero-profile-actions .hero-action {
  display: block;
  width: 100%;
  box-sizing: border-box;
  padding: 10px;
  font-size: 18px;
  line-height: 1.2;
  text-align: center;
  margin-bottom: 8px;
}

/* Stato disabilitato leggibile */
.hero-profile-actions .hero-action[disabled] {
  opacity: 0.7;
  cursor: not-allowed;
}
/* Spaziatura compatta del titolo nella pagina Profilo Eroe */
#hero-profile-view h2 {
  margin-top: 4px;
  margin-bottom: 8px;
}
/* Colore coerente per i pulsanti della barra messaggi in ogni vista */
#message-nav .magic-button,
#message-nav .magic-button.magic-button--slim {
  background-color: #6b4226 !important;  /* stesso colore dei ‚Äúricevuti‚Äù */
  color: #fff8dc !important;
  border: 1px solid #3c2d1e;
}
#message-nav .magic-button:hover,
#message-nav .magic-button.magic-button--slim:hover {
  background-color: #8c5a3c !important;
}
/* Sfide: font pi√π piccolo ma nitido */
#challenges .sfide-compact,
#challenges .sfide-compact * {
  font-size: 13px;     /* ‚Üë da 12px a 13px: di solito molto pi√π leggibile */
  line-height: 1.3;
}
/* Sfide: label energia pi√π grande (override del compatto) */
#challenges .sfide-compact #sfide-energy .label {
  font-size: 16px !important;  /* usa !important per vincere l'ordine pari specificit√† */
}

#challenges .sfide-compact {
  -webkit-font-smoothing: auto;   /* evita smoothing "troppo leggero" */
  -moz-osx-font-smoothing: auto;
  text-rendering: optimizeLegibility;
}

/* Tabelle un filo pi√π compatte senza schiacciare troppo */
#challenges .sfide-compact th,
#challenges .sfide-compact td {
  padding: 6px 6px;
  font-weight: 500;    /* leggermente pi√π ‚Äúcorposo‚Äù, aiuta la nitidezza */
}

/* Mantieni il titolo un pelo pi√π grande per gerarchia visiva */
#challenges .sfide-compact .title {
  font-size: 18px;
  line-height: 1.3;
}

/* Mini bottone 'Sfida' proporzionato */
#challenges .sfide-compact .mini-button {
  padding: 3px 8px;
  font-size: 12px;
}
/* Sfide: header tabella in grassetto */
#challenges .sfide-compact table.hero-table thead th {
  font-weight: 700;
}
/* === Cornice fantasy SOLO per il mio profilo (pulsante Eroe) =============== */
#hero-profile .my-hero-card{
  position: relative;
  /* pergamena chiara con leggero chiarore superiore */
  background:
    radial-gradient(120% 180% at 50% 0%, rgba(255,255,255,.35) 0%, rgba(255,255,255,0) 55%),
    linear-gradient(180deg, #f7f0d9 0%, #efe3c6 100%);
  /* bordo dorato a effetto ‚Äúmetallo antico‚Äù */
  border: 2px solid transparent;
  border-image: conic-gradient(from 180deg,
                #e9d8a6, #b8923a, #8b6c2e, #b8923a, #e9d8a6) 1;
  border-radius: 16px;
  padding: 22px 18px 18px;
  margin-top: 12px;
  margin-bottom: 20px;
  box-shadow:
    0 2px 10px rgba(0,0,0,.18),
    inset 0 1px 0 rgba(255,255,255,.35);
  color: #2a241b;
}

/* filetto interno per profondit√† */
#hero-profile .my-hero-card::after{
  content:"";
  position:absolute;
  inset:10px;
  border-radius: 12px;
  border: 1px solid rgba(139,104,43,.5);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.25);
  pointer-events:none;
}

/* rivetti/gemme agli angoli */
#hero-profile .my-hero-card::before{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  background:
    radial-gradient(circle at 16px 16px,                     #e7d39a 0 4px, #8a6a2a 4.5px, transparent 5px),
    radial-gradient(circle at calc(100% - 16px) 16px,        #e7d39a 0 4px, #8a6a2a 4.5px, transparent 5px),
    radial-gradient(circle at 16px calc(100% - 16px),        #e7d39a 0 4px, #8a6a2a 4.5px, transparent 5px),
    radial-gradient(circle at calc(100% - 16px) calc(100% - 16px),
                                                           #e7d39a 0 4px, #8a6a2a 4.5px, transparent 5px);
}

/* tipografia e spaziatura pi√π curata dentro la card */
#hero-profile .my-hero-card > *{
  position: relative; /* sopra ai pseudo-elementi */
  z-index: 1;
}
#hero-profile .my-hero-card .muted{ color:#4b3f2c; }
#hero-profile .my-hero-card p{ margin: 8px 0; }

/* Mano Destra: margine minimo tutt'intorno, allineato a sinistra */
#hero-profile .my-hero-card button.magic-label-button[onclick="openHandPopup('right')"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;   /* ‚âà 1 mm su tutti i lati */
  padding: 3px 9px !important;/* piccolo padding interno, per ‚Äúrespiro‚Äù visivo */
  text-align: left !important;
  vertical-align: middle;     /* allineamento perfetto in linea */
}


/* La riga che contiene "Mano Destra" parte da sinistra */
#hero-profile .my-hero-card .magic-line:has(> button[onclick="openHandPopup('right')"]){
  justify-content: flex-start;  /* a sinistra */
  width: 100%;
  gap: 8px;                     /* spazio tra etichetta e valore */
  text-align: left;
}
/* Mano Sinistra: margine/padding minimi, allineato a sinistra */
#hero-profile .my-hero-card button.magic-label-button[onclick="openHandPopup('left')"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;     /* ‚âà 1 mm su tutti i lati */
  padding: 3px 9px !important;  /* come Mano Destra */
  text-align: left !important;
  vertical-align: middle;
}

/* La riga che contiene "Mano Sinistra" parte da sinistra */
#hero-profile .my-hero-card .magic-line:has(> button[onclick="openHandPopup('left')"]){
  justify-content: flex-start;
  width: 100%;
  gap: 8px;
  text-align: left;
}
/* Magia: margine/padding minimi, allineato a sinistra */
#hero-profile .my-hero-card button.magic-label-button[onclick="openMagicPopup()"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;     /* ‚âà 1 mm su tutti i lati */
  padding: 3px 9px !important;  /* come mano dx/sx */
  text-align: left !important;
  vertical-align: middle;
}

/* La riga che contiene "Magia" parte da sinistra */
#hero-profile .my-hero-card .magic-line:has(> button[onclick="openMagicPopup()"]){
  justify-content: flex-start;
  width: 100%;
  gap: 8px;
  text-align: left;
}
/* Armatura: margine/padding minimi, allineato a sinistra */
#hero-profile .my-hero-card button.magic-label-button[onclick="openArmorSelect()"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;     /* ‚âà 1 mm su tutti i lati */
  padding: 3px 9px !important;  /* uniforme con gli altri slot */
  text-align: left !important;
  vertical-align: middle;
}

/* La riga che contiene "Armatura" parte da sinistra */
#hero-profile .my-hero-card .magic-line:has(> button[onclick="openArmorSelect()"]){
  justify-content: flex-start;
  width: 100%;
  gap: 8px;
  text-align: left;
}
/* Creatura: margine/padding minimi, allineato a sinistra */
#hero-profile .my-hero-card button.magic-label-button[onclick="openCreatureSelect()"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;     /* ‚âà 1 mm su tutti i lati */
  padding: 3px 9px !important;  /* come gli altri slot */
  text-align: left !important;
  vertical-align: middle;
}

/* La riga che contiene "Creatura" parte da sinistra */
#hero-profile .my-hero-card .magic-line:has(> button[onclick="openCreatureSelect()"]){
  justify-content: flex-start;
  width: 100%;
  gap: 8px;
  text-align: left;
}
/* Spazio extra tra "Oro" e "Mano Destra" */
#hero-profile .my-hero-card #hero-gold{
  margin-bottom: 22px !important;
}
/* Separatore decorativo dorato con simbolo centrale ‚öúÔ∏è */
#hero-profile .my-hero-card #hero-motto::after{
  content: "‚öúÔ∏è";
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin: 20px auto 4px;
  width: 62% !important;         /* un po' pi√π corta */
  max-width: 420px;               /* limite assoluto: evita linee troppo lunghe */
  color: #b8923a;
  font-size: 16px;
  text-shadow: 0 0 5px rgba(185,146,58,0.6);
  position: relative;
}


/* Linee dorate ai lati del simbolo */
#hero-profile .my-hero-card #hero-motto::before{
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 75%;
  height: 2px;
  background: linear-gradient(90deg, 
              rgba(185,146,58,0),
              #b8923a 20%, 
              #b8923a 80%, 
              rgba(185,146,58,0));
  border-radius: 2px;
  box-shadow: 0 0 4px rgba(185,146,58,0.6);
  transform: translate(-50%, -50%);
  z-index: -1;
}
/* Allineamento a sinistra per Mano Destra e Mano Sinistra */
#hero-profile .my-hero-card p.magic-line:has(> strong > button[onclick="openHandPopup('right')"]),
#hero-profile .my-hero-card p.magic-line:has(> strong > button[onclick="openHandPopup('left')"]) {
  display: flex;
  align-items: center;
  justify-content: flex-start; /* allinea tutto a sinistra */
  gap: 8px;
  text-align: left;
}
/* Allineamento a sinistra per la riga Creatura */
#hero-profile .my-hero-card p.magic-line:has(> strong > button[onclick="openCreatureSelect()"]) {
  display: flex;
  align-items: center;
  justify-content: flex-start; /* allinea tutto a sinistra */
  gap: 8px;                    /* piccolo spazio tra etichetta e nome */
  text-align: left;
}
#hero-profile .my-hero-card #hero-level{
  display: inline-block;     /* <- rende efficace il margin-bottom */
  margin-bottom: 8px !important; /* metti il valore che preferisci */
}
/* Magia: riga allineata a sinistra */
#hero-profile .my-hero-card p.magic-line:has(> strong > button[onclick="openMagicPopup()"]){
  display: flex;
  align-items: center;
  justify-content: flex-start; /* tutto a sinistra */
  gap: 8px;                    /* spazio tra etichetta e valore */
  text-align: left;
}
/* === Toast / notifiche leggere (centrali) === */
#toast-container{
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* centra davvero */
  z-index: 99999;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  pointer-events: none;
}
.toast{
  background: #2b2b2b;
  color: #fff;
  padding: 10px 14px;
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,.25);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity .2s ease, transform .2s ease;
  text-align: center;                     /* centratura testo */
  max-width: min(90vw, 520px);            /* dimensione ragionevole */
}
.toast.ok   { border-left: 4px solid #2ecc71; }
.toast.warn { border-left: 4px solid #f39c12; }
.toast.err  { border-left: 4px solid #e74c3c; }
.toast.show { opacity: 1; transform: translateY(0); }

/* Icone relazioni gilda (alleanze/guerre) */
.ally-icon { margin-left: 4px; }
.war-icon  { margin-left: 4px; color: #c62828; } /* rosso */

/* Motto: pulsante compatto come Mano DX/SX */
#hero-profile .my-hero-card button.magic-label-button[onclick="openMottoScreen()"]{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;    /* ‚âà 1 mm */
  padding: 3px 9px !important; /* come gli altri slot */
  text-align: center !important;
  vertical-align: middle;
}

/* Riga contenitore del bottone Motto: centrata e con poco spazio */
#hero-profile .my-hero-card #hero-motto-header{
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 2px 0 0 !important;  /* dimezza lo spazio sotto il bottone */
  gap: 6px;
}

/* Testo del motto: vicinissimo al bottone e base per il separatore sotto */
#hero-profile .my-hero-card #hero-motto{
  text-align: center;
  margin-top: 2px !important;  /* ancora meno spazio sopra il motto */
  position: relative;           /* serve per l'::before assoluto del separatore */
}
/* Reliquia di guerra: pulsante compatto come il Motto */
#hero-profile .my-hero-card #btn-war-relics{
  display: inline !important;
  width: auto !important;
  margin: 1.5px !important;
  padding: 3px 9px !important;
  text-align: center !important;
  vertical-align: middle;
}

/* Riga contenitore del bottone Reliquia: centrata e con poco spazio */
#hero-profile .my-hero-card #war-relics-header{
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 2px 0 0 !important;
  gap: 6px;
}
/* === Separatore dorato (profilo ALTRUI) ‚Äî stesso stile del profilo personale === */
#hero-profile-view #other-hero-sep{
  position: relative;
  display: block;
  width: 100%;
}
#hero-profile-view #other-hero-sep::after{
  content: "‚öúÔ∏è";
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin: 20px auto 12px;
  width: 62% !important;      /* coerente col tuo profilo */
  max-width: 420px;
  color: #b8923a;
  font-size: 16px;
  text-shadow: 0 0 5px rgba(185,146,58,0.6);
  position: relative;         /* sta sopra la linea */
  z-index: 1;
}

#hero-profile-view #other-hero-sep::before{
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 75%;
  height: 2px;
  background: linear-gradient(90deg,
              rgba(185,146,58,0),
              #b8923a 20%,
              #b8923a 80%,
              rgba(185,146,58,0));
  border-radius: 2px;
  box-shadow: 0 0 4px rgba(185,146,58,0.6);
  transform: translate(-50%, -50%);
  z-index: 0;                 /* non negativo: resta dentro la card */
}
/* --- BADGE "Miniera della Gilda": riusa lo stesso stile dei badge esistenti --- */
#g-mine-btn { position: relative; } /* se lo hai gi√† messo non fa nulla di male */
#g-mine-btn #g-mine-dot.dot {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: red;       /* stessa tinta dei badge gi√† presenti */
  display: block;        /* evita che resti inline / in basso */
  z-index: 2;
  pointer-events: none;
}
/* Nasconde quando la classe .hidden √® presente (coerente con gli altri) */
#g-mine-btn #g-mine-dot.hidden { display: none !important; }

.weapon-thumb{
  display: block;
  margin: 0 auto 12px auto;
  width: 150px;
  height: 150px;
  object-fit: contain;

  /* Cornice */
  padding: 10px;
  border-radius: 14px;
  border: 3px solid #8b6a2b;

  /* Effetto fantasy */
  background:
    radial-gradient(circle at top,
      rgba(255,215,150,0.25),
      rgba(0,0,0,0.15) 70%),
    linear-gradient(145deg,
      #2b1f10,
      #1a1208);

  box-shadow:
    inset 0 0 12px rgba(0,0,0,0.6),
    0 6px 18px rgba(0,0,0,0.45);
}
/* === FIX: popup pozioni senza scrollbar interna === */
#potion-detail{
  position: fixed;
  top: var(--modal-top, 50%);
  left: 50%;
  transform: translate(-50%, 0);
  background: #f5f1e1;
  border: 3px solid #6b4226;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 0 15px #00000088;
  z-index: 1000;
  width: 360px;
  text-align: left;

  /* se serve, scrolla il popup intero, NON il body interno */
  max-height: 88vh;
  overflow: auto;
}

#potion-detail-body{
  max-height: none !important;
  overflow: visible !important;
}

/* neutralizza la .scroll-area solo dentro alle pozioni */
#potion-detail .scroll-area{
  max-height: none !important;
  overflow: visible !important;
}

/* overlay coerente (se vuoi uniformarlo agli altri) */
#potion-overlay{
  position: fixed;
  inset: 0;
  background: transparent;
  z-index: 999;
}
/* === FIX: pulsanti equip/vendi pi√π bassi nei popup === */
#weapon-detail .magic-button,
#armor-detail .magic-button,
#magic-detail .magic-button,
#creature-detail .magic-button,
#potion-detail .magic-button {
  padding: 4px 10px !important;   /* era ~10‚Äì12px */
  font-size: 0.85rem !important;
  line-height: 1.1 !important;
  min-height: unset !important;
}

/* === FIX: rettangolo effetto extra arma pi√π basso === */
#weapon-detail .traits-block {
  padding: 6px 8px !important;   /* riduce altezza interna */
}

#weapon-detail .traits-block .traits-grid {
  row-gap: 2px !important;
}

#weapon-detail .traits-block div {
  line-height: 1.15 !important;
  margin: 0 !important;
}
#tutorial-screen { text-align: center; }

.tutorial-card {
  margin: 10px auto;
  max-width: 520px;
  text-align: left;
}

.tutorial-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: flex-end;
  margin-top: 10px;
}
/* ===== Tutorial: pulsanti pi√π "stretti" (solo nel tutorial) ===== */
#tutorial-screen .magic-button{
  padding: 6px 10px;     /* prima erano 10px */
  font-size: 14px;       /* prima 18px */
  margin: 4px 0;         /* prima 8px 0 */
  line-height: 1.2;
}
/* ===== FIX iPhone: bottoni non sotto la barra (safe-area) ===== */
:root{
  --modal-gap: 16px; /* respiro dal bordo */
}

/* iOS old fallback */
@supports (padding: constant(safe-area-inset-bottom)){
  :root{
    --safe-bottom: constant(safe-area-inset-bottom);
    --safe-top: constant(safe-area-inset-top);
  }
}
/* iOS modern */
@supports (padding: env(safe-area-inset-bottom)){
  :root{
    --safe-bottom: env(safe-area-inset-bottom);
    --safe-top: env(safe-area-inset-top);
  }
}

@media (max-width: 600px){
  #weapon-detail,
  #armor-detail,
  #magic-detail,
  #creature-detail,
  #crystals-modal,
  #crystal-spend-modal,
  #extra-effect-modal {
    /* invece del ‚Äúcentrato‚Äù, lo teniamo DENTRO la safe area */
    top: calc(var(--safe-top, 0px) + var(--modal-gap)) !important;
    bottom: calc(var(--safe-bottom, 0px) + var(--modal-gap)) !important;
    left: 50% !important;

    /* niente translateY: cos√¨ il bottom non finisce sotto */
    transform: translateX(-50%) !important;

    /* altezza = tra top e bottom -> scroll interno garantito */
    max-height: none !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;

    /* spazio extra in fondo: i bottoni non vengono ‚Äúmangiati‚Äù */
    padding-bottom: calc(20px + var(--safe-bottom, 0px) + 12px) !important;

    /* su mobile meglio un filo pi√π largo ma dentro schermo */
    width: min(92vw, 360px) !important;
  }
}
/* üëá INCOLLA QUESTO SUBITO QUI SOTTO */
@media (max-width: 600px){
  #weapon-detail .modal-actions{
    padding-bottom: var(--safe-bottom, 0px);
  }
}
  </style>
</head>
<body>
<div class="container" id="main">
<h1>Mitharia</h1>
<div id="login-section">
<h2>Login</h2>
<div style="
  text-align:center;
  font-size:15px;
  line-height:1.4;
  margin-bottom:18px;
  padding:12px 14px;
  color:#2c1e12;
  background: rgba(255,245,230,0.55);
  border: 1px solid rgba(140,100,60,0.55);
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.35);
">

  <strong style="font-size:17px; color:#2c1e12;">
    Benvenuto, valoroso avventuriero!
  </strong>

  <div style="margin-top:8px; font-weight:400;"> 
    Oltre queste porte ti attende <strong>Mitharia</strong>, un mondo di sfide,
    misteri e antichi tesori.<br>
    Forgerai la tua leggenda affrontando missioni, creature leggendarie
    e oscure minacce.<br>
    Scegli il tuo destino, potenzia il tuo eroe e unisciti a una gilda
    per diventare un mito.<br>
    La storia inizia ora‚Ä¶ sei pronto?
  </div>

</div>


<input id="username" placeholder="Nickname" type="text"/>
<input id="password" placeholder="Password" type="password"/>
<label><input id="remember" type="checkbox"/> Ricorda password</label>
<button onclick="login()">Entra</button>
<p>Non hai un account? <a href="#" onclick="showRegister()">Registrati</a></p>
</div>
<div class="hidden" id="register-section">
<h2>Registrazione</h2>
<div style="
  text-align:center;
  font-size:15px;
  line-height:1.4;
  margin-bottom:18px;
  padding:12px 14px;
  color:#2c1e12;
  background: rgba(255,245,230,0.55);
  border: 1px solid rgba(140,100,60,0.55);
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.35);
">

  <strong style="font-size:17px; color:#2c1e12;">
    Benvenuto, valoroso avventuriero!
  </strong>

  <div style="margin-top:8px; font-weight:400;"> 
    Oltre queste porte ti attende <strong>Mitharia</strong>, un mondo di sfide,
    misteri e antichi tesori.<br>
    Forgerai la tua leggenda affrontando missioni, creature leggendarie
    e oscure minacce.<br>
    Scegli il tuo destino, potenzia il tuo eroe e unisciti a una gilda
    per diventare un mito.<br>
    La storia inizia ora‚Ä¶ sei pronto?
  </div>

</div>


<input
  id="reg-username"
  placeholder="Nickname"
  type="text"
  minlength="3"
  maxlength="12"
  required
/>
<input id="reg-password" placeholder="Password" type="password"/>
<input id="reg-email" placeholder="Email" type="email"/>

<button onclick="register()">Registrati</button>
<p>Hai gi√† un account? <a href="#" onclick="showLogin()">Login</a></p>
</div>
<div class="hidden" id="hero-choice">
<h2>Scegli il tuo eroe</h2>
<ul id="hero-choice-list">
<li data-hero="Umano">Umano</li>
<li data-hero="Orco">Orco</li>
<li data-hero="Elfo">Elfo</li>
<li data-hero="Nano">Nano</li>
<li data-hero="Draconide">Draconide</li>
<li data-hero="Demone">Demone</li>
<li data-hero="Bestiale">Bestiale</li>
<li data-hero="Nonmorto">Nonmorto</li>
</ul>
<div id="hero-description">Seleziona un eroe per vedere la descrizione.</div>
<button disabled id="hero-confirm-btn" onclick="confirmHero()">Conferma</button>
</div>
<div class="hidden" id="menu">
  <h2>Benvenuto, <span id="user-display"></span></h2>

  <button class="menu-button" onclick="showHeroProfile()">üßù‚Äç‚ôÇÔ∏è Eroe</button>
  <button class="menu-button" onclick="showInventory()">üéí Inventario</button>
  <button class="menu-button" onclick="showChallenges()">‚öîÔ∏è Sfide e Dungeon</button>
  <button class="menu-button" onclick="showMissions()">
  üéØ Missioni e Quest
  <span id="missions-badge" class="dot hidden"></span>
</button>
  <button class="menu-button" onclick="showShop()">üè∞ Bottega e Forzieri</button>
  <button class="menu-button crystal-btn" onclick="showCrystalsScreen()">
  <img src="cristallo_emoji.png" alt="Cristallo" class="crystal-icon">
  <span class="crystal-label">Cristalli di Potenziamento</span>
</button>
<button class="menu-button" onclick="showHeroHall()">
  <span class="menu-ico">üèõÔ∏è</span> Sala degli Eroi
</button>
<button class="menu-button" onclick="showGuildScreen()">üõ°Ô∏è Gilda <span id="guild-badge" class="dot hidden"></span></button>
  <button class="menu-button" onclick="showTutorial()">üìò Tutorial</button>
  <button class="menu-button" onclick="showMessages()">‚úâÔ∏è Messaggistica <span id="messages-badge"></span></button>
  <button class="menu-button" onclick="showLeaderboard()">üèÜ Classifica</button>
  <button class="menu-button" onclick="showSettings()">‚öôÔ∏è Impostazioni</button>
  <button class="menu-button" onclick="logout()">üö™ Logout</button>
</div>

<div class="hidden" id="tutorial-screen">
  <h2>üìò Tutorial</h2>
  <div id="tutorial-body"></div>
</div>

<div class="hidden" id="hero-profile">
<h2>Profilo Eroe</h2>
  <div class="my-hero-card">
<div id="hero-name-tag" style="margin:4px 0 10px; font-size:16px; font-weight:700; color:#000;"></div>
<p><strong class="magic-line">
  <button class="magic-label-button" onclick="openHeroChange()">Tipo Eroe:</button>
  <span id="hero-type"></span>
</strong></p>
<p class="magic-line shield-row"
   style="justify-content:center; margin-top:4px; margin-bottom:4px;">

  <span id="shield-link"
      style="text-decoration:underline; cursor:pointer; white-space:nowrap;"
      onclick="openShieldPopup()">
  üõ°Ô∏è Scudo<span id="shield-active-label"></span>
</span>
</p>
<p class="hero-health-row">
  <strong>Salute:</strong>
  <span id="hero-hp">100</span>/<span id="hero-hp-max">100</span>
  <span class="hp-bar" aria-hidden="true"><span id="hero-hp-bar" class="hp-fill"></span></span>
</p>

<p>
  <strong>Livello:</strong>
  <span id="hero-level">1</span>
  (
  <span id="hero-xp">0</span> /
  <span id="hero-xp-needed">40</span> XP
  )
</p>
<p>
  <strong>EXP totale guadagnata:</strong>
  <span id="hero-xp-total">0 XP</span>
</p>
<p>
  <strong>Potenza eroe:</strong>
  <span id="hero-power">0</span>
</p>
<p id="hero-gold">
  <strong>Oro:</strong> 0 monete d'oro
</p>


<!-- ‚Äî‚Äî‚Äî Motto personale ‚Äî‚Äî‚Äî -->
<div class="magic-line" id="hero-motto-header" style="justify-content:center; text-align:center;">
  <strong><u><button class="magic-label-button" onclick="openMottoScreen()">Motto personale</button></u></strong>
</div>
<div id="hero-motto" style="text-align:center; margin-top:3px;"></div>
<!-- ‚Äî‚Äî‚Äî fine motto personale ‚Äî‚Äî‚Äî -->

<!-- === Reliquia di guerra: bottone + slot pubblicato === -->
<div id="war-relics-header" style="text-align:center; margin-top:6px; display:none;">
  <strong><u><button
    id="btn-war-relics"
    class="magic-label-button"
    onclick="openWarRelicsScreen()"
  >Reliquia di guerra</button></u></strong>
</div>
<div id="war-relics-published" style="margin-top:6px;"></div>

<p class="magic-line">
  <strong><button class="magic-label-button" onclick="openHandPopup('right')">Mano Destra:</button></strong>
  <span id="right-hand-display" class="equip-display">Nessuna</span>
</p>

<p class="magic-line">
  <strong><button class="magic-label-button" onclick="openHandPopup('left')">Mano Sinistra:</button></strong>
  <span id="left-hand-display" class="equip-display">Nessuna</span>
</p>

<p class="magic-line">
  <strong><button class="magic-label-button" onclick="openMagicPopup()">Magia:</button></strong>
  <span id="selected-magic" class="equip-display">Nessuna</span>
</p>

<div class="magic-line">
  <button class="magic-label-button" onclick="openArmorSelect()">Armatura:</button>
  <span id="equipped-armor">Nessuna</span>
</div>

<p class="magic-line">
  <strong><button class="magic-label-button" onclick="openCreatureSelect()">Creatura:</button></strong>
<span id="equipped-creature">Nessuna</span>
</p>

<p><strong class="magic-line">
  <button class="magic-label-button" onclick="showAbilities()">Abilit√†</button>
<span id="ability-points-badge" class="pill-badge" style="display:none"></span>
</strong></p>
</div>
<button onclick="goBack()">Torna Indietro</button>
</div>
<div class="hidden" id="magic-popup">
<h3>Inserisci Magia</h3>
<div class="magic-option" onclick="selectMagic('Fuoco')">Fuoco</div>
<div class="magic-option" onclick="selectMagic('Acqua')">Acqua</div>
<div class="magic-option" onclick="selectMagic('Vento')">Vento</div>
<div class="magic-option" onclick="selectMagic('Ghiaccio')">Ghiaccio</div>
<div class="magic-option" onclick="selectMagic('Fulmine')">Fulmine</div>
<div class="magic-option" onclick="selectMagic('Terra')">Terra</div>
<div class="magic-option" onclick="selectMagic('Luce')">Luce</div>
<div class="magic-option" onclick="selectMagic('Oscurit√†')">Oscurit√†</div>
<br/>
<button onclick="removeMagic()" style="background-color: #b03030;">Elimina</button>
<button onclick="closeMagicPopup()">Chiudi</button>
</div>
<div class="hidden" id="hand-popup">
  <h3 id="hand-popup-title">Seleziona Arma</h3>
  <div id="hand-weapon-options"></div>
  <br/>
  <button onclick="removeWeapon()" style="background-color: #b03030;">Elimina</button>
  <button onclick="closeHandPopup()">Chiudi</button>
</div>

<div class="hidden" id="motto-screen">
  <h2>Motto Personale</h2>
  <p>Inserisci il tuo motto personale. Tutti i motti inseriti vengono archiviati. 
     Frasi che vadano a violare il regolamento porteranno alla tua espulsione.</p>

  <label for="motto-input"><strong>Motto (max 45 caratteri)</strong></label>
  <input id="motto-input" type="text" maxlength="45" 
         placeholder="Es.: Il fato favorisce gli audaci"
         style="width:100%; box-sizing:border-box; padding:10px; font-size:16px; margin:6px 0 12px;">

  <div style="display:flex; gap:10px; flex-wrap:wrap;">
    <button class="menu-button" id="motto-confirm">Conferma</button>
    <button class="menu-button" id="motto-back">Torna indietro</button>
  </div>
</div>

<!-- === Schermata: Reliquie di guerra === -->
<div class="hidden" id="warrel-screen">
  <div class="traits-block">
    <div class="title">Reliquie di guerra</div>
    <div id="warrel-body" class="traits-grid" style="grid-template-columns:1fr;"></div>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button class="mini-button mini-button--dark" id="warrel-back">‚Üê Torna indietro</button>
      <button class="mini-button" id="warrel-clear">Elimina pubblicazione</button>
    </div>
  </div>
</div>

<div class="hidden" id="abilities">
  <h2>Abilit√†</h2>
  <p id="ability-points-display"><strong>Punti Abilit√† disponibili:</strong> 0</p>
  <!-- Card: Rituale di riassetto -->
<!-- Pill: Rituale di riassetto -->
<div id="abilities-respec-card"
     role="button"
     tabindex="0"
     aria-label="Rituale di riassetto"
     onclick="openAbilitiesRespec()"
     onkeydown="if(event.key==='Enter'||event.key===' '){openAbilitiesRespec();event.preventDefault();}">
  Rituale di riassetto
</div>

<div id="abilities-list"></div>

  <button id="abilities-save" class="menu-button" style="display:none">Salva</button>
  <button onclick="showHeroProfile()" class="menu-button">Torna indietro</button>
</div>

<div class="hidden" id="settings">
<h2>Impostazioni</h2>
<button onclick="deleteAccount()">Cancella Account</button>
<button onclick="goBack()">Torna Indietro</button>
</div>
<div class="hidden" id="inventory">
  <h2>Deposito Personale</h2>
  <button class="magic-button magic-button--compact" onclick="showWeapons()">Armi</button>
  <button class="magic-button magic-button--compact" onclick="showArmors()">Armature</button>
  <button class="magic-button magic-button--compact" onclick="showMagicStorage()">Magie</button>
  <button class="magic-button magic-button--compact" onclick="showCreatures()">Creature</button>
  <button class="magic-button magic-button--compact" onclick="showPotionStorage()">Pozioni</button>
  <button onclick="goBack()">Torna Indietro</button>
</div>
<div class="hidden" id="weapon-storage">
<h2>Armi</h2>
<ul id="weapon-list"></ul>
<button onclick="backToInventory()">Indietro</button>
</div>
<div class="hidden" id="magic-storage">
<h2>Magie</h2>
<ul id="magic-list"></ul>
<button onclick="backToInventory()">Indietro</button>
</div>
<div class="hidden" id="armor-storage">
<h2>Armature</h2>
<ul id="armor-list"></ul>
<button onclick="backToInventory()">Indietro</button>
</div>
<div class="hidden" id="creature-storage">
<h2>Creature</h2>
<ul id="creature-list"></ul>
<button onclick="backToInventory()">Indietro</button>
</div>
<div class="hidden" id="potion-storage">
  <h2>Pozioni</h2>
  <ul id="potion-list"></ul>
  <button onclick="backToInventory()">Indietro</button>
</div>

<div class="hidden" id="shop">
<h2>Bottega</h2>
<button class="magic-button magic-button--compact" onclick="showWeaponShop()">Bottega delle Armi</button>
<button class="magic-button magic-button--compact" onclick="showArmorShop()">Bottega delle Armature</button>
<button class="magic-button magic-button--compact" onclick="showMagicShop()">Bottega delle Magie</button>
<button class="magic-button magic-button--compact" onclick="showCreatureShop()">Bottega delle Creature</button>
<button class="magic-button magic-button--compact" onclick="showPotionShop()">Bottega delle Pozioni</button>
<button class="magic-button magic-button--compact" onclick="showArcaneShop()">Bottega Arcana</button>
<button id="chest-portal-btn" class="menu-button chest-portal" onclick="showChestsRoom()">
  Sala dei Forzieri
</button>
<button onclick="goBack()">Torna Indietro</button>
</div>
<div class="hidden" id="chest-room">
  <h2>Sala dei Forzieri</h2>

  <!-- Fascia chiavi possedute -->
  <div id="key-belt" class="key-belt">
    <div class="key-slot" data-key="ottone" title="Chiave del Mercante">
      <img class="key-ico key--rame" src="imgkey-blank.png" alt="">
      <span class="key-count" id="key-count-ottone">0</span>
      <div class="key-label">Chiave del Mercante</div>
    </div>

    <div class="key-slot" data-key="argento" title="Chiave dell‚ÄôAvventuriero">
      <img class="key-ico key--argento" src="imgkey-blank.png" alt="">
      <span class="key-count" id="key-count-argento">0</span>
      <div class="key-label">Chiave dell‚ÄôAvventuriero</div>
    </div>

    <div class="key-slot" data-key="oro" title="Chiave del Re">
      <img class="key-ico key--oro" src="imgkey-blank.png" alt="">
      <span class="key-count" id="key-count-oro">0</span>
      <div class="key-label">Chiave del Re</div>
    </div>

    <div class="key-slot" data-key="runica" title="Chiave Arcana">
      <img class="key-ico key--runica" src="imgkey-blank.png" alt="">
      <span class="key-count" id="key-count-runica">0</span>
      <div class="key-label">Chiave Arcana</div>
    </div>
  </div>

<p class="chest-hint">Seleziona l‚Äôequipaggiamento</p>
<p class="chest-desc">
  Nella Sala dei Forzieri puoi ottenere armi, armature, magie e creature di rarit√† superiore (Rara, Epica, Leggendaria, Mitica).
  Pi√π la rarit√† √® alta, migliori saranno le caratteristiche. Guadagna Polvere Arcana e chiavi completando attivit√† e quest,
  seleziona l'equipaggiamento e apri il forziere.
</p>

  <!-- Layout: tabs categoria + griglia forzieri -->
<div class="chests-layout">
  <div class="chests-left">
    <!-- Tabs categoria (2√ó2, nessun tab selezionato di default) -->
    <div class="chest-tabs">
      <button class="chest-tab is-active" data-cat="armi" onclick="selectChestCategory('armi')">Armi</button>
      <button class="chest-tab" data-cat="armature" onclick="selectChestCategory('armature')">Armature</button>
      <button class="chest-tab" data-cat="magie" onclick="selectChestCategory('magie')">Magie</button>
      <button class="chest-tab" data-cat="creature" onclick="selectChestCategory('creature')">Creature</button>
    </div>

    <!-- Griglia dei 4 forzieri (riempita via JS) -->
    <div id="chest-grid" class="chest-grid"></div>

    <!-- Polvere Arcana SOTTO ai forzieri -->
    <div class="dust-box" style="margin-top:12px;">
      <div class="lg-title">Polvere Arcana</div>
      <div id="dust-counter">0</div>
    </div>
  </div> <!-- /chests-left -->
</div> <!-- /chests-layout -->


  <br/>
  <button class="menu-button" onclick="showShop()">Torna alla Bottega</button>
</div>

<div class="hidden" id="magic-shop">
  <h2>Bottega delle Magie</h2>
  <p><strong>Oro disponibile:</strong> <span id="magic-shop-gold"></span> monete d'oro</p>
  <div id="magic-buttons-list"></div>
  <div id="magic-details" class="hidden"></div>
  <button onclick="goBackFromMagicShop()">Torna Indietro</button>
</div>
<div class="hidden" id="weapon-shop">
  <h2>Bottega delle Armi</h2>
  <p><strong>Oro disponibile:</strong> <span id="weapon-shop-gold"></span> monete d'oro</p>
  <div id="weapon-buttons-list"></div>
  <div id="weapon-details" class="hidden"></div>
  <button onclick="goBackFromWeaponShop()">Torna Indietro</button>
</div>
<div class="hidden" id="creature-shop">
  <h2>Bottega delle Creature</h2>
  <p><strong>Oro disponibile:</strong> <span id="creature-shop-gold"></span> monete d'oro</p>
  <div id="creature-buttons-list"></div>
  <div id="creature-details" class="hidden"></div>
  <button onclick="goBackFromCreatureShop()">Torna Indietro</button>
</div>
<div class="hidden" id="potion-shop">
  <h2>Bottega delle Pozioni</h2>
  <p><strong>Oro disponibile:</strong> <span id="potion-shop-gold"></span> monete d'oro</p>
  <div id="potion-buttons-list"></div>
  <div id="potion-details" class="hidden"></div>
  <button onclick="goBackFromPotionShop()">Torna Indietro</button>
</div>

<div class="hidden" id="armor-shop">
  <h2>Bottega delle Armature</h2>
  <p><strong>Oro disponibile:</strong> <span id="armor-shop-gold"></span> monete d'oro</p>
  <div id="armor-buttons-list"></div>
  <div id="armor-details" class="hidden"></div>
  <button onclick="goBackFromArmorShop()">Torna Indietro</button>
</div>
<div class="hidden" id="arcane-shop">
  <h2>Bottega Arcana</h2>
  <p><strong>Polvere Arcana:</strong> <span id="arcane-dust-amount">0</span></p>

  <div id="arcane-items-list" class="arcane-grid"></div>

  <button onclick="goBackFromArcaneShop()">Torna Indietro</button>
</div>

<!-- ==== Sezione Sfide e Dungeon ==== -->
<div id="challenges" class="hidden">
  <h2>Sfide e Dungeon</h2>

  <!-- Qui dentro costruiamo i tab via JS (Sfide / Dungeon) -->
  <div id="challenges-root"></div>

  <div style="margin-top:10px;">
    <button onclick="goBack()">Men√π principale</button>
  </div>
</div>

<!-- ==== /Sezione Sfide e Dungeon ==== -->
<!-- üîÆ CRISTALLI DI POTENZIAMENTO ‚Äî PAGINA -->
<div id="crystals-screen" class="hidden">
  <h2>Cristalli di Potenziamento</h2>

  <!-- corpo dinamico -->
  <div id="crystals-screen-body" style="margin-top:10px;"></div>

  <!-- azioni principali -->
  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px;">
    <button id="crystals-fuse-btn" class="magic-button">Fondi</button>
    <button id="crystals-use-btn"  class="magic-button">Usa cristalli</button>
<button class="magic-button" id="crystals-reset-btn">Ripristina cristalli</button>
  </div>

  <!-- back -->
  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="backFromCrystalsScreen()">Torna indietro</button>
  </div>
</div>
<!-- üîß USA CRISTALLI ‚Äî PAGINA -->
<div id="crystal-spend-screen" class="hidden">
  <h2>Usa Cristalli</h2>
  <div id="crystal-spend-body" style="margin-top:10px;"></div>
  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="goToMainMenu()">Men√π principale</button>
  </div>
</div>
<!-- ======= CRISTALLI (Ripristina) ‚Äì Pagina ======= -->
<div id="crystal-reset-screen" class="hidden">
  <h2>Ripristina Cristalli</h2>

  <div id="crystal-reset-body" style="margin-top:10px;"></div>

  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="goToMainMenu()">Men√π principale</button>
  </div>
</div>
<!-- üîß CRISTALLI (Fusione) ‚Äì Pagina -->
<div id="crystal-fuse-screen" class="hidden">
  <h2>Fondi Cristalli</h2>

  <div id="crystal-fuse-body" style="margin-top:10px;"></div>

  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="backFromFuseCrystalsScreen()">Torna indietro</button>
  </div>
</div>

<!--  SALA DEGLI EROI ‚Äî PAGINA -->
<div class="hidden" id="hero-hall">
  <h2>Sala degli Eroi</h2>

  <div style="margin: 8px 0;">
  <input id="hero-hall-search" type="text" placeholder="Cerca per nome..." style="width:100%; padding:8px; box-sizing:border-box;">
</div>

  <div class="table-wrap">
    <table class="hero-table">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Tag</th>
          <th style="text-align:left;">Nome</th>
          <th>Livello</th>
          <th>Punti</th>
        </tr>
      </thead>
      <tbody id="hero-hall-body">
        <!-- righe generate via JS -->
      </tbody>
    </table>
  </div>

  <div id="hero-hall-pager" class="pager">
    <button id="hero-hall-prev" class="magic-button magic-button--compact">Pagina precedente</button>
    <span id="hero-hall-pageinfo"></span>
    <button id="hero-hall-next" class="magic-button magic-button--compact">Pagina successiva</button>
  </div>

  <button onclick="backFromHeroHall()">Indietro</button>
</div>
<!-- üèÜ CLASSIFICA ‚Äî PAGINA -->
<div id="leaderboard" class="hidden">
  <h2>Classifica</h2>
  <div id="leaderboard-root"></div>

  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="goBack()">Men√π principale</button>
  </div>
</div>

<!-- PROFILO EROI ‚Äî PAGINA -->
<div id="hero-profile-view" class="hidden" style="padding:8px 16px 16px;">
  <h2>Profilo Eroe</h2>

  <button class="mini-button mini-button--dark" onclick="backFromHeroProfile()">‚Üê Indietro</button>

  <!-- Scheda dati eroe in ‚Äúfinestra‚Äù -->
  <div class="hero-card">
    <div id="hero-profile-info" class="hero-profile-info"></div>
  </div>

  <!-- Azioni (stessa grandezza/centro testo come i 'torna indietro' in bottega) -->
  <div class="hero-profile-actions">
  <button id="hero-challenge" class="hero-action" disabled>Sfida</button>
  <button id="hero-send-message" class="hero-action" disabled>Invia messaggio</button>
  <button class="hero-action" onclick="goToMenu()">Torna indietro</button>
</div>
</div>


<!-- üõ°Ô∏è GILDA ‚Äî PAGINA -->
<div id="guild-screen" class="hidden">
  <h2>Gilda</h2>

  <!-- Corpo dinamico -->
  <div id="guild-screen-body" style="margin-top:10px;"></div>

  <!-- back -->
  <div class="back-button-container" style="margin-top:16px;">
    <button type="button" onclick="backFromGuildScreen()">Torna indietro</button>
  </div>
</div>
<!-- GILDA ‚Äî MEMBRI (finestra in stile Sala degli Eroi) -->
<div id="guild-members-view" class="hidden">
  <h2 id="gm-title">Membri di Gilda</h2>
<div class="back-button-container" style="margin:8px 0;">
  <button id="gm-back-guild" type="button" class="mini-button mini-button--dark">‚Üê Indietro</button>
</div>
<!-- Stato Diplomazia: alleanze/guerre correnti -->
<div id="gm-diplobox" class="muted" style="display:none; margin:6px 0; padding:8px; border:1px dashed #d0caa9; border-radius:8px;">
  <!-- riempito via JS -->
</div>
  <div style="margin: 8px 0;">
    <input id="gm-search" type="text" placeholder="Cerca per nome..." style="width:100%; padding:8px; box-sizing:border-box;">
  </div>

  <div class="table-wrap">
    <table class="hero-table">
      <thead>
  <tr>
    <th>Tag</th>
    <th>Nome</th>
    <th>Classe</th>
    <th>Livello</th>
    <th>Punti</th>
  </tr>
</thead>

      <tbody id="gm-body">
        <!-- righe generate via JS -->
      </tbody>
    </table>
  </div>

  <div id="gm-pager" class="pager hidden">
    <button id="gm-prev" class="magic-button magic-button--compact">Pagina precedente</button>
    <span id="gm-pageinfo"></span>
    <button id="gm-next" class="magic-button magic-button--compact">Pagina successiva</button>
  </div>

  <div class="back-button-container" style="margin-top:16px;">
  <button id="gm-back-main" type="button">Torna indietro</button>
</div>
</div>

<!-- ===== Schermata: Messaggio Collettivo ===== -->
<div class="hidden" id="guild-broadcast-screen">
  <div class="traits-block">
    <div class="title">Messaggio collettivo</div>
    <div class="traits-grid" style="grid-template-columns:1fr;">
      <textarea id="guild-broadcast-text" rows="6" placeholder="Scrivi qui il testo da inviare a tutti i membri..." style="width:100%; resize:vertical;"></textarea>
    </div>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button class="mini-button mini-button--dark" id="guild-broadcast-send">Invia</button>
      <button class="mini-button" id="guild-broadcast-back">Torna indietro</button>
    </div>
  </div>
</div>

<div id="missions" class="hidden">
  <h2>Missioni</h2>
  <div id="mission-active-box" class="hidden">
    <p><strong>Missione in corso:</strong> <span id="mission-active-name"></span></p>
    <p><strong>Tempo rimanente:</strong> <span id="mission-countdown">--:--</span></p>
  </div>
<!-- QUI: overlay + popup messaggio -->



  <div id="missions-list"></div>

  <button onclick="goBack()">Torna Indietro</button>
</div>
<!-- üîΩ QUI sotto aggiungi il nuovo popup dettaglio missione -->
<div class="hidden" id="mission-detail">
  <h3 id="mission-detail-title">Titolo missione</h3>
  <p id="mission-detail-desc"></p>
  <p id="mission-detail-diff"></p>
  <p id="mission-detail-rew"></p>
  <p id="mission-detail-dur"></p>
  <button id="mission-detail-start">Avvia Missione</button>
  <button onclick="closeMissionDetail()" style="margin-top:8px;">Torna indietro</button>
</div>
<!-- üîº Fine popup dettaglio missione -->
<div id="messages" class="hidden">
  <h2>Messaggistica <span id="messages-unread-label" class="muted"></span></h2>
<!-- TOOLBAR: solo elimina selezionati -->
<div id="message-toolbar" style="display:flex; gap:8px; align-items:center; margin:8px 0;">
  <button id="msg-delete-selected" class="btn-danger" style="display:none;">Elimina selezionati</button>
</div>

<!-- LISTA -->
<div id="message-list"></div>

<!-- PAGINAZIONE: IN FONDO, VERTICALE, SOPRA IL TUO "TORNA INDIETRO" -->
<div id="message-pagination" style="display:flex; flex-direction:column; gap:8px; align-items:stretch; margin:12px 0;">
  <button id="msg-prev" class="magic-button" style="width:100%;">‚Äπ Pagina precedente</button>
  <button id="msg-next" class="magic-button" style="width:100%;">Pagina successiva ‚Ä∫</button>
  <div id="msg-page-label" class="muted" style="text-align:center;"></div>
</div>

  <div id="message-list"></div>

  <div id="message-detail" class="hidden" style="margin-top:12px;">
    <h3 id="msg-title"></h3>
    <div id="msg-meta" style="font-size:0.9em; opacity:0.8; margin-bottom:6px;"></div>
    <div id="msg-body" style="text-align:left; background:#fff8dc; border:2px solid #6b4226; padding:12px; border-radius:8px;"></div>
    <button style="margin-top:12px;" onclick="closeMessageDetail()">Torna alla lista</button>
  </div>
<!-- NAV MESSAGGI (sotto la numerazione di pagina, sopra "Torna Indietro") -->
<div id="message-nav" style="display:flex; gap:0px; flex-wrap:wrap; margin:4px 0;">
  <button id="msg-compose-open" class="magic-button">Invia un messaggio</button>
  <button id="msg-go-inbox" class="magic-button">Messaggi ricevuti</button>
  <button id="msg-go-sent" class="magic-button">Messaggi inviati</button>
  <button id="msg-go-arch" class="magic-button">Messaggi archiviati</button>
</div>

<!-- COMPOSER (pagina di composizione) -->
<div id="message-compose" class="hidden" style="margin-top:10px;">
  <div class="traits-block">
    <div class="title">Nuovo messaggio</div>
    <div class="traits-grid" style="grid-template-columns:1fr;">
      <label>Destinatario
        <input id="msg-to" style="max-width:280px; border:1px solid #000; border-radius:4px; padding:4px;">
      </label>
      <label>Testo
        <textarea id="msg-body-input" rows="5" style="width:100%;"></textarea>
      </label>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="msg-send" class="magic-button">Invia</button>
        <button id="msg-compose-back" class="mini-button mini-button--dark">Torna indietro</button>
      </div>
    </div>
  </div>
</div>

  <button style="margin-top:16px;" onclick="goBack()">Men√π principale</button>
</div>
<!-- === Finestra dettaglio messaggio (NON popup) === -->
<section id="message-window" class="hidden" style="padding:12px;">
  <h2 id="message-window-title" style="margin:0 0 8px 0;">Messaggio</h2>

  <div id="message-window-body" class="scroll-area"
       style="background:#fffbe8;border:1px solid #b79146;border-radius:10px;padding:10px;
              box-shadow:0 6px 18px rgba(0,0,0,.18);min-height:120px;text-align:left;"></div>

  <div class="mw-actions" style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end;">
    <button id="msgwin-delete" class="btn-danger hidden" onclick="deleteOpenMessage()">Elimina</button>
    <!-- ‚¨áÔ∏è NEW -->
    <button id="msgwin-reply" class="magic-button hidden" onclick="replyToOpenMessage()">Rispondi</button>
    <!-- ‚¨ÜÔ∏è NEW -->
    <button id="msgwin-back" class="magic-button" onclick="closeMessageDetail()">‚Üê Torna ai messaggi</button>
  </div>
</section>


</div> <!-- fine .container -->
<script>
// --- GAME STORAGE VIA storage.js ---

let currentUser = null;
let currentWeaponPage = 1; 
// Descrizioni eroi
const heroDescriptions = {
  Umano: "Creature versatili e ingegnose, gli umani non eccellono in nulla ma possono adattarsi a qualsiasi situazione. Il loro vero punto di forza √® la determinazione.",
  Orco: "Massicci e feroci, gli orchi vivono per la battaglia. La loro potenza fisica √® ineguagliabile, anche se spesso sottovalutano la strategia.",
  Elfo: "Eleganti e longevi, gli elfi hanno un legame profondo con la natura e le arti arcane. Preferiscono agilit√† e astuzia alla forza bruta.",
  Nano: "Piccoli ma indomabili, i nani sono esperti guerrieri e artigiani. Resistenti e testardi, non abbandonano mai i loro alleati.",
  Draconide: "Discendenti dei draghi, i draconidi hanno scaglie robuste e un‚Äôaura imponente. Alcuni sviluppano un respiro elementale, altri una forza sovrumana.",
  Demone: "Nati dalle tenebre, i demoni possiedono poteri arcani innati. La loro sete di distruzione li rende temuti ovunque vadano.",
  Bestiale: "Uomini con tratti animali, i bestiali sono rapidi, agili e guidati dall‚Äôistinto. Vivono in armonia con i loro sensi acuti.",
  Nonmorto: "Spiriti inquieti legati a un corpo decadente. Resistenti al dolore e alla paura, ma condannati a una vita di fredde emozioni."
};

// === Lingua: "alla stirpe dei/degli <PluralRazza>" ===
function heroPluralInfo(sing) {
  const map = {
    Umano:     { plural: 'Umani',     art: 'degli' },
    Orco:      { plural: 'Orchi',     art: 'degli' },
    Elfo:      { plural: 'Elfi',      art: 'degli' },
    Nano:      { plural: 'Nani',      art: 'dei'   },
    Draconide: { plural: 'Draconidi', art: 'dei'   },
    Demone:    { plural: 'Demoni',    art: 'dei'   },
    Bestiale:  { plural: 'Bestiali',  art: 'dei'   },
    Nonmorto:  { plural: 'Nonmorti',  art: 'dei'   }
  };
  const k = String(sing || '').trim();
  if (map[k]) return map[k];
  const plural = italianPlural(k);
  return { plural, art: articleForPlural(plural) };
}
function italianPlural(s) {
  if (!s) return s;
  // co/go -> chi/ghi (es. Orco‚ÜíOrchi, Drago‚ÜíDraghi)
  if (/co$/i.test(s)) return s.replace(/co$/i, 'chi');
  if (/go$/i.test(s)) return s.replace(/go$/i, 'ghi');
  if (/o$/i.test(s))  return s.replace(/o$/i, 'i');
  if (/a$/i.test(s))  return s.replace(/a$/i, 'e');
  if (/e$/i.test(s))  return s.replace(/e$/i, 'i');
  return s + 'i';
}
function articleForPlural(pl) {
  // 'degli' prima di vocale o gruppi speciali; altrimenti 'dei'
  return (/^[aeiou]/i.test(pl) || /^(s[bcdfghjklmnpqrstvwxyz]|z|gn|ps|x|y)/i.test(pl))
    ? 'degli' : 'dei';
}

// === Toast helpers (GLOBALI) ===
(function () {
  if (window.showToast) return; // evita doppie definizioni

  window.ensureToastContainer = function () {
    let c = document.getElementById('toast-container');
    if (!c) {
      c = document.createElement('div');
      c.id = 'toast-container';
      document.body.appendChild(c);
    }
    return c;
  };

  window.showToast = function (text, type = 'ok', duration = 3000) {
    const c = window.ensureToastContainer();
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.innerHTML = (typeof escapeHtml === 'function')
      ? escapeHtml(String(text))
      : String(text);
    c.appendChild(t);
    requestAnimationFrame(() => t.classList.add('show'));
    const close = () => { t.classList.remove('show'); setTimeout(() => t.remove(), 200); };
    setTimeout(close, duration);
  };
})();

  // helper per posizionare i popup sotto al titolo sezione
  function positionModalBelowSectionTitle(modal, sectionSelector, offsetPx = 16) {
    const h2 = document.querySelector(sectionSelector + ' h2');
    if (!h2 || !modal) return;

    const r = h2.getBoundingClientRect();
    const desired = Math.round(r.bottom + offsetPx);

    const h = modal.offsetHeight || 0;
const vv = window.visualViewport;
const viewportH = vv ? vv.height : window.innerHeight;
const maxTop = Math.max(16, viewportH - h - 16);
const topPx = Math.min(Math.max(16, desired), maxTop);


    modal.style.setProperty('--modal-top', topPx + 'px');
  }

 // üëá parte facoltativa: ricalcolo quando ridimensiono la finestra
  window.addEventListener('resize', () => {
    const modal = document.querySelector(
      '#weapon-detail:not(.hidden), ' +
      '#armor-detail:not(.hidden), ' +
      '#magic-detail:not(.hidden), ' +
      '#creature-detail:not(.hidden)'
    );
    if (!modal) return;

    const map = [
      ['#weapon-shop',    '#weapon-storage'],
      ['#armor-shop',     '#armor-storage'],
      ['#magic-shop',     '#magic-storage'],
      ['#creature-shop',  '#creature-storage'],
    ];

    for (const [shop, inv] of map) {
      if (document.querySelector(shop) && !document.querySelector(shop).classList.contains('hidden')) {
        positionModalBelowSectionTitle(modal, shop, 16);
        return;
      }
      if (document.querySelector(inv) && !document.querySelector(inv).classList.contains('hidden')) {
        positionModalBelowSectionTitle(modal, inv, 16);
        return;
      }
           }
       });

/* Posiziona un popup poco sotto il campo "Tipo Eroe" del profilo */
function positionModalUnderHeroType(modal, offsetPx = 12) {
  if (!modal) return;
  // bottone "Tipo Eroe:" nel profilo (fallback all'H2 "Profilo Eroe")
  const anchor =
    document.querySelector('#hero-profile button[onclick^="openHeroChange"]') ||
    document.querySelector('#hero-profile h2');
  if (!anchor) return;

  const r = anchor.getBoundingClientRect();
  const desired = Math.round(r.bottom + offsetPx);

  // calcola una quota valida visibile (con margine di 16px)
  const h = modal.offsetHeight || 0;
  const maxTop = Math.max(16, window.innerHeight - h - 16);
  const topPx = Math.min(Math.max(16, desired), maxTop);

  modal.style.setProperty('--modal-top', topPx + 'px');
}

function formatGold(value) {
  return Number(value).toLocaleString('it-IT');
}
// Applica attributo data-rarity e calcola la larghezza underline = (larghezza testo + 2cm)
function applyRarityDecor(modalEl, titleEl, rarityKey) {
  if (!modalEl || !titleEl) return;
  const key = String(rarityKey || 'comune').trim().toLowerCase(); // <- normalizza
  modalEl.setAttribute('data-rarity', key);

  requestAnimationFrame(() => {
    const w = titleEl.getBoundingClientRect().width || 0;
    modalEl.style.setProperty('--title-underline-width', `calc(${Math.round(w)}px + 2cm)`);
  });
}

function fmtDateTime(ts) {
  const d = new Date(ts);
  // Usa formato locale senza secondi
  return d.toLocaleString([], {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

function showLogin() {
  document.getElementById('login-section').classList.remove('hidden');
  document.getElementById('register-section').classList.add('hidden');
}
function showInventory() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('inventory').classList.remove('hidden');
}
function backToInventory() {
  document.getElementById('weapon-storage').classList.add('hidden');
  document.getElementById('magic-storage').classList.add('hidden');
  document.getElementById('armor-storage').classList.add('hidden');
  document.getElementById('creature-storage').classList.add('hidden');
  document.getElementById('potion-storage').classList.add('hidden'); // üëà aggiunta
  document.getElementById('inventory').classList.remove('hidden');
  // chiudi eventuale popup pozioni aperto
  if (typeof closePotionDetail === 'function') closePotionDetail();
}


function showWeapons() {
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('weapon-storage').classList.remove('hidden');
  _invPage.weapons = 1;
populateStorage('weapon-list', 'weapons', 1);

}
// === Catalogo Magie (descrizioni estese + caratteristiche 1..15) ===
const magicItems = [
  {
    name: 'Fuoco',
    price: 2000,
    desc: [
      'Evoca una palla di fuoco che esplode all‚Äôimpatto, incendiando l‚Äôarea.',
      'Il calore destabilizza i nemici e pu√≤ innescare effetti a catena.',
      'Efficace contro gruppi serrati o creature vulnerabili al fuoco.',
      'Richiede controllo: l‚Äôarea d‚Äôeffetto pu√≤ colpire anche alleati distratti.'
    ].join(' '),
    traits: { Danno: 11, Velocit√†: 7 },
  rarity: 'comune'
  },
  {
    name: 'Acqua',
    price: 2000,
    desc: [
      'Convoglia un getto pressurizzato che spezza la guardia e raffredda le armi.',
      'Il fluire costante riduce l‚Äôaccuratezza degli avversari.',
      'Pu√≤ spegnere incendi e neutralizzare effetti di fuoco.',
      'Ottima per mantenere il controllo del campo senza eccessivo consumo.'
    ].join(' '),
    traits: { Danno: 7, Velocit√†: 10 },
  rarity: 'comune'
  },
  {
    name: 'Vento',
    price: 2000,
    desc: [
      'Un colpo d‚Äôaria tagliente che sbilancia e arretra i nemici.',
      'Ideale per interrompere incantesimi o colpi caricati.',
      'Apre varchi nella formazione avversaria con spinte controllate.',
      'Molto rapido da lanciare, con basso impegno di concentrazione.'
    ].join(' '),
    traits: { Danno: 6, Velocit√†: 12 },
  rarity: 'comune'
  },
  {
    name: 'Ghiaccio',
    price: 2000,
    desc: [
      'Cristallizza l‚Äôaria in schegge che rallentano i movimenti.',
      'Pu√≤ immobilizzare parzialmente i bersagli pi√π deboli.',
      'Sinergico con colpi mirati che sfruttano la rigidit√† del ghiaccio.',
      'Richiede tempismo: l‚Äôeffetto √® potente ma non istantaneo.'
    ].join(' '),
    traits: { Danno: 8, Velocit√†: 8 },
  rarity: 'comune'
  },
  {
    name: 'Fulmine',
    price: 2200,
    desc: [
      'Scarica elettricit√† a catena, rimbalzando tra bersagli vicini.',
      'Eccelle contro gruppi e nemici metallici.',
      'Il lampo √® quasi istantaneo, difficile da evitare.',
      'Serve precisione per non dissipare l‚Äôenergia su oggetti conduttivi.'
    ].join(' '),
    traits: { Danno: 7, Velocit√†: 12 },
  rarity: 'comune'
  },
  {
    name: 'Terra',
    price: 2400,
    desc: [
      'Richiama pietre e frammenti che travolgono il nemico.',
      'Pu√≤ erigere brevi barriere per riparo tattico.',
      'Impatto pesante che incrina difese e postura.',
      'Richiede un attimo di concentrazione per ‚Äúsentire‚Äù il terreno.'
    ].join(' '),
    traits: { Danno: 12, Velocit√†: 6 },
  rarity: 'comune'
  },
  {
    name: 'Luce',
    price: 2600,
    desc: [
      'Canalizza energia radiante che purifica e cura lievi ferite.',
      'Acceca temporaneamente gli avversari rivolti alla fonte.',
      'Potente contro creature d‚Äôombra o non-morte.',
      'La focalizzazione richiede respiro regolare e mente salda.'
    ].join(' '),
    traits: { Danno: 9, Velocit√†: 9 },
  rarity: 'comune'
  },
  {
    name: 'Oscurit√†',
    price: 3000,
    desc: [
      'Proietta un‚Äôonda d‚Äôombra che erode vigore e lucidit√†.',
      'Confonde i bersagli, aprendo spiragli per colpi critici.',
      'La sua energia √® instabile: rende al massimo in ambienti bui.',
      'Gli incantatori inesperti possono subirne un lieve contraccolpo mentale.'
    ].join(' '),
    traits: { Danno: 13, Velocit√†: 6 },
  rarity: 'comune'
  }
];

// === Catalogo Armi (descrizioni estese + caratteristiche 1..15) ===
const weaponItems = [
  {
    name: 'Spada',
    price: 1500,
    desc: [
      'Una spada a una mano, bilanciata e versatile, adatta a quasi ogni stile di combattimento.',
      'La lama diritta permette fendenti controllati e affondi precisi.',
      '√à un‚Äôarma ottima per chi vuole alternare attacco e difesa.',
      'Richiede manutenzione regolare, ma ripaga con affidabilit√† sul campo.'
    ].join(' '),
    traits: { Danno: 11, Velocit√†: 9, 'Distanza d\'uso': 4, 'Velocit√† uso e riuso': 5, Peso: 5 },
  rarity: 'comune'
  },
  {
    name: 'Ascia',
    price: 1800,
    desc: [
      'Colpi potenti che frantumano scudi e spezzano la guardia.',
      'L‚Äôinerzia della testa in metallo richiede ritmo e decisione.',
      'Ideale contro avversari corazzati o creature robuste.',
      'Meno agile in parata, ma devastante quando trova il bersaglio.'
    ].join(' '),
    traits: { Danno: 13, Velocit√†: 7, 'Distanza d\'uso': 4, 'Velocit√† uso e riuso': 5, Peso: 6 },
  rarity: 'comune'
  },
  {
    name: 'Falce',
    price: 2000,
    desc: [
      'Arma curva nata dagli attrezzi agricoli, trasformata per il combattimento.',
      'I tagli avvolgenti possono aggirare scudi e parate.',
      'Richiede buona tecnica per mantenere la distanza corretta.',
      'Spaventa i nemici meno esperti con la sua silhouette minacciosa.'
    ].join(' '),
    traits: { Danno: 13, Velocit√†: 6, 'Distanza d\'uso': 3, 'Velocit√† uso e riuso': 5, Peso: 6 },
  rarity: 'comune'
  },
  {
    name: 'Bastone Incantato',
    price: 2100,
    desc: [
      'Canalizza le energie arcane con maggiore stabilit√†.',
      'Funziona anche come leva o arma contundente di fortuna.',
      'I rune incise lungo l‚Äôasta amplificano gli incantesimi.',
      'Preferito dai maghi itineranti per la sua versatilit√†.'
    ].join(' '),
    traits: { Danno: 6, Velocit√†: 8, 'Distanza d\'uso': 4, 'Velocit√† uso e riuso': 7, Peso: 4 },
  rarity: 'comune'
  },
      {
    name: 'Arco',
    price: 1800,
    desc: [
      'Lungo raggio e traiettorie tese per colpire a distanza.',
      'Richiede buona forza e allenamento costante.',
      'Temibile in campo aperto contro bersagli scoperti.',
      'La corda deve essere curata, pena cali di prestazione.'
    ].join(' '),
    traits: { Danno: 9, Velocit√†: 5, 'Distanza d\'uso': 9, 'Velocit√† uso e riuso': 6, Peso: 5 },
  rarity: 'comune'
  },
  {
    name: 'Balestra Leggera',
    price: 1900,
    desc: [
      'Meccanismo semplice, rapido da armare con un minimo di pratica.',
      'Buona precisione a media distanza.',
      'Adatta a principianti e a combattimenti difensivi.',
      'Richiede dardi di qualit√† per rendere al meglio.'
    ].join(' '),
    traits: { Danno: 11, Velocit√†: 5, 'Distanza d\'uso': 8, 'Velocit√† uso e riuso': 6, Peso: 6 },
  rarity: 'comune'
  },
    {
    name: 'Spadino',
    price: 1200,
    desc: [
      'Piccola spada sottile e bilanciata.',
      'Favorisce affondi rapidi e precisi.',
      'Molto agile, ma potenza limitata.',
      'Ideale per duelli e autodifesa.'
    ].join(' '),
    traits: { Danno: 6, Velocit√†: 9, 'Distanza d\'uso': 2, 'Velocit√† uso e riuso': 7, Peso: 4 },
  rarity: 'comune'
  },
  {
    name: 'Saetta',
    price: 2200,
    desc: [
      'Arma dal profilo slanciato, pensata per colpire prima dell‚Äôavversario.',
      'Predilige sequenze di colpi rapidi che fiaccano la guardia.',
      'Meno incisiva per impatti singoli.',
      'Richiede nervi saldi e tempismo perfetto.'
    ].join(' '),
    traits: { Danno: 6, Velocit√†: 9, 'Distanza d\'uso': 3, 'Velocit√† uso e riuso': 7, Peso: 4 },
  rarity: 'comune'
  },
        {
    name: 'Shuriken',
    price: 1800,
    desc: [
      'Stelle da lancio leggere e silenziose.',
      'Ideali per distrarre, ferire e rallentare.',
      'Letali se colpiscono punti scoperti.',
      'Richiedono precisione e scorte abbondanti.'
    ].join(' '),
    traits: { Danno: 2, Velocit√†: 13, 'Distanza d\'uso': 6, 'Velocit√† uso e riuso': 10, Peso: 2 },
  rarity: 'comune'
  },
  {
    name: 'Mazza Chiodata',
    price: 2200,
    desc: [
      'Testa ferrata irta di punte che lacera e frantuma.',
      'Il colpo giusto pu√≤ disarcionare o spezzare scudi.',
      'Richiede forza e controllo per non sbilanciarsi.',
      'Temuta nelle mischie pi√π caotiche.'
    ].join(' '),
    traits: { Danno: 30, Velocit√†: 5, 'Distanza d\'uso': 2, 'Velocit√† uso e riuso': 3, Peso: 9 },
  rarity: 'comune'
  },
  {
    name: 'Martello Pesante',
    price: 3000,
    desc: [
      'Mazza a due mani progettata per abbattere difese.',
      'Ogni impatto √® un terremoto sul campo.',
      'Lenta ma inesorabile, punisce le esitazioni.',
      'Serve allenamento per gestire rimbalzi e inerzia.'
    ].join(' '),
    traits: { Danno: 28, Velocit√†: 4, 'Distanza d\'uso': 3, 'Velocit√† uso e riuso': 4, Peso: 10 },
  rarity: 'comune'
  },
  {
    name: 'Pugnale',
    price: 1700,
    desc: [
      'Forgiato con tecniche antiche, leggero e affilatissimo.',
      'Predilige la precisione rispetto alla forza bruta.',
      'Si muove come un‚Äôestensione della mano.',
      'Richiede disciplina e occhio allenato.'
    ].join(' '),
    traits: { Danno: 2, Velocit√†: 10, 'Distanza d\'uso': 2, 'Velocit√† uso e riuso': 8, Peso: 2 },
  rarity: 'comune'
  },
      {
    name: 'Palle di Ferro',
    price: 2000,
    desc: [
      'Coppia di sfere collegate, da brandire a due mani.',
      'Capaci di colpire pi√π bersagli con traiettorie ampie.',
      'Difficili da controllare in spazi stretti.',
      'Richiedono pratica per sfruttarne l‚Äôinerzia.'
    ].join(' '),
    traits: { Danno: 13, Velocit√†: 6, 'Distanza d\'uso': 4, 'Velocit√† uso e riuso': 5, Peso: 6 },
  rarity: 'comune'
  },
  {
    name: 'Mannaia',
    price: 2300,
    desc: [
      'Lama larga e pesante, nata per recidere.',
      'Favorevole ai colpi dall‚Äôalto e ai fendenti.',
      'Penalizza agilit√† e ripresa.',
      'Impressiona e intimorisce gli avversari.'
    ].join(' '),
    traits: { Danno: 22, Velocit√†: 6, 'Distanza d\'uso': 3, 'Velocit√† uso e riuso': 4, Peso: 8 },
  rarity: 'comune'
  },
  {
    name: 'Mazzafrusto a 3',
    price: 2300,
    desc: [
      'Tre catene con teste ferrate che ruotano in concerto.',
      'Difficile da padroneggiare, ma ferocemente efficace.',
      'Colpisce oltre la prima linea difensiva.',
      'Richiede spazio e ottimo controllo del tempo.'
    ].join(' '),
    traits: { Danno: 13, Velocit√†: 7, 'Distanza d\'uso': 4, 'Velocit√† uso e riuso': 5, Peso: 6 },
  rarity: 'comune'
  },
      {
    name: 'Scudo',
    price: 2200,
    desc: [
      'Difesa robusta che regge urti ripetuti.',
      'Ottimo in formazione o per tenere una linea.',
      'Lentezza e ingombro si fanno sentire alla lunga.',
      'Sicurezza massima per chi privilegia la resistenza.'
    ].join(' '),
    traits: { Danno: 5, Velocit√†: 6, 'Distanza d\'uso': 1, 'Velocit√† uso e riuso': 13, Peso: 6 },
  rarity: 'comune'
  }
];

// --- Missioni di base ---
const missions = [
  { id: 'm1',  name: 'Difesa del villaggio',   duration: 5,  difficulty: 'facile',     expReward: 10,  goldReward: 50 },
  { id: 'm2',  name: 'Caccia ai briganti',     duration: 5,  difficulty: 'facile', expReward: 15,  goldReward: 70 },
  { id: 'm3',  name: 'Raccolta erbe',          duration: 15, difficulty: 'intermedia',     expReward: 25,  goldReward: 120 },
  { id: 'm4',  name: 'Esplora le rovine',      duration: 15, difficulty: 'intermedia', expReward: 35,  goldReward: 160 },
  { id: 'm5',  name: 'Assalto al covo',        duration: 15, difficulty: 'difficile',  expReward: 50,  goldReward: 220 },
  { id: 'm6',  name: 'Scorta mercanti',        duration: 30, difficulty: 'intermedia',     expReward: 60,  goldReward: 260 },
  { id: 'm7',  name: 'Bonifica miniere',       duration: 30, difficulty: 'difficile', expReward: 80,  goldReward: 320 },
  { id: 'm8',  name: 'Bestia nella foresta',   duration: 30, difficulty: 'difficile',  expReward: 110, goldReward: 420 },
  { id: 'm9',  name: 'Patrol di confine',      duration: 60, difficulty: 'intermedia',     expReward: 140, goldReward: 520 },
  { id: 'm10', name: 'Cripte dimenticate',     duration: 60, difficulty: 'difficile', expReward: 180, goldReward: 650 },
  { id: 'm11', name: 'Assedio notturno',       duration: 60, difficulty: 'estrema',  expReward: 240, goldReward: 800 },
  { id: 'm12', name: 'Drago dei picchi',       duration: 60, difficulty: 'estrema',    expReward: 350, goldReward: 1200 },
];

// stato timer missioni
let missionTimer = null;
// --- COOLDOWN MISSIONI ---
const MISSION_COOLDOWN_HOURS = 8;
const MISSION_COOLDOWN_MS = MISSION_COOLDOWN_HOURS * 60 * 60 * 1000;
let missionCooldownTimer = null;
const missionDescriptions = {
  m1: [
    "Le palizzate scricchiolano sotto il vento del nord.",
    "Pattuglie di contadini chiedono aiuto contro razziatori.",
    "Organizza una difesa rapida con le poche risorse.",
    "Dimostra al villaggio che Mitharia protegge i suoi."
  ],
  m2: [
    "La strada dei mercanti √® funestata da agguati.",
    "Individua le tracce dei briganti tra rovi e rocce.",
    "Colpisci rapido, senza dare tempo alla fuga.",
    "Riporta la quiete sui sentieri collinari."
  ],
  m3: [
    "L‚Äôalchimista chiede erbe rare per un distillato.",
    "Raccoglile prima che il sole bruci la rugiada.",
    "Stai attento a rovi e piccole creature gelose.",
    "Ogni foglia ha il suo prezzo nel mercato."
  ],
  m4: [
    "Rovine antiche emergono da pietre muschiose.",
    "Rumori lontani... o solo vento tra gli archi?",
    "Esplora con passo leggero e mente lucida.",
    "Ogni frammento racconta un passato perduto."
  ],
  m5: [
    "Un covo di predoni infesta le scogliere.",
    "Le loro torce brillano come stelle maligne.",
    "Colpisci al cuore, senza piet√† n√© clamore.",
    "Liberare la costa √® un dovere antico."
  ],
  m6: [
    "Carovane tremano davanti al prossimo passo.",
    "I muli sono nervosi, l‚Äôaria odora di pioggia.",
    "Scorta e osserva: la minaccia √® nell‚Äôombra.",
    "Arriva a destinazione: la fiducia vale oro."
  ],
  m7: [
    "Le miniere sono silenziose, troppo silenziose.",
    "Strani crolli e sussurri nelle gallerie.",
    "Bonifica i cunicoli, metti in salvo i minatori.",
    "Luce e picconi apriranno nuove strade."
  ],
  m8: [
    "Nella foresta si aggira una bestia irrequieta.",
    "Impronte profonde e rami spezzati ovunque.",
    "Studia il terreno, scegli il momento giusto.",
    "Placa la furia o abbatti la minaccia."
  ],
  m9: [
    "Il confine chiama: fuochi fatuo e passi lontani.",
    "Controlla valichi e guadi prima dell‚Äôalba.",
    "Segnala ogni movimento sospetto.",
    "La pace si mantiene con occhi vigili."
  ],
  m10: [
    "Cripte umide sussurrano nomi dimenticati.",
    "Le candele tremano senza vento.",
    "Scendi con calma, rispetta l‚Äôeco dei passi.",
    "L√¨ sotto giacciono verit√† e pericoli."
  ],
  m11: [
    "La notte cade e con essa l‚Äôassedio.",
    "Dardi e scale assaltano le mura scure.",
    "Resisti, coordina, ispira il contrattacco.",
    "All‚Äôalba, il silenzio canter√† vittoria."
  ],
  m12: [
    "Sui picchi innevati volteggia un‚Äôombra rovente.",
    "Il drago misura i cuori con il suo sguardo.",
    "Prepara il piano: coraggio, scudi, magia.",
    "Solo i leggendari tornano da lass√π."
  ],
};
// --- MESSAGGISTICA ---
function getMessages() {
  return userStore.get('messages') || [];
}
function setMessages(arr) {
  userStore.set('messages', arr);
}
// === INVIA / ARCHIVIO ===
// Inviati (per-utente)
function getSentMessages(){ return userStore.get('messages_sent') || []; }
function setSentMessages(arr){ userStore.set('messages_sent', Array.isArray(arr)?arr:[]); }

// Segna archiviati (sui RICEVUTI: non si spostano, restano in inbox)
function archiveMessagesByIds(ids){
  const arr = getMessages();
  let touched = false;
  const set = new Set(ids||[]);
  for (let i=0;i<arr.length;i++){
    const m = arr[i];
    if (m && set.has(m.id)) { m.archived = true; touched = true; }
  }
  if (touched) setMessages(arr);
}
function unarchiveMessagesByIds(ids){
  const arr = getMessages();
  let touched = false;
  const set = new Set(ids||[]);
  for (let i=0;i<arr.length;i++){
    const m = arr[i];
    if (m && set.has(m.id)) { m.archived = false; touched = true; }
  }
  if (touched) setMessages(arr);
}

function addMessage(msg) {
  const arr = getMessages();
  arr.unshift(msg); // pi√π nuova in alto
  setMessages(arr);
  updateMessagesBadge();
}
function countUnread() {
  return getMessages().filter(m => m.unread).length;
}
function updateMessagesBadge() {
  const n = countUnread();
  const badge = document.getElementById('messages-badge');
  if (!badge) return;
  badge.textContent = n > 0 ? `(${n})` : '';
  const label = document.getElementById('messages-unread-label');
  if (label) label.textContent = n > 0 ? `‚Ä¢ ${n} non letti` : '';
}
// === Auto-refresh badge Messaggistica ===
(function setupMessagesBadgeListeners(){
  // Aggiorna appena la pagina √® pronta
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
    });
  } else {
    if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
  }

  // Se la tab torna in primo piano ‚Üí ricalcola
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && typeof updateMessagesBadge === 'function') {
      updateMessagesBadge();
    }
  });

  // Da altre schede/browser (evento storage) ‚Üí ricalcola
  window.addEventListener('storage', (e) => {
    // ascolta solo la casella messaggi dell‚Äôutente corrente
    try{
      const pref = (typeof STORAGE_PREFIX==='string') ? STORAGE_PREFIX : 'mitharia_';
      if (e.key && e.key.endsWith(':messages') && e.key.includes(pref + 'u:' + currentUser + ':')) {
        if (typeof updateMessagesBadge === 'function') updateMessagesBadge();

        // üî• NEW: se cambiano i messaggi del mio utente, riallineo anche la salute
        try {
          const username = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
          if (username && typeof syncHeroHpFromDirectory === 'function') {
            syncHeroHpFromDirectory(username);
          }
        } catch(_){}
      }
    }catch(_){}
  });

  // Evento custom locale quando consegniamo un messaggio nella stessa scheda
  window.addEventListener('myth:messages-changed', () => {
    if (typeof updateMessagesBadge === 'function') updateMessagesBadge();

    // üî• NEW: anche qui, appena arriva un nuovo messaggio (es. sfida), aggiorna HP
    try {
      const username = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
      if (username && typeof syncHeroHpFromDirectory === 'function') {
        syncHeroHpFromDirectory(username);
      }
    } catch(_){}
  });
})();

// Avvia subito il controllo offerta segreta + badge Gilda alla partenza
(function bootGuildBadges(){
  const run = ()=>{
    if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
    if (typeof updateGuildBadges === 'function') updateGuildBadges();
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
// refresh automatico quando cambia lo stato guerre
window.addEventListener('wars:updated', () => {
  try {
    // Se la schermata Diplomazia √® aperta, ridisegna
    const myG = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    const host = document.getElementById('guild-screen-body');
    if (myG && host && typeof renderGuildDiplomacy === 'function') {
      renderGuildDiplomacy(myG);
    }

    // Se sei su Sfide o Sala Eroi, ridisegna le liste (se i renderer esistono)
    if (typeof renderSfideList === 'function') renderSfideList();
    if (typeof renderHeroList  === 'function') renderHeroList();
  } catch (_){}
});

function showMessages() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('messages').classList.remove('hidden');
  setMessageView('inbox'); // ‚Üê apre sempre i ricevuti
}
(function wireComposer(){
  const sendBtn = document.getElementById('msg-send');
  if (!sendBtn) return;

  sendBtn.onclick = ()=>{
    const to   = String(document.getElementById('msg-to').value || '').trim();
    const text = String(document.getElementById('msg-body-input').value || '').trim();

    if (!to){ alert('Inserisci un destinatario.'); return; }
    if (!text){ alert('Scrivi un messaggio.'); return; }

    // üîç verifica esistenza utente
    if (!userExists(to)){
      showGameMessage?.('Impossibile inviare', `Il destinatario <strong>${to}</strong> non esiste! Controlla lo username e riprova.`);
      return;
    }

    const me = (typeof currentUser==='string' && currentUser) ? currentUser : 'utente';

    // Oggetto messaggio ricevuto (N.B. niente ‚ÄúMessaggio da ‚Ä¶‚Äù nel titolo)
    const msg = {
  id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
  type: 'dm',             // <<<<<<<<<<  NUOVO
  title: '',
  body: text,
  from: me,
  to: to,
  when: Date.now(),
  unread: true,
  archived: false
};


    // consegna al destinatario
    if (typeof deliverMessageToUser === 'function') deliverMessageToUser(to, msg);

    // copia negli inviati del mittente (gli inviati non sono "unread")
    const sent = getSentMessages();
    const copy = Object.assign({}, msg, { unread:false });
    sent.unshift(copy);
    setSentMessages(sent);

    // pulizia e vai a "Inviati"
    document.getElementById('msg-to').value = '';
    document.getElementById('msg-body-input').value = '';
    setMessageView('sent');
    showGameMessage?.('Messaggio inviato', `Inviato a <strong>${to}</strong>.`);
  };
})();

// Aggiorna il contatore "Messaggistica (N)" sul bottone del menu
// [FIX] Compat: reindirizza tutte le vecchie chiamate al sistema corretto del badge
function updateMessageBadge(){
  if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
}

// --- Config/State messaggi (NUOVO) ---
const MSGS_PER_PAGE = 10;
let _msgPage = 1;
let _msgSelection = new Set();
let _openMsgId = null;

// --- Vista corrente: 'inbox' | 'sent' | 'arch' | 'compose'
let _msgView = 'inbox';
// Bind pulsanti di navigazione
(function wireMessageNav(){
  const V = {
    inbox: document.getElementById('msg-go-inbox'),
    sent:  document.getElementById('msg-go-sent'),
    arch:  document.getElementById('msg-go-arch'),
    comp:  document.getElementById('msg-compose-open'),
    back:  document.getElementById('msg-compose-back')
  };

  if (V.inbox) V.inbox.onclick = () => setMessageView('inbox');
  if (V.sent)  V.sent.onclick  = () => setMessageView('sent');
  if (V.arch)  V.arch.onclick  = () => setMessageView('arch');

  // Apertura "normale" del composer dalla pagina Messaggi
  if (V.comp) V.comp.onclick = () => {
    window._composeBackTo = null; // nessuna destinazione speciale di rientro
    setMessageView('compose');
  };

  // Torna indietro dal composer
  if (V.back) V.back.onclick = () => {
    // Caso speciale: composer aperto dal percorso Gilda ‚Üí Membri ‚Üí Profilo
    if (window._composeBackTo === 'guild-members') {
      window._composeBackTo = null; // consumato

      // Chiudi i messaggi e l'eventuale profilo
      document.getElementById('messages')?.classList.add('hidden');
      document.getElementById('hero-profile-view')?.classList.add('hidden');

      // Riapri la finestra "Membri di Gilda"
      document.getElementById('guild-members-view')?.classList.remove('hidden');
      return;
    }
// Caso speciale: composer aperto dal profilo arrivando dalla World Ranking
if (window._composeBackTo === 'leaderboard') {
  window._composeBackTo = null;

  document.getElementById('messages')?.classList.add('hidden');
  document.getElementById('hero-profile-view')?.classList.add('hidden');
  document.getElementById('leaderboard')?.classList.remove('hidden');
  return;
}

    // Caso speciale: composer aperto dalla Sala degli Eroi
    if (window._composeBackTo === 'hero-hall') {
      window._composeBackTo = null; // consumato

      // Chiudi i messaggi e l'eventuale profilo
      document.getElementById('messages')?.classList.add('hidden');
      document.getElementById('hero-profile-view')?.classList.add('hidden');

      // Riapri la Sala degli Eroi
      document.getElementById('hero-hall')?.classList.remove('hidden');

      // (opzionale) riallinea la lista
      if (typeof renderHeroHall === 'function') { try { renderHeroHall(); } catch(e){} }
      return;
    }

    // Comportamento normale: torna alla Inbox
    setMessageView('inbox');
  };
})();

function setMessageView(view){
  _msgView = view;
  _msgSelection.clear();

  // toggle blocchi
  const listArea = document.getElementById('message-list');
  const toolbar  = document.getElementById('message-toolbar');
  const pag      = document.getElementById('message-pagination');
  const detail   = document.getElementById('message-detail');
  const compose  = document.getElementById('message-compose');

  if (compose) compose.classList.toggle('hidden', view !== 'compose');
  if (detail)  detail.classList.add('hidden'); // esci da eventuale dettaglio

  const showList = (view !== 'compose');
  if (listArea) listArea.classList.toggle('hidden', !showList);
  if (toolbar)  toolbar.classList.toggle('hidden', !showList);
  if (pag)      pag.classList.toggle('hidden', !showList);

  // toggle navbar pulsanti in base alla vista
  const nav   = document.getElementById('message-nav');
  const bComp = document.getElementById('msg-compose-open');
  const bInb  = document.getElementById('msg-go-inbox');
  const bSent = document.getElementById('msg-go-sent');
  const bArch = document.getElementById('msg-go-arch');

  if (view === 'compose') {
resetComposeForm();
    if (nav) nav.classList.add('hidden');      // in composizione: nascondi tutta la barra
  } else {
    if (nav) nav.classList.remove('hidden');
    if (bComp) bComp.classList.remove('hidden'); // ‚ÄúInvia‚Äù visibile in tutte le liste
    if (bInb)  bInb.classList.toggle('hidden', view === 'inbox'); // non mostrare ‚ÄúRicevuti‚Äù quando sono gi√† in ricevuti
    if (bSent) bSent.classList.toggle('hidden', view === 'sent'); // idem per ‚ÄúInviati‚Äù
    if (bArch) bArch.classList.toggle('hidden', view === 'arch'); // idem per ‚ÄúArchiviati‚Äù
  }


  // titolino
  const h2 = document.querySelector('#messages > h2');
  if (h2){
    const label = view==='inbox' ? 'Messaggistica'
                 : view==='sent' ? 'Messaggi inviati'
                 : view==='arch' ? 'Messaggi archiviati'
                 : 'Invia un messaggio';
    h2.childNodes[0].nodeValue = label + ' ';
  }

  // render
  if (view === 'compose') return; // niente lista
  renderMessageList(1);           // reset pagina quando cambi vista
}

function userExists(username){
  try{
    if (!username) return false;
    const pref = (typeof STORAGE_PREFIX==='string') ? STORAGE_PREFIX : 'mitharia_';
    const start = pref + 'u:' + username + ':';
    for (let i = 0; i < localStorage.length; i++){
      const k = localStorage.key(i);
      if (k && k.startsWith(start)) return true;
    }
  }catch(_){}
  return false;
}

// Sorgente dati in base alla vista
function _getListForCurrentView(){
  if (_msgView === 'sent')  return getSentMessages();
  if (_msgView === 'arch')  return getMessages().filter(m => m.archived);
  // inbox
  return getMessages();
}

// Estensione della tua renderMessageList: legge dalla vista corrente
const _origRenderMessageList = renderMessageList;
renderMessageList = function(page=_msgPage){
  const list = document.getElementById('message-list');
  if (!list) return;

  const msgs = _getListForCurrentView();
  const total = msgs.length;
  const totalPages = Math.max(1, Math.ceil(total / MSGS_PER_PAGE));
  _msgPage = Math.min(Math.max(1, page), totalPages);

  list.innerHTML = '';

  if (total === 0){
    list.innerHTML = '<p class="muted">Nessun messaggio.</p>';
    updateMessagesBadge();
    updatePaginationUI(1, 1);
    const prev = document.getElementById('msg-prev');
    const next = document.getElementById('msg-next');
    if (prev) prev.style.display = 'none';
    if (next) next.style.display = 'none';
    // nascondi azioni
    document.getElementById('msg-delete-selected')?.style && (document.getElementById('msg-delete-selected').style.display='none');
    document.getElementById('msg-archive')?.classList.add('hidden');
    document.getElementById('msg-unarchive')?.classList.add('hidden');
    return;
  }

  // paginazione
  const start = (_msgPage - 1) * MSGS_PER_PAGE;
  const end   = Math.min(start + MSGS_PER_PAGE, total);
  const pageItems = msgs.slice(start, end);

  // righe (riuso struttura esistente)
  pageItems.forEach(m => {
    const item = document.createElement('div');
    item.className = 'message-item';
    item.setAttribute('data-id', m.id);

    const row = document.createElement('div');
    row.style.display = 'grid';
    row.style.gridTemplateColumns = 'auto 1fr';
    row.style.alignItems = 'center';
    row.style.gap = '10px';

    const sel = document.createElement('input');
    sel.type = 'checkbox';
    sel.className = 'msg-select';
    sel.setAttribute('data-id', m.id);
    sel.checked = _msgSelection.has(m.id);
    sel.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = sel.getAttribute('data-id');
      if (sel.checked) _msgSelection.add(id); else _msgSelection.delete(id);
      refreshActionButtonsVisibility();
    });

    const content = document.createElement('div');
    content.style.cursor = 'pointer';

    const title = document.createElement('div');
    const isUnread = !!m.unread && _msgView!=='sent'; // inviati non hanno "unread"
    title.className = 'message-title' + (isUnread ? '' : ' read');
    // Titolo: da chi / a chi
    // Niente prefisso per le notifiche di sfida: titolo ‚Äúpuro‚Äù
const prefix =
  (m.type === 'pvp_challenge')
    ? ''
    : (_msgView === 'sent' ? `A: ${m.to} ‚Äî ` : (m.from ? `Da: ${m.from}  ` : ''));
title.textContent = prefix + (m.title || '');



    const meta = document.createElement('div');
    meta.className = 'muted';
    const dt = fmtDateTimeShort(m.when);
    meta.textContent = dt + (m.archived && _msgView!=='arch' ? ' ‚Ä¢ Archiviato' : '');

    content.appendChild(title);
    content.appendChild(meta);

    content.addEventListener('click', () => {
      // open detail: usa gi√† openMessageById, ma serve indicizzare nella fonte giusta
      if (_msgView === 'sent'){
        openSentMessageById(m.id);
      } else {
        openMessageById(m.id);
      }
    });

    row.appendChild(sel);
    row.appendChild(content);
    item.appendChild(row);
    list.appendChild(item);
  });

  // Pager (riuso delle tue regole)
  // Pager (riuso delle tue regole) ‚Äî con inversione ordine nelle pagine centrali
const prev = document.getElementById('msg-prev');
const next = document.getElementById('msg-next');
const wrapper = document.getElementById('message-pagination');
const totalPagesNow = Math.max(1, Math.ceil(total / MSGS_PER_PAGE));

if (prev) prev.onclick = () => renderMessageList(_msgPage - 1);
if (next) next.onclick = () => renderMessageList(_msgPage + 1);

// REGOLE VISIBILIT√Ä:
// - PRIMA PAGINA: SOLO "SUCCESSIVA"
// - ULTIMA PAGINA: SOLO "PRECEDENTE"
// - PAGINE INTERMEDIE: ENTRAMBI, con ordine: NEXT poi PREV
if (prev && next) {
  if (totalPagesNow <= 1) {
    prev.style.display = 'none';
    next.style.display = 'none';
  } else if (_msgPage === 1) {
    prev.style.display = 'none';
    next.style.display = 'block';
    // ordine irrilevante: c'√® solo "successiva"
  } else if (_msgPage === totalPagesNow) {
    prev.style.display = 'block';
    next.style.display = 'none';
    // ordine irrilevante: c'√® solo "precedente"
  } else {
    // pagine centrali: mostra entrambi e metti NEXT prima di PREV
    prev.style.display = 'block';
    next.style.display = 'block';
    if (wrapper && next && prev && next.nextSibling !== prev) {
      // sposta "successiva" davanti a "precedente"
      wrapper.insertBefore(next, prev);
    }
  }
}

updatePaginationUI(_msgPage, totalPagesNow);


  refreshActionButtonsVisibility();
};

// Azioni visibili in base a vista e selezione
function refreshActionButtonsVisibility(){
  const hasSel = _msgSelection.size > 0;

  // (1) Mostra/nascondi il bottone "Elimina selezionati"
  const delBtn = document.getElementById('msg-delete-selected');
  if (delBtn) {
    delBtn.style.display = hasSel ? '' : 'none';

    // Ri-aggancia SEMPRE l'handler (cos√¨ restiamo immuni ai doppioni di renderMessageList)
    delBtn.onclick = () => {
      const nSel = _msgSelection.size;
      if (nSel <= 0) return;

      // usa la modale standard; se non c'√®, il fallback conferma con window.confirm
      askConfirm({
        title: 'Eliminare messaggi',
        text: `Sei sicuro di voler eliminare ${nSel === 1 ? 'il messaggio selezionato' : nSel + ' messaggi selezionati'}?`,
        okText: 'Conferma',
        cancelText: 'Annulla',
        onConfirm: () => {
          // elimina e ripulisci selezione
          deleteMessagesByIds(Array.from(_msgSelection));
          _msgSelection.clear();

          // ricalcola pagine in base ALLA VISTA CORRENTE (inbox/sent/arch)
          const totalAfter = _getListForCurrentView().length;
          const totalPagesAfter = Math.max(1, Math.ceil(totalAfter / MSGS_PER_PAGE));
          if (_msgPage > totalPagesAfter) _msgPage = totalPagesAfter;

          renderMessageList(_msgPage);
        }
      });
    };
  }

  // (2) Crea (se mancano) e gestisci i bottoni Archivia / Rimuovi dall‚Äôarchivio
  let archBtn = document.getElementById('msg-archive');
  let unarchBtn = document.getElementById('msg-unarchive');
  const toolbar = document.getElementById('message-toolbar');

  if (toolbar){
    if (!archBtn){
      archBtn = document.createElement('button');
      archBtn.id = 'msg-archive';
      archBtn.className = 'magic-button';
      archBtn.textContent = 'Archivia selezionati';
      archBtn.style.marginLeft = '8px';
      archBtn.onclick = () => {
        archiveMessagesByIds(Array.from(_msgSelection));
        _msgSelection.clear();
        renderMessageList(_msgPage);
      };
      toolbar.appendChild(archBtn);
    }
    if (!unarchBtn){
      unarchBtn = document.createElement('button');
      unarchBtn.id = 'msg-unarchive';
      unarchBtn.className = 'magic-button';
      unarchBtn.textContent = 'Rimuovi dall‚Äôarchivio';
      unarchBtn.style.marginLeft = '8px';
      unarchBtn.onclick = () => {
        unarchiveMessagesByIds(Array.from(_msgSelection));
        _msgSelection.clear();
        renderMessageList(_msgPage);
      };
      toolbar.appendChild(unarchBtn);
    }
  }

  // (3) Visibilit√† contestuale in base alla vista corrente
  if (archBtn)   archBtn.classList.toggle('hidden', !hasSel || _msgView!=='inbox');
  if (unarchBtn) unarchBtn.classList.toggle('hidden', !hasSel || _msgView!=='arch');
}


// Apertura dettaglio dai "Inviati" (clona la tua openMessageById per la lista sent)
function openSentMessageById(id){
  const list = (typeof getSentMessages === 'function')
    ? getSentMessages()
    : (userStore.get('sentMessages') || []);
  const msg = list.find(m => m && m.id === id);
  if (!msg) return;

  _openMsgId = id;
  const { titleEl, bodyEl, deleteBtn } = ensureMessageWindow();
  if (deleteBtn) deleteBtn.classList.add('hidden'); // di norma non elimino dalla posta inviata

  const when = new Date(msg.timestamp || msg.sentAt || Date.now()).toLocaleString();
  const to   = (msg.to || msg.recipient || '').toString();

  titleEl.textContent = msg.subject || '(Nessun oggetto)';

  // consenti solo <br> e <strong> nel corpo, come negli altri dettagli
  const safeBody = (msg.bodyHtml || msg.body || '').toString()
    .replace(/<(?!br\s*\/?|\/?strong\b)[^>]*>/gi, '');

  bodyEl.innerHTML = `
    <div class="muted" style="margin-bottom:8px">
      <div><strong>A:</strong> ${escapeHtml(to)}</div>
      <div><strong>Data:</strong> ${when}</div>
    </div>
    <div>${safeBody}</div>
  `;

  showMessageWindow();
}

function fmtDateTimeShort(when) {
  try {
    const d = new Date(when);
    const ds = d.toLocaleDateString('it-IT', { year:'numeric', month:'2-digit', day:'2-digit' });
    const ts = d.toLocaleTimeString('it-IT', { hour:'2-digit', minute:'2-digit' });
    return `${ds} ‚Ä¢ ${ts}`;
  } catch { return String(when); }
}
/* ====== Sala dei Forzieri ‚Äì stato locale ====== */
let _currentChestCategory = 'armi';   // default
// Rende il contenuto custom dell'invito gilda dentro un container (dettaglio messaggio)
function renderGuildInviteDetail(container, msg){
  const name = msg?.gname || 'Gilda';
  const tag  = msg?.gtag  || '';
  const inviter = msg?.inviter || 'un giocatore';
  container.innerHTML = `
    <div style="text-align:left;">
      <p><strong>${inviter}</strong> ti ha invitato a entrare nella gilda <strong>${name}</strong>${tag?` [${tag}]`:''}.</p>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="guild-invite-decline" class="magic-button magic-button--slim">Rifiuta</button>
        <button id="guild-invite-accept" class="magic-button">Accetta</button>
      </div>
    </div>
  `;

  const accept = container.querySelector('#guild-invite-accept');
  const decline = container.querySelector('#guild-invite-decline');

  // helper: marca letto e chiudi se hai un close
  function finalize(closeFn){
    try{
      // marca come letto (se il tuo viewer gestisce "read")
      if (typeof currentUser==='string' && currentUser){
        const prefix = (typeof STORAGE_PREFIX==='string') ? STORAGE_PREFIX : 'mitharia_';
        const k = prefix + 'u:' + currentUser + ':messages';
        const arr = JSON.parse(localStorage.getItem(k) || '[]');
        const idx = arr.findIndex(m => m && m.id === msg.id);
        if (idx >= 0){ arr[idx].unread = false; localStorage.setItem(k, JSON.stringify(arr)); }
      }
    }catch(e){}
    if (typeof updateMessageBadge==='function') updateMessageBadge();
    if (typeof closeMessageDetail==='function') closeMessageDetail(); // se hai una funzione simile
    if (typeof closeModal==='function') closeModal(); // fallback eventuale
    if (typeof closeMessagesPopup==='function') closeMessagesPopup();
    if (closeFn) closeFn();
  }

  if (decline) decline.onclick = ()=> finalize(()=> showGameMessage?.('Invito rifiutato','Hai rifiutato l‚Äôinvito.'));

  if (accept) accept.onclick = ()=>{
    // controlli base
    if (!msg?.gid){ finalize(); return; }
    if (typeof getUserGuildId==='function' && getUserGuildId()){ 
      finalize(()=> showGameMessage?.('Gi√† in gilda','Sei gi√† in una gilda.')); 
      return; 
    }
    const members = (typeof getGuildMembers==='function') ? getGuildMembers(msg.gid) : [];
    const gAll = (typeof getGuilds==='function') ? getGuilds() : {};
    const g = gAll[msg.gid];
    const limit = g?.limit || 60;
    if (!g){ finalize(); return; }
    if (members.length >= limit){
      finalize(()=> showGameMessage?.('Gilda piena','Questa gilda ha raggiunto il limite di membri.'));
      return;
    }

    // join
    if (typeof addGuildMember==='function') addGuildMember(msg.gid, currentUser, 'member');
    if (typeof setUserGuildId==='function') setUserGuildId(msg.gid);
    finalize(()=> showGameMessage?.('Ingresso effettuato', `Sei entrato in <strong>${name}</strong>${tag?` [${tag}]`:''}.`));
  };
}

// Rende il dettaglio di una RICHIESTA ACCESSO GILDA per il Capogilda
function renderGuildRequestDetail(container, msg){
  const name = msg?.gname || 'Gilda';
  const tag  = msg?.gtag  || '';
  const who  = msg?.applicant || 'un giocatore';

  container.innerHTML = `
    <div style="text-align:left;">
      <p><strong>${who}</strong> ha chiesto di entrare nella tua gilda <strong>${name}</strong>${tag?` [${tag}]`:''}.</p>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="guild-req-decline" class="magic-button magic-button--slim">Rifiuta</button>
        <button id="guild-req-accept" class="magic-button">Accetta</button>
      </div>
    </div>
  `;

  const decline = container.querySelector('#guild-req-decline');
  const accept  = container.querySelector('#guild-req-accept');

  function finalize(after){
    try{
      if (typeof currentUser==='string' && currentUser){
        const prefix = (typeof STORAGE_PREFIX==='string') ? STORAGE_PREFIX : 'mitharia_';
        const k = prefix + 'u:' + currentUser + ':messages';
        const arr = JSON.parse(localStorage.getItem(k) || '[]');
        const idx = arr.findIndex(m => m && m.id === msg.id);
        if (idx >= 0){ arr[idx].unread = false; localStorage.setItem(k, JSON.stringify(arr)); }
      }
    }catch(e){}
    if (typeof updateMessageBadge==='function') updateMessageBadge();
    if (typeof closeMessageDetail==='function') closeMessageDetail();
    if (typeof closeModal==='function') closeModal();
    if (typeof closeMessagesPopup==='function') closeMessagesPopup();
    if (after) after();
  }

  if (decline) decline.onclick = ()=> finalize(()=> showGameMessage?.('Richiesta rifiutata', 'Hai rifiutato la richiesta.'));

  if (accept) accept.onclick = ()=>{
    if (!msg?.gid){ finalize(); return; }

    // sicurezza: solo il Capogilda pu√≤ accettare
    const all = (typeof getGuilds==='function') ? getGuilds() : {};
    const g = all[msg.gid];
    if (!g){ finalize(); return; }
    if (typeof currentUser==='string' && currentUser && g.owner !== currentUser){
      finalize(()=> showGameMessage?.('Operazione non consentita', 'Solo il Capogilda pu√≤ accettare le richieste.'));
      return;
    }

    // l'utente potrebbe gi√† essere entrato altrove
    const already = (typeof _getUserKey==='function') ? _getUserKey(msg.applicant, 'guildId', null) : null;
    if (already){
      finalize(()=> showGameMessage?.('Giocatore gi√† in gilda', `${who} risulta gi√† in una gilda.`));
      return;
    }

    // capienza
    const members = (typeof getGuildMembers==='function') ? getGuildMembers(msg.gid) : [];
    const limit   = g?.limit || (typeof GUILD_MEMBER_LIMIT!=='undefined' ? GUILD_MEMBER_LIMIT : 60);
    if (members.length >= limit){
      finalize(()=> showGameMessage?.('Gilda piena', 'Questa gilda ha raggiunto il limite di membri.'));
      return;
    }

    // aggiungi il membro + imposta flag sul suo profilo (device-local)
    if (typeof addGuildMember==='function') addGuildMember(msg.gid, msg.applicant, 'member');
    if (typeof forceSetGuildFlagForUser==='function') forceSetGuildFlagForUser(msg.applicant, msg.gid);

    // facoltativo: notifica l‚Äôinteressato
if (typeof deliverMessageToUser==='function') {
  deliverMessageToUser(msg.applicant, {
    id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
    type: 'guild_request_accepted',  // <‚Äî TIPO NUOVO
    gid: msg.gid,
    gname: name,
    gtag: tag,
    leader: (g && g.owner) ? g.owner : 'il Capogilda',
    title: 'Richiesta accettata',
    body: `<strong>${g.owner}</strong> ha accettato la tua richiesta: entri in <strong>${name}</strong>${tag?` [${tag}]`:''}. Benvenuto in gilda!`,
    when: Date.now(),
    unread: true
  });
}


    finalize(()=> showGameMessage?.('Richiesta accettata', `${who} √® entrato in <strong>${name}</strong>${tag?` [${tag}]`:''}.`));
  };
}


function selectChestCategory(cat){
  _currentChestCategory = cat;
  // aggiornamento UI tabs
  document.querySelectorAll('.chest-tab').forEach(b=>{
    b.classList.toggle('is-active', b.dataset.cat===cat);
  });
  renderChestGrid();
}

function renderChestGrid(){
  ensureKeyStores?.();
  ensureChestStores?.();
  if (!window.CHEST_TIERS) return;

  // Polvere Arcana (se presente lo store)
  const dustEl = document.getElementById('dust-counter');
  if (dustEl && typeof getArcaneDust === 'function') {
    dustEl.textContent = getArcaneDust();
  }

  const grid = document.getElementById('chest-grid');
  if (!grid) return;

  const lvl = getNum?.('level', 1) ?? 1;
  const cat = _currentChestCategory || 'armi';  // fallback sicuro

  const tiers = ['mercante','avventuriero','re','arcano'];
  grid.innerHTML = tiers.map(tid=>{
    const t = CHEST_TIERS[tid];
    const keyCount = (typeof getKeyCount==='function') ? getKeyCount(t.keyId) : 0;

    // percentuali -> HTML barre
    const order = ['rara','epica','leggendaria','mitica'];
    const bars = order
      .filter(r => (t.odds[r]||0) > 0)
      .map(r => {
        const perc = Math.round((t.odds[r]||0)*1000)/10; // es. 80.0
        return `
          <div class="rbar">
            <span class="lab">${r.charAt(0).toUpperCase()+r.slice(1)}</span>
            <div class="bar"><div class="fill ${r}" style="width:${perc}%;"></div></div>
            <span>${perc}%</span>
          </div>`;
      }).join('');

    const locked   = lvl < t.minLevel;
    const disabled = locked || keyCount<=0;

    // Pity badge
let pityBadge = '';
if (typeof getChestPity === 'function' && _currentChestCategory){
  if (tid === 'avventuriero') {
    const v = getChestPity('avventuriero') || 0;
    const max = 10;
    const deg = Math.round(360 * (v / max));
    pityBadge = `<div class="pity-badge" style="--deg:${deg}deg; --ring:#5d6b85; --thickness:6px" title="Garanzia Leggendaria: ${v}/10">${v}/10</div>`;
  } else if (tid === 're') {
    const v = getChestPity('re') || 0;
    const max = 15;
    const deg = Math.round(360 * (v / max));
    pityBadge = `<div class="pity-badge" style="--deg:${deg}deg; --ring:#c58a12; --thickness:6px" title="Garanzia Mitica: ${v}/15">${v}/15</div>`;
  }
}

    return `
      <div class="chest-card tier-${tid}">
        ${pityBadge}
        <div class="head">
          <div class="name">${t.label}</div>
          <div class="keys">Chiavi: <strong>${keyCount}</strong></div>
        </div>

        <div class="chest-ico"></div>
        <div class="req">Requisito: Livello <strong>${t.minLevel}</strong></div>

        <div class="rarity-bars">${bars}</div>

        <div class="chest-cta">
          <button class="open-btn" ${disabled ? 'disabled' : ''}
            title="${
              locked
                ? `Sblocca al Livello ${t.minLevel}`
                : (keyCount<=0 ? `Ti manca 1 ${KEY_META?.[t.keyId]?.label || 'Chiave'}` : '')
            }"
            onclick="confirmOpenChest('${tid}','${_currentChestCategory}')">Apri</button>
          <span class="drops-link" onclick="showChestDrops('${tid}','${_currentChestCategory}')">Mostra drop</span>
        </div>

        ${locked ? `<div class="locked">üîí Liv. ${t.minLevel}</div>` : ''}
      </div>`;
  }).join('');
}

/* Conferma (per ora solo conferma; lo ‚Äústep 2‚Äù far√† l‚Äôapertura reale) */
/* === Apertura reale forzieri (STEP 2) === */
const DUST_BY_RARITY = { rara:10, epica:15, leggendaria:20, mitica:30 };

// === Helper UI Polvere Arcana ===
function updateDustBadges(){
  const get = (typeof getArcaneDust === 'function') ? getArcaneDust() : 0;
  const elChest  = document.getElementById('dust-counter');         // Sala forzieri
  const elArcane = document.getElementById('arcane-dust-amount');    // Bottega Arcana
  if (elChest)  elChest.textContent  = get;
  if (elArcane) elArcane.textContent = get;
}

// Conferma conversione: nessuna chiusura cliccando sul backdrop
function confirmConvertToDust(dustGain, onConfirm){
  const id = 'dust-confirm-layer';
  let layer = document.getElementById(id);
  if (layer && layer.parentNode) layer.parentNode.removeChild(layer);

  layer = document.createElement('div');
  layer.id = id;
  layer.style.position = 'fixed';
  layer.style.inset = '0';
  layer.style.zIndex = '9999';
  layer.innerHTML = `
    <div class="confirm-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,.55)"></div>
    <div class="confirm-dialog" style="position:absolute; left:50%; top:12vh; transform:translateX(-50%);
         width:min(520px,92vw); background:#f6ecd1; border:1px solid #b5914a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.3);">
      <div style="padding:16px; text-align:left">
        <div style="font-weight:700; margin-bottom:6px;">Conferma conversione</div>
        <div>Sei sicuro di voler trasformare l'oggetto in Polvere Arcana? Otterrai <strong>${dustGain}</strong> unit√†.</div>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; padding:0 16px 16px;">
        <button id="dust-confirm-yes" class="magic-button">S√¨</button>
        <button id="dust-confirm-no" class="magic-button">No</button>
      </div>
    </div>`;
  document.body.appendChild(layer);

  // üîí Non chiudere cliccando la finestra dietro: non attacchiamo handler sulla .confirm-backdrop
  layer.querySelector('#dust-confirm-no').onclick  = () => { if (layer && layer.parentNode) layer.parentNode.removeChild(layer); };
  layer.querySelector('#dust-confirm-yes').onclick = () => {
    try { if (typeof onConfirm === 'function') onConfirm(); } finally {
      if (layer && layer.parentNode) layer.parentNode.removeChild(layer);
    }
  };
}

// Aggiorna i contatori dell'oro dove presenti (profilo + botteghe)
function updateGoldBadges(){
  const g = (typeof getNum === 'function') ? getNum('gold', 0) : 0;
  const heroGoldEl = document.getElementById('hero-gold');
  if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;
  // se le botteghe sono aperte, aggiorna anche l√¨
  ['weapon-shop-gold','magic-shop-gold','armor-shop-gold','creature-shop-gold','guild-shop-gold'].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.textContent = formatGold(g);
  });
}
// === L'eroe corrente appartiene a una gilda? ===
function isCurrentHeroInGuild(){
  try {
    if (typeof getUserGuildId === 'function') {
      return !!getUserGuildId();  // true se esiste un guildId salvato
    }
  } catch {}
  return false;
}

function updateGuildBadges(){
  // Sei in una gilda?
  const inGuild = (typeof getUserGuildId === 'function') ? !!getUserGuildId() : false;

  let show = false;
  if (inGuild) {
    // Assicurati che lo special della settimana sia generato per l'utente corrente
    try { if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek(); } catch {}

    // Stato corrente dell'oggetto segreto
    const s = (typeof getGuildSpecial === 'function') ? getGuildSpecial() : null;

    // Offerta attiva adesso?
    const active = (typeof isGuildSpecialActiveNow === 'function') ? isGuildSpecialActiveNow() : false;

    // Visto / acquistato (preferisci i flag dentro s; fallback a vecchie funzioni se esistono)
    const seen   = !!(s && (s.seen   || (typeof isGuildSpecialSeen   === 'function' && isGuildSpecialSeen())));
    const bought = !!(s && (s.bought || (typeof isGuildSpecialBought === 'function' && isGuildSpecialBought())));

    show = !!(s && active && !seen && !bought);
  }

  // Controllo Miniera: esiste un claimable nella Miniera della Gilda?
  let mineClaim = null;
  try {
    if (typeof userStore !== 'undefined' && userStore && typeof userStore.get === 'function') {
      mineClaim = userStore.get('guildMine_claimable') || null;
    }
  } catch (e) {
    mineClaim = null;
  }
  const hasMineClaim = !!mineClaim;

  // Applica la visibilit√† ai tre pallini esistenti (comportamento invariato)
  ['guild-badge', 'g-shop-badge', 'gs-secret-dot'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    // 'guild-badge' deve essere visibile se show OR se c'√® claim della miniera
    if (id === 'guild-badge') {
      el.classList.toggle('hidden', !(show || hasMineClaim));
    } else {
      el.classList.toggle('hidden', !show);
    }
  });

  // Gestione specifica del pallino sulla voce "Miniera della Gilda"
  try {
    const mineDot = document.getElementById('g-mine-dot');
    if (mineDot) {
      if (hasMineClaim) mineDot.classList.remove('hidden'); else mineDot.classList.add('hidden');
    }
  } catch (e){ /* ignore */ }
}



// Popup conferma VENDITA (non si chiude cliccando sul backdrop)
function confirmSellItem(goldGain, onConfirm){
  const id = 'sell-confirm-layer';
  let layer = document.getElementById(id);
  if (layer && layer.parentNode) layer.parentNode.removeChild(layer);

  layer = document.createElement('div');
  layer.id = id;
  layer.style.position = 'fixed';
  layer.style.inset = '0';
  layer.style.zIndex = '9999';
  layer.innerHTML = `
    <div class="confirm-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,.55)"></div>
    <div class="confirm-dialog" style="position:absolute; left:50%; top:12vh; transform:translateX(-50%);
         width:min(520px,92vw); background:#f6ecd1; border:1px solid #b5914a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.3);">
      <div style="padding:16px; text-align:left">
        <div style="font-weight:700; margin-bottom:6px;">Conferma vendita</div>
        <div>Sei sicuro di voler vendere l'oggetto? Otterrai <strong>${formatGold(goldGain)}</strong> monete d'oro.</div>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; padding:0 16px 16px;">
        <button id="sell-confirm-yes" class="magic-button">S√¨</button>
        <button id="sell-confirm-no" class="magic-button">No</button>
      </div>
    </div>`;
  document.body.appendChild(layer);

  layer.querySelector('#sell-confirm-no').onclick  = () => { layer.remove(); };
  layer.querySelector('#sell-confirm-yes').onclick = () => {
    try { if (typeof onConfirm === 'function') onConfirm(); } finally { layer.remove(); }
  };
}

function ensureChestRewardModal(){
  if (document.getElementById('chest-reward-overlay')) return;

  const ov = document.createElement('div');
  ov.id = 'chest-reward-overlay';
  ov.className = 'hidden overlay-common';
  ov.innerHTML = `
    <div id="chest-reward-modal">
      <header><h3 id="chest-reward-title"></h3></header>
      <div class="body" id="chest-reward-body"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="chest-reward-keep" class="magic-button">Mantieni</button>
        <button id="chest-reward-dust" class="magic-button">Converti in Polvere</button>
      </div>
    </div>
  `;

  document.body.appendChild(ov);
}

function pickRarityWithPity(tierId, category){
  const t = CHEST_TIERS[tierId];
  if (!t) return null;

  // Arcano: 100% Mitica
  if (tierId === 'arcano') return 'mitica';

  // Pity
  if (tierId === 'avventuriero') {
    const cur = (typeof getChestPity==='function') ? getChestPity('avventuriero') : 0;
    if (cur >= 10) return 'leggendaria'; // garantita
  }
  if (tierId === 're') {
    const cur = (typeof getChestPity==='function') ? getChestPity('re') : 0;
    if (cur >= 15) return 'mitica'; // garantita
  }

  // RNG pesato
  const odds = t.odds || {};
  const entries = Object.entries(odds).filter(([_,v])=>v>0);
  const total = entries.reduce((s,[_,v])=>s+v,0);
  if (total <= 0) return null;

  let r = Math.random() * total;
  for (const [rar, v] of entries){
    if ((r -= v) <= 0) return rar;
  }
  return entries[entries.length-1]?.[0] || null;
}

function poolBy(category, rarity){
  if (typeof getAllDefs !== 'function') return [];
  const catMap = { armi:'weapons', armature:'armors', magie:'magics', creature:'creatures' };
  const catKey = catMap[category];
  if (!catKey) return [];
  const all = getAllDefs(catKey);
  return all.filter(it => String(it.rarity||'').toLowerCase() === rarity);
}

function addDroppedItemToInventory(category, name){
  if (!name) return;
  if (category === 'armi') {
    const map = userStore.get('weapons') || {};
    map[name] = (map[name]||0) + 1;
    userStore.set('weapons', map);
  } else if (category === 'armature') {
    const arr = userStore.get('armors') || [];
    if (!arr.includes(name)) arr.push(name);
    userStore.set('armors', arr);
  } else if (category === 'magie') {
    const arr = userStore.get('magics') || [];
    if (!arr.includes(name)) arr.push(name);
    userStore.set('magics', arr);
  } else if (category === 'creature') {
    if (typeof window.addOwnedCreature === 'function') {
      window.addOwnedCreature(name);
    } else {
      const arr = userStore.get('creatures') || [];
      if (!arr.includes(name)) arr.push(name);
      userStore.set('creatures', arr);
    }
  }
}

function showChestReward(item){
  ensureChestRewardModal();
  const ov = document.getElementById('chest-reward-overlay');
  const modal = document.getElementById('chest-reward-modal');
  const title = document.getElementById('chest-reward-title');
  const body = document.getElementById('chest-reward-body');
  const keepBtn = document.getElementById('chest-reward-keep');
  const dustBtn = document.getElementById('chest-reward-dust');

  title.textContent = item.name;
  const rarityKey = String(item.rarity || 'comune').toLowerCase();

  // NEW: fallback per immagine/descrizione e calcolo tratti se non presenti
  const desc = item.desc || item.description || '';
  const traitsObj = item.traits || (typeof getCreatureTraits === 'function' ? getCreatureTraits(item.name) : null);
  const imgHtml = item.img
  ? `<img class="weapon-thumb creature-thumb--frame" src="${item.img}" alt="${item.name}">`
  : '';


  body.innerHTML = `
    ${imgHtml}
    <p class="muted" style="margin:4px 0 8px 0;">Rarit√†: <strong class="rarity rarity--${rarityKey}">${rarityKey}</strong></p>
    ${desc ? `<p>${desc}</p>` : ''}
    ${traitsObj ? `
      <div class="traits-block">
        <div class="title">Caratteristiche</div>
        <div class="traits-grid">
          ${Object.entries(traitsObj).map(([k,v])=>`<div>${k}: <strong>${v}</strong></div>`).join('')}
        </div>
      </div>` : ''}
  `;

  ov.classList.remove('hidden');
  if (typeof positionModalBelowSectionTitle === 'function') {
    positionModalBelowSectionTitle(
      document.getElementById('chest-reward-modal'),
      '#chest-room',
      16
    );
  }

  // Decorazioni rarit√†
  if (typeof applyRarityDecor === 'function') applyRarityDecor(modal, title, rarityKey);

  // Attacchi
  const dustGain = DUST_BY_RARITY[rarityKey] || 0;
  dustBtn.textContent = dustGain > 0 ? `Converti in Polvere (+${dustGain})` : 'Converti in Polvere';

  // Pulizia vecchi handler
  keepBtn.onclick = null;
  dustBtn.onclick = null;

  // --- LOGICA DOPPIONE DURO (solo magie/armature/creature) ---
  // categoria passata da performOpenChest: item._dropCategory
  const cat = item._dropCategory || null;
  let isHardDuplicate = false;
  if (cat === 'magie' || cat === 'armature' || cat === 'creature') {
    // Queste categorie usano array di NOMI (nome include la rarit√†).
    // Stesso tipo + stessa rarit√† => stesso name.
    if (cat === 'magie') {
      const owned = userStore.get('magics') || [];
      isHardDuplicate = owned.includes(item.name);
    } else if (cat === 'armature') {
      const owned = userStore.get('armors') || [];
      isHardDuplicate = owned.includes(item.name);
    } else if (cat === 'creature') {
      const owned = userStore.get('creatures') || [];
      isHardDuplicate = owned.includes(item.name);
    }
  }

  // Reset visibilit√† di default
  keepBtn.style.display = '';

  // Se doppione duro: nascondi "Mantieni" e mostra avviso
  if (isHardDuplicate) {
    // Messaggio sopra ai bottoni (nel body del popup)
    const notice = document.createElement('p');
    notice.style.fontWeight = '700';
    notice.style.margin = '8px 0 0';
    notice.style.color = '#5a3b00';
    notice.textContent = 'Hai gi√† questo oggetto: verr√† trasformato in Polvere Arcana.';
    body.appendChild(notice);

    // Nascondi il pulsante "Mantieni"
    keepBtn.style.display = 'none';

    // Focus UX sul bottone polvere
    setTimeout(() => dustBtn?.focus?.(), 0);
  }

  // Handler "Mantieni" (rimane ma √® nascosto nei doppioni duri)
  keepBtn.onclick = ()=>{
    ov.classList.add('hidden');
    showGameMessage('Ricompensa ottenuta', `Hai ricevuto <strong>${item.name}</strong>.`);
  };

  // --- CONFERMA CONVERSIONE (S√¨/No) ---
  dustBtn.onclick = ()=>{
    // Crea un piccolo layer di conferma sopra il modal ricompensa
    const layerId = 'dust-confirm-layer';
    let layer = document.getElementById(layerId);
    if (!layer){
      layer = document.createElement('div');
      layer.id = layerId;
      layer.style.position = 'fixed';
      layer.style.inset = '0';
      layer.style.zIndex = '10000'; // sopra al reward overlay
      layer.innerHTML = `
        <div class="confirm-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,.55)"></div>
        <div class="confirm-dialog" style="position:absolute; left:50%; top:18vh; transform:translateX(-50%);
             width:min(520px,92vw); background:#f6ecd1; border:1px solid #b5914a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.3);">
          <div style="padding:16px; text-align:left">
            <div style="font-weight:700; margin-bottom:6px;">Conferma conversione</div>
            <div>Sei sicuro di voler trasformare l'oggetto in Polvere Arcana? Otterrai <strong>${dustGain}</strong> unit√†.</div>
          </div>
          <div style="display:flex; gap:10px; justify-content:flex-end; padding:0 16px 16px;">
            <button id="dust-confirm-yes" class="magic-button">S√¨</button>
            <button id="dust-confirm-no" class="magic-button">No</button>
          </div>
        </div>`;
      document.body.appendChild(layer);

      // üîí Non chiudere cliccando sul backdrop (niente onclick sulla .confirm-backdrop)
      layer.querySelector('#dust-confirm-no').onclick = ()=>{
        // Chiudi SOLO il layer di conferma, torna al popup ricompensa
        if (layer && layer.parentNode) layer.parentNode.removeChild(layer);
      };

      layer.querySelector('#dust-confirm-yes').onclick = ()=>{
        // Procedi con la conversione
        if (typeof addArcaneDust === 'function') addArcaneDust(dustGain);
        const dEl = document.getElementById('dust-counter');
        if (dEl && typeof getArcaneDust === 'function') dEl.textContent = getArcaneDust();

        // Chiudi conferma e popup ricompensa
        if (layer && layer.parentNode) layer.parentNode.removeChild(layer);
        ov.classList.add('hidden');

        // Messaggio finale
        showGameMessage('Conversione riuscita', `L'oggetto √® stato disperso in <strong>${dustGain}</strong> unit√† di Polvere Arcana.`);
      };
    }
  };
}

function updatePityAfter(tierId, rarity){
  if (typeof getChestPity !== 'function' || typeof setChestPity !== 'function') return;
  const safe = (n)=> Math.max(0, Number(n)||0);

  if (tierId === 'avventuriero'){
    const pre = safe(getChestPity('avventuriero'));
    // Azzera SOLO quando la garanzia √® appena scattata (pre >= 10), altrimenti +1
    setChestPity('avventuriero', pre >= 10 ? 0 : pre + 1);
  } else if (tierId === 're'){
    const pre = safe(getChestPity('re'));
    // Azzera SOLO quando la garanzia √® appena scattata (pre >= 15), altrimenti +1
    setChestPity('re', pre >= 15 ? 0 : pre + 1);
  }
}

function performOpenChest(tierId, category){
  const t = CHEST_TIERS[tierId];
  if (!t) return;

  // Gate livello
  const lvl = getNum('level', 1);
  if (lvl < t.minLevel) {
    showGameMessage('Non puoi ancora aprirlo', `Sblocca al <strong>Livello ${t.minLevel}</strong>.`);
    return;
  }

  // Chiavi
  const have = (typeof getKeyCount==='function') ? getKeyCount(t.keyId) : 0;
  if (have <= 0) {
    const lab = KEY_META?.[t.keyId]?.label || 'Chiave';
    showGameMessage('Chiave mancante', `Ti serve 1 <strong>${lab}</strong>.`);
    return;
  }

  // Rarit√† (con pity)
  let rarity = pickRarityWithPity(tierId, category);
  if (!rarity) { showGameMessage('Errore', 'Impossibile determinare la rarit√†.'); return; }

  // Pool
  const pool = poolBy(category, rarity);
  if (!pool.length) {
    // Non consumo: niente nel pool di questa rarit√† per questa categoria
    showGameMessage('Nessun drop disponibile', `Non esistono oggetti di rarit√† <strong>${rarity}</strong> per <em>${category}</em>.`);
    return;
  }

  // Consuma chiave ora
  if (typeof spendKey === 'function') spendKey(t.keyId, 1);
  if (typeof renderKeyBelt === 'function') renderKeyBelt();

  // Pesca oggetto
  const item = pool[Math.floor(Math.random()*pool.length)];

  // Aggiorna pity in base all'esito
  updatePityAfter(tierId, rarity);

  // UI: aggiorna badge pity e (se presente) contatore polvere
  if (typeof renderChestGrid === 'function') renderChestGrid();

  // Descrizione magie: fallback nome base
  if (item && item.rarity && item.name && typeof baseNameFromVariant === 'function' && typeof magicDescriptions === 'object') {
    if (category === 'magie') {
      const base = baseNameFromVariant(item.name);
      item.desc = magicDescriptions[item.name] || magicDescriptions[base] || item.desc || '';
    }
  }

  // ‚¨áÔ∏è NEW: uniforma i dati delle creature per il popup ricompensa
  if (category === 'creature') {
    // usa la descrizione del catalogo se manca item.desc
    item.desc = item.desc || item.description || '';
    // calcola i tratti dalla tabella fissa in base a nome+rarit√† se non gi√† presenti
    if (!item.traits && typeof getCreatureTraits === 'function') {
      item.traits = getCreatureTraits(item.name);
    }
    // l'immagine arriva gi√† dal catalogo creature (storage.js) come item.img
  }

  // ‚¨áÔ∏è NEW: passo la categoria al popup per la logica dei doppioni
  item._dropCategory = category;

  // Mostra modale ricompensa
  showChestReward(item);

// ‚ûï Quest settimanale: "Apri un forziere"
if (typeof incrementQuest === 'function') incrementQuest('q_weekly_open_chest', 1);
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
if (typeof renderWeeklyQuestsUI === 'function') renderWeeklyQuestsUI();

  // Azione "mantieni" ‚Üí aggiungi in inventario
  const keepBtn = document.getElementById('chest-reward-keep');
  if (keepBtn){
    const nameToAdd = item.name;
    keepBtn.onclick = ()=>{
      addDroppedItemToInventory(category, nameToAdd);
      document.getElementById('chest-reward-overlay').classList.add('hidden');
      showGameMessage('Ricompensa ottenuta', `Hai ricevuto <strong>${nameToAdd}</strong>.`);
    };
  }
}

function confirmOpenChest(tierId, category){
  const t = CHEST_TIERS[tierId];
  if (!t) return;

  const labKey = KEY_META?.[t.keyId]?.label || 'Chiave';
  const msg = `Vuoi aprire <strong>${t.label}</strong> <strong>CATEGORIA ${String(category||'').toUpperCase()}</strong>?<br/>Consumerai <strong>1 ${labKey}</strong>.`;

  // piccolo layer di conferma inline
  const layerId = 'chest-open-confirm-layer';
  let layer = document.getElementById(layerId);
  if (!layer){
    layer = document.createElement('div');
    layer.id = layerId;
    layer.style.position = 'fixed';
    layer.style.inset = '0';
    layer.style.zIndex = '9998';
    layer.innerHTML = `
      <div class="confirm-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,.55)"></div>
      <div class="confirm-dialog" style="position:absolute; left:50%; top:12vh; transform:translateX(-50%);
           width:min(520px,92vw); background:#f6ecd1; border:1px solid #b5914a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.3);">
        <div style="padding:16px; text-align:left" id="chest-open-confirm-text"></div>
        <div style="display:flex; gap:10px; justify-content:flex-end; padding:0 16px 16px;">
          <button id="chest-open-accept" class="magic-button">Apri</button>
          <button id="chest-open-cancel" class="magic-button">Annulla</button>
        </div>
      </div>`;
    document.body.appendChild(layer);

    // üîí NON chiudere al click fuori dalla finestra:
    // layer.querySelector('.confirm-backdrop').onclick = ()=> layer.classList.add('hidden');  // ‚¨ÖÔ∏è rimosso

    // chiudi solo con "Annulla"
    layer.querySelector('#chest-open-cancel').onclick = ()=> layer.classList.add('hidden');
  }

  document.getElementById('chest-open-confirm-text').innerHTML = msg;
  layer.classList.remove('hidden');

  const accept = document.getElementById('chest-open-accept');
  accept.disabled = false;
  accept.onclick = ()=>{
    accept.disabled = true;
    layer.classList.add('hidden');
    performOpenChest(tierId, category);
  };
}

/* Placeholder Mostra Drop ‚Äì nello step 2 mettiamo l‚Äôelenco reale */
function showChestDrops(tierId, category){
  const t = CHEST_TIERS[tierId];
  if (!t) return;
  const odds = t.odds;
  const lines = Object.keys(odds).filter(r=>odds[r]>0).map(r=>{
    const perc = Math.round(odds[r]*1000)/10;
    return `<div><strong>${r}</strong>: ${perc}%</div>`;
  }).join('');
  showGameMessage?.(t.label, `Categoria: <strong>${category}</strong><br/>${lines}`);
}

function showChestsRoom(){
  ensureKeyStores?.();
  ensureChestStores?.();

  document.getElementById('shop').classList.add('hidden');
  document.getElementById('chest-room').classList.remove('hidden');

  renderKeyBelt?.();           // aggiorna subito le chiavi
  selectChestCategory('armi'); // evidenzia il tab "Armi" + renderizza i 4 forzieri
}

function renderMessageList(page=_msgPage) {
  const list = document.getElementById('message-list');
  if (!list) return;
  const msgs = getMessages();
  const total = msgs.length;
  const totalPages = Math.max(1, Math.ceil(total / MSGS_PER_PAGE));
  _msgPage = Math.min(Math.max(1, page), totalPages);

  list.innerHTML = '';

  if (total === 0) {
  list.innerHTML = '<p class="muted">Nessun messaggio.</p>';
  updateMessagesBadge();
  updatePaginationUI(1, 1);

  // nascondi "Elimina selezionati"
  const delBtn = document.getElementById('msg-delete-selected');
  if (delBtn) delBtn.style.display = 'none';

  // üîß FIX: nascondi i bottoni di paginazione quando non ci sono messaggi
  const prev = document.getElementById('msg-prev');
  const next = document.getElementById('msg-next');
  if (prev) prev.style.display = 'none';
  if (next) next.style.display = 'none';

  return;
}


  const start = (_msgPage - 1) * MSGS_PER_PAGE;
  const end   = Math.min(start + MSGS_PER_PAGE, total);
  const pageItems = msgs.slice(start, end);

  pageItems.forEach(m => {
    const item = document.createElement('div');
    item.className = 'message-item';
    item.setAttribute('data-id', m.id);

    // RIGA: [checkbox] [contenuto cliccabile]
    const row = document.createElement('div');
    row.style.display = 'grid';
    row.style.gridTemplateColumns = 'auto 1fr';
    row.style.alignItems = 'center';
    row.style.gap = '10px';

    // CHECKBOX A SINISTRA
    const sel = document.createElement('input');
    sel.type = 'checkbox';
    sel.className = 'msg-select';
    sel.setAttribute('data-id', m.id);
    sel.checked = _msgSelection.has(m.id);
    sel.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = sel.getAttribute('data-id');
      if (sel.checked) _msgSelection.add(id); else _msgSelection.delete(id);
      refreshDeleteSelectedVisibility();
    });

    // CONTENUTO (clic apre il popup)
    const content = document.createElement('div');
    content.style.cursor = 'pointer';

    const title = document.createElement('div');
    title.className = 'message-title' + (m.unread ? '' : ' read');
    title.textContent = m.title || 'Messaggio';

    const meta = document.createElement('div');
    meta.className = 'muted';
    meta.textContent = fmtDateTimeShort(m.when); // DATA + ORA AFFIANCATE

    content.appendChild(title);
    content.appendChild(meta);

    content.addEventListener('click', () => openMessageById(m.id));

    row.appendChild(sel);
    row.appendChild(content);
    item.appendChild(row);
    list.appendChild(item);
  });
// PULSANTE ELIMINA SELEZIONATI
const delBtn = document.getElementById('msg-delete-selected');
if (delBtn) {
  delBtn.onclick = () => {
    if (_msgSelection.size === 0) return;
    const count = _msgSelection.size;
    showConfirmDialog({
      title: 'Eliminare messaggi',
      text: `Sei sicuro di voler eliminare ${count === 1 ? 'il messaggio selezionato' : count + ' messaggi selezionati'}?`,
      okText: 'Conferma',
      cancelText: 'Annulla',
      onConfirm: () => {
        deleteMessagesByIds(Array.from(_msgSelection));
        _msgSelection.clear();
        const after = getMessages().length;
        const newTotalPages = Math.max(1, Math.ceil(after / MSGS_PER_PAGE));
        if (_msgPage > newTotalPages) _msgPage = newTotalPages;
        renderMessageList(_msgPage);
      }
    });
  };
}

  // PAGINAZIONE (IN FONDO, UNO SOTTO L'ALTRO)
  const prev = document.getElementById('msg-prev');
  const next = document.getElementById('msg-next');
  const totalPagesNow = Math.max(1, Math.ceil(getMessages().length / MSGS_PER_PAGE));

  if (prev) {
    prev.onclick = () => renderMessageList(_msgPage - 1);
  }
  if (next) {
    next.onclick = () => renderMessageList(_msgPage + 1);
  }

  // REGOLE VISIBILIT√Ä:
  // - PRIMA PAGINA: SOLO "SUCCESSIVA"
  // - ULTIMA PAGINA: SOLO "PRECEDENTE"
  // - PAGINE INTERMEDIE: ENTRAMBI
  if (prev && next) {
    if (_msgPage <= 1 && totalPagesNow > 1) {
      prev.style.display = 'none';
      next.style.display = 'block';
    } else if (_msgPage >= totalPagesNow && totalPagesNow > 1) {
      prev.style.display = 'block';
      next.style.display = 'none';
    } else if (totalPagesNow <= 1) {
      prev.style.display = 'none';
      next.style.display = 'none';
    } else {
      prev.style.display = 'block';
      next.style.display = 'block';
    }
  }

  updatePaginationUI(_msgPage, totalPagesNow);
  refreshDeleteSelectedVisibility();
}

// Ri-uso le funzioni gi√† introdotte prima:
function openMessageById(id) {
  const msgs = getMessages();
  const idx = msgs.findIndex(m => m.id === id);
  if (idx < 0) return;
  _openMsgId = id;
  openMessage(idx);
}

function deleteMessagesByIds(ids) {
  const all = getMessages();
  const keep = all.filter(m => !ids.includes(m.id));
  setMessages(keep);
  updateMessagesBadge();
}

function updatePaginationUI(page, totalPages) {
  const lbl = document.getElementById('msg-page-label');
  if (!lbl) return;
  if (totalPages <= 1) {
    lbl.textContent = '';
  } else {
    lbl.textContent = `Pagina ${page} di ${totalPages}`;
  }
}

function refreshDeleteSelectedVisibility() {
  const delBtn = document.getElementById('msg-delete-selected');
  if (delBtn) delBtn.style.display = _msgSelection.size > 0 ? 'inline-block' : 'none';
}
function updateSelectAllCheckbox() {
  const selectAll = document.getElementById('msg-select-all');
  if (!selectAll) return;
  const msgs = getMessages();
  const total = msgs.length;
  if (total === 0) { selectAll.checked = false; return; }
  const start = (_msgPage - 1) * MSGS_PER_PAGE;
  const end   = Math.min(start + MSGS_PER_PAGE, total);
  const pageIds = msgs.slice(start, end).map(m => m.id);
  selectAll.checked = pageIds.every(id => _msgSelection.has(id)) && pageIds.length > 0;
}
// L'eroe corrente appartiene a una gilda?
function isCurrentHeroInGuild(){
  try {
    if (typeof getMyGuild === 'function') {
      const g = getMyGuild();
      if (g && (g.id || g.name)) return true;
    }
  } catch {}
  try {
    const u = (typeof getCurrentUser === 'function') ? getCurrentUser() : (window.currentUser || null);
    if (u && (u.guildId || u.guild)) return true;
  } catch {}
  return false;
}

// --- helper cancellazione multipla ---
function deleteMessagesByIds(ids) {
  const all = getMessages();
  const keep = all.filter(m => !ids.includes(m.id));
  setMessages(keep);
  updateMessagesBadge();
}
function ensureMessagePopup() {
  let overlay = document.getElementById('message-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'message-overlay';
    overlay.className = 'hidden';
    document.body.appendChild(overlay);
    overlay.onclick = closeMessagePopup; // chiudi cliccando il backdrop
  }

  let popup = document.getElementById('message-popup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'message-popup';
    popup.className = 'hidden';
    popup.innerHTML = `
  <h3 id="message-popup-title">Messaggio</h3>
  <div id="message-popup-body"></div>
  <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
    <button class="btn-danger" onclick="deleteOpenMessage()">Elimina</button>
    <button class="close-button" onclick="closeMessagePopup()">Chiudi</button>
  </div>
`;
    document.body.appendChild(popup);
  }

  return { overlay, popup };
}

function openMessage(index) {
  const msgs = getMessages();
  const m = msgs[index];
  if (!m) return;

  // Segna come letto
  if (m.unread) {
    m.unread = false;
    setMessages(msgs);
  }

  // ====== Parsing del corpo (supporta nuovo e vecchio formato) ======
  let oro = '-', xp = '-', pa = '0', cxp = '-', missionName = 'Missione';
  let hasCrystalLine = false; // NEW
  try {
    const body = String(m.body || '');

    // Rileva riga "Complimenti, hai trovato 1/3 del cristallo..." (nuovo formato)
    hasCrystalLine = /complimenti,\s*hai\s*trovato\s*1\/3\s*del\s*cristallo/i.test(body);

    // Estrai info dal corpo (compat nuov/vecchio formato)
    // - Missione: <nome>
    // - Oro: <n>
    // - XP: <n>
    // - PA: <n>
    // - CXP: <n>
    // Tieni conto che alcuni campi potrebbero mancare a seconda del tipo.
    const lines = body.split(/\r?\n/);

    // Cerca nome missione
    for (const raw of lines) {
      const s = raw.trim();
      if (/^Missione\s*:/.test(s)) {
        const mm = s.match(/^Missione\s*:\s*(.+)$/i);
        if (mm && mm[1]) missionName = mm[1].trim();
        break;
      }
    }

    // Cerca numeri
    for (const raw of lines) {
      const s = raw.trim();
      if (/^Oro\s*:/.test(s) && oro === '-') {
        const mm = s.match(/(\d[\d.]*)/);
        if (mm) oro = mm[1].replace(/\./g, '');
      }
      if (/^XP\s*:/.test(s) && xp === '-') {
        const mm = s.match(/(\d+)/);
        if (mm) xp = mm[1];
      }
      if (/^PA\s*:/.test(s) && pa === '0') {
        const mm = s.match(/(\d+)/);
        if (mm) pa = mm[1];
      }
      if (/^CXP\s*:/.test(s) && cxp === '-') {
        const mm = s.match(/(\d+)/);
        if (mm) cxp = mm[1];
      }

      // Compat con etichette estese/nuove (italiano)
if (/^Oro guadagnato:/i.test(s) && oro === '-') {
  // cattura numeri anche con separatori (es. "1.234")
  const mm = s.match(/(-|[\d\.]+)/);
  if (mm) oro = mm[1].replace(/\./g, ''); // tolgo i punti per poter ri-formattare
  continue;
}
if (/^Esperienza guadagnata:/i.test(s) && xp === '-') {
  const mm = s.match(/(-|\d+)/);
  if (mm) xp = (mm[1] === '-' ? '0' : mm[1]);
  continue;
}
// NB: accetto sia "abilit√†" con accento sia "abilita" senza
if (/^Punti abil(?:it√†|ita)\s+guadagnati:/i.test(s) && pa === '0') {
  const mm = s.match(/(-|\d+)/);
  if (mm) pa = (mm[1] === '-' ? '0' : mm[1]);
  continue;
}
// NEW: riga per la creatura
if (/^Esperienza\s+creatura\s+guadagnata:/i.test(s) && cxp === '-') {
  const mm = s.match(/(-|\d+)/);
  if (mm) cxp = (mm[1] === '-' ? '0' : mm[1]);
  continue;
}
    }

    // Se non abbiamo trovato il nome con "Missione: ...", nel NUOVO formato √®
    // la prima riga non vuota dopo "Complimenti, hai terminato la missione."
    if (missionName === 'Missione') {
      const nonEmpty = lines.map(s => s.trim()).filter(Boolean);
      if (nonEmpty.length >= 2) missionName = nonEmpty[1];
    }
  } catch {}

  // ====== Assicura finestra messaggio (no popup) ======
  const { screen, titleEl, bodyEl, deleteBtn, replyBtn } = ensureMessageWindow();
if (replyBtn) replyBtn.classList.add('hidden'); // di default: nascosto, lo mostro solo per i DM
  // di default nascondo il bottone "Elimina": lo abilito nei casi consentiti
  if (deleteBtn) deleteBtn.classList.add('hidden');

  // --- INVITO GILDA: renderer custom ---
  if (m && m.type === 'guild_invite') {
    // titolo
    if (titleEl) titleEl.textContent = m.title || 'Invito alla Gilda';

    // corpo: usa il renderer dedicato gi√† definito nel file
    if (typeof renderGuildInviteDetail === 'function' && bodyEl) {
      renderGuildInviteDetail(bodyEl, m);

      // mostra finestra + aggiorna UI messaggi
      showMessageWindow();

      if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
      if (typeof renderMessageList === 'function') renderMessageList();
    }
    return;
  }

  // --- RICHIESTA ACCESSO GILDA ---
  if (m && m.type === 'guild_request') {
    if (titleEl) titleEl.textContent = m.title || 'Richiesta di accesso alla Gilda';

    if (typeof renderGuildRequestDetail === 'function' && bodyEl) {
      renderGuildRequestDetail(bodyEl, m);

      // mostra finestra
      showMessageWindow();

      if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
      if (typeof renderMessageList === 'function') renderMessageList();
    }
    return;
  }
// --- RICHIESTA DI ALLEANZA TRA GILDE ---
if (m && m.type === 'guild_alliance_request') {
  if (titleEl) titleEl.textContent = m.title || 'Richiesta di Alleanza';

  if (bodyEl) {
    // username corrente (stringa)
    const currentUserName =
      (typeof currentUser === 'string' && currentUser) ||
      (typeof getCurrentUser === 'function' ? getCurrentUser() : '') ||
      (typeof window !== 'undefined' ? window.currentUser : '');

    // gilda DESTINATARIA presa dal messaggio (non dallo userStore locale)
    const allGuilds = (typeof getGuilds === 'function') ? getGuilds() : {};
    const targetGuild = m.toGuildId ? allGuilds[m.toGuildId] : null;

    // fallback: se per qualche motivo toGuildId mancasse, prova a dedurre la gilda dell‚Äôutente
    const myGuildFallback = (typeof findGuildOfUser === 'function') ? findGuildOfUser(currentUserName) : null;
    const effectiveTargetGuild = targetGuild || myGuildFallback;

    const iAmTargetLeader = !!(effectiveTargetGuild && effectiveTargetGuild.owner === currentUserName);

// >>> NUOVO: verifica se la richiesta √® ancora pendente
    let stillPending = true;
    try {
      if (typeof listPendingFor === 'function') {
        const pendFor = listPendingFor(m.toGuildId) || [];
stillPending = pendFor.some(p => p.from === m.fromGuildId && p.to === m.toGuildId);
      }
    } catch(_) {}

    if (!stillPending) {
      // Richiesta non pi√π valida: solo info + back
      bodyEl.innerHTML = `
  <div style="margin-bottom:10px;">Richiesta non pi√π disponibile (ritirata o gi√† gestita).</div>
`;

      showMessageWindow(); updateMessagesBadge?.(); renderMessageList?.();
      return;
    }

    bodyEl.innerHTML = `
      <div style="margin-bottom:10px;">${m.body || ''}</div>
      ${iAmTargetLeader ? `
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="ally-accept" class="magic-button">Accetta</button>
          <button id="ally-reject" class="btn-danger">Rifiuta</button>
        </div>
      ` : `
        <div class="muted" style="margin-bottom:8px;">Solo il Capogilda destinatario pu√≤ accettare o rifiutare.</div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button class="close-button" onclick="closeMessageDetail(_msgView||'inbox')">Torna ai messaggi</button>
        </div>
      `}
    `;

    if (iAmTargetLeader) {
      const doFinalize = () => {
        try { deleteMessagesByIds([m.id]); } catch(_){}
        try { updateMessagesBadge?.(); renderMessageList?.(); } catch(_){}
        try { closeMessagePopup?.(); } catch(_){}
        // rientra nella inbox dopo l‚Äôazione
        closeMessageDetail(_msgView||'inbox');
      };

      document.getElementById('ally-accept')?.addEventListener('click', () => {
        if (typeof acceptAlliance === 'function') acceptAlliance(m.fromGuildId, m.toGuildId);
        doFinalize();
      });

      document.getElementById('ally-reject')?.addEventListener('click', () => {
        if (typeof rejectAlliance === 'function') rejectAlliance(m.fromGuildId, m.toGuildId);
        doFinalize();
      });
    }
  }

  showMessageWindow();
  updateMessagesBadge?.();
  renderMessageList?.();
  return;
}
// --- RICHIESTA DI ALLEANZA RITIRATA (notifica informativa) ---
if (m && m.type === 'guild_alliance_withdrawn') {
  if (titleEl) titleEl.textContent = m.title || 'Richiesta di alleanza ritirata';
  if (bodyEl) {
    const safe = String(m.body || '').replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;

  }
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }
  showMessageWindow(); updateMessagesBadge?.(); renderMessageList?.();
  return;
}

// --- ESITI ALLEANZA (accettata / rifiutata / nuova alleanza) ---
if (m && (m.type === 'guild_alliance_accept' || m.type === 'guild_alliance_reject' || m.type === 'guild_alliance_new')) {
  // Titolo sensato
  if (titleEl) {
    titleEl.textContent =
      m.title ||
      (m.type === 'guild_alliance_accept' ? 'Richiesta di alleanza accettata'
       : m.type === 'guild_alliance_reject' ? 'Richiesta di alleanza rifiutata'
       : 'Nuova alleanza');
  }

  if (bodyEl) {
    const safe = String(m.body || '').replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;
  }

  // "Elimina" solo in inbox/archivio
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }

  showMessageWindow();
  updateMessagesBadge?.();
  renderMessageList?.();
  return;
}


  // --- NOTIFICHE GILDA: accettazione / comunicazioni ---
  if (m && (m.type === 'guild_request_accepted' || m.type === 'guild_notice')) {
    if (titleEl) {
      titleEl.textContent =
        m.title ||
        (m.type === 'guild_request_accepted' ? 'Richiesta approvata' : 'Comunicazione della Gilda');
    }

    if (bodyEl) {
      if (typeof renderGuildGenericDetail === 'function') {
        renderGuildGenericDetail(bodyEl, m);
      } else {
  // Consenti solo <strong> e <br>, rimuovi qualsiasi altro tag
  const safe = String(m.body || '')
    .replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
  bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;
}
    }

    // mostra finestra
    showMessageWindow();

    // mostra/nascondi "Elimina" in base alla vista
    if (deleteBtn) {
      const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
      deleteBtn.classList.toggle('hidden', !canDelete);
    }

    if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
    if (typeof renderMessageList === 'function') renderMessageList();
    return;
  }

// --- DICHIARAZIONE DI GUERRA ---
if (m && m.type === 'guild_war_declare') {
  if (titleEl) titleEl.textContent = m.title || 'Dichiarazione di guerra';
  if (bodyEl) {
    const safe = String(m.body || '').replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;
  }
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }
  showMessageWindow(); updateMessagesBadge?.(); renderMessageList?.();
  return;
}

// --- DICHIARAZIONE DI RESA ---
if (m && m.type === 'guild_war_surrender') {
  if (titleEl) titleEl.textContent = m.title || 'Dichiarazione di resa';
  if (bodyEl) {
    const safe = String(m.body || '').replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;
  }
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }
  showMessageWindow(); updateMessagesBadge?.(); renderMessageList?.();
  return;
}

// --- GUERRA: VITTORIA / SCONFITTA (renderer semplice, NO report missione) ---
if (m && (m.type === 'guild_war_victory' || m.type === 'guild_war_defeat')) {
  if (titleEl) titleEl.textContent = m.title || (m.type === 'guild_war_victory' ? 'Vittoria di Gilda' : 'Sconfitta di Gilda');

  if (bodyEl) {
    // consenti solo <strong> e <br>, rimuovi qualsiasi altro tag
    const safe = String(m.body || '').replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p><p class="muted">${fmtDateTime(m.when)}</p>`;
  }

  // mostra/nascondi "Elimina" (coerente con altri messaggi di sistema)
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }

  showMessageWindow();
  updateMessagesBadge?.();
  renderMessageList?.();
  return;
}


// --- SFIDA PVP (notifica) ---
if (m && m.type === 'pvp_challenge') {
  if (titleEl) titleEl.textContent = m.title || 'Sfida ricevuta';

  if (bodyEl) {
    // Consenti solo <strong> e <br>, rimuovi qualsiasi altro tag
    const safe = String(m.body || '')
      .replace(/<(?!\/?strong\b|br\s*\/?)[^>]*>/gi, '');
    bodyEl.innerHTML = `<p>${safe}</p>`;
  }

  // Nessuna risposta per notifiche di sistema
  if (replyBtn) replyBtn.classList.add('hidden');

  // Mostra finestra e aggiorna UI
  showMessageWindow();

  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }

  if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
  if (typeof renderMessageList === 'function') renderMessageList();
  return;
}

// --- MESSAGGIO COLLETTIVO GILDA ---
if (m && m.type === 'guild_broadcast') {
  // titolo
  if (titleEl) titleEl.textContent = m.title || 'Messaggio Collettivo';

  // corpo: mittente + data + testo (rispetta gli "a capo")
  if (bodyEl) {
    const safe = escapeHtml(String(m.body || '')).replace(/\n/g, '<br>');
    bodyEl.innerHTML = `
      <div class="muted" style="margin-bottom:8px">
        <div><strong>Da:</strong> ${escapeHtml(String(m.from || ''))}</div>
        <div><strong>Data:</strong> ${fmtDateTime(m.when)}</div>
      </div>
      <div>${safe}</div>
    `;
  }

  // mostra "Rispondi" (indirizzato al mittente)
if (replyBtn){
  replyBtn.classList.remove('hidden');
  replyBtn.onclick = ()=>{
    // Chiudi la finestra di lettura e apri direttamente il composer
    document.getElementById('message-window')?.classList.add('hidden');
    openComposeTo(m.from || '');
  };
}


  // mostra finestra, abilita/elimina come gli altri
  showMessageWindow();
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }

  // importante: FERMA il renderer qui (evita layout missione)
  if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
  if (typeof renderMessageList === 'function') renderMessageList();
  return; // ‚Üê‚Üê‚Üê questa riga √® la chiave
}

  // --- MESSAGGIO PRIVATO (DM) ---
  if (m && m.type === 'dm') {
    if (titleEl) titleEl.textContent = m.title || 'Messaggio privato';

    if (bodyEl) {
      if (typeof renderDirectMessageDetail === 'function') {
        renderDirectMessageDetail(bodyEl, m);
      } else {
        bodyEl.innerHTML = `
          <div class="muted" style="margin-bottom:8px">
            <div><strong>Da:</strong> ${escapeHtml(String(m.from || ''))}</div>
            <div><strong>Data:</strong> ${fmtDateTime(m.when)}</div>
          </div>
          <div>${escapeHtml(String(m.body || '')).replace(/\n/g,'<br>')}</div>
        `;
      }
    }

    // mostra finestra
    showMessageWindow();

    // mostra/nascondi "Elimina"
    if (deleteBtn) {
      const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
      deleteBtn.classList.toggle('hidden', !canDelete);
    }
// === Abilita "Rispondi" per i DM e preimposta destinatario + oggetto ===
if (replyBtn) {
  replyBtn.classList.remove('hidden');
  // salva info sull'ultimo messaggio aperto, cos√¨ replyToOpenMessage le recupera
  replyBtn.dataset.to = String(m.from || '').trim();
  // evita doppio "Re: " se gi√† presente
  const baseSubj = m.title || 'Messaggio';
  replyBtn.dataset.subject = baseSubj.startsWith('Re: ') ? baseSubj : `Re: ${baseSubj}`;
}
    if (typeof updateMessagesBadge === 'function') updateMessagesBadge();
    if (typeof renderMessageList === 'function') renderMessageList();
    return;
  }

  // --- FALLBACK: Report missione o altro ---
  if (titleEl) {
    titleEl.textContent = m.title || 'Messaggio';
  }

  if (bodyEl) {
    const oroFmt = (oro === '-' ? '-' : formatGold(Number(oro)));
bodyEl.innerHTML = `
  <p><strong>Complimenti, hai terminato la missione.</strong></p>

  <p><strong>${missionName}</strong></p>
  <hr style="border:none;border-top:1px solid #6b4226; margin:8px 0;">

  <p><strong>Oro guadagnato:</strong> ${oroFmt}</p>
  <p><strong>Esperienza guadagnata:</strong> ${xp} XP</p>
  <p><strong>Punti abilit√† guadagnati:</strong> ${pa}</p>
  <p><strong>Esperienza creatura guadagnata:</strong> ${cxp} XP</p>

  ${hasCrystalLine
    ? `<p style="color:#b00000; font-weight:bold; margin-top:6px;">COMPLIMENTI, HAI TROVATO 1/3 DEL CRISTALLO DI POTENZIAMENTO!</p>`
    : ``}

  <p class="muted">${fmtDateTime(m.when)}</p>
`;
  }
  // Mostra/nascondi "Elimina"
  if (deleteBtn) {
    const canDelete = (_msgView === 'inbox' || _msgView === 'arch');
    deleteBtn.classList.toggle('hidden', !canDelete);
  }

  // ====== Mostra overlay + popup ======
  showMessageWindow();

  updateMessagesBadge();
  renderMessageList();
}

function replyToOpenMessage(){
  const replyBtn = document.getElementById('msgwin-reply');
  if (!replyBtn) return;

  const rawTo = (replyBtn.dataset.to || '').trim();
  const to = rawTo.replace(/<[^>]+>/g, '');

  // vai alla vista compose e chiudi il dettaglio senza tornare alla inbox
  if (typeof setMessageView === 'function') { try { setMessageView('compose'); } catch(e){} }
  closeMessageDetail?.('compose');

  // helper: trova campi destinatario e corpo (inclusi i tuoi id reali)
  function findComposeInputs(){
    const toInput = document.querySelector(
      [
        '#msg-to', // tuo campo destinatario
        '#dm-to', '#message-to', '#compose-to', '#recipient', '#destinatario',
        'input[name="dm-to"]', 'input[name="message-to"]', 'input[name="to"]',
        'input[placeholder*="Destinatario"]', 'input[placeholder*="A:"]'
      ].join(', ')
    );
    const bodyInput = document.querySelector(
      [
        '#msg-body-input', // tuo textarea del testo
        '#dm-body', '#message-body', '#compose-body',
        'textarea[name="dm-body"]', 'textarea[name="message-body"]', 'textarea[name="body"]',
        'textarea'
      ].join(', ')
    );
    return { toInput, bodyInput };
  }

  // aspetta che l‚Äôeditor sia pronto (max ~1.5s)
  let attempts = 0;
  const maxAttempts = 15;
  const timer = setInterval(() => {
    attempts++;
    const { toInput, bodyInput } = findComposeInputs();

    if (toInput) {
      // svuota bozza precedente
      if (bodyInput) {
        bodyInput.value = '';
        bodyInput.dispatchEvent(new Event('input',  { bubbles: true }));
        bodyInput.dispatchEvent(new Event('change', { bubbles: true }));
      }

      // imposta destinatario
      toInput.value = to;
      toInput.dispatchEvent(new Event('input',  { bubbles: true }));
      toInput.dispatchEvent(new Event('change', { bubbles: true }));

      // focus nel corpo
      if (bodyInput) {
        bodyInput.focus();
        const len = bodyInput.value.length;
        try { bodyInput.setSelectionRange(len, len); } catch(e){}
      }

      clearInterval(timer);
    } else if (attempts >= maxAttempts) {
      clearInterval(timer);
    }
  }, 100);
}



// === Finestra messaggio NON-popup ===
function ensureMessageWindow(){
  let screen = document.getElementById('message-window');
  if (!screen) {
    // fallback: se non esistesse gi√† creato via HTML, lo creo dinamicamente
    screen = document.createElement('section');
    screen.id = 'message-window';
    screen.className = 'hidden';
    screen.innerHTML = `
      <h2 id="message-window-title">Messaggio</h2>
      <div id="message-window-body" class="scroll-area"></div>
      <div class="mw-actions" style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end;">
        <button id="msgwin-delete" class="btn-danger hidden" onclick="deleteOpenMessage()">Elimina</button>
        <button id="msgwin-reply" class="magic-button hidden" onclick="replyToOpenMessage()">Rispondi</button>
        <button id="msgwin-back" class="magic-button" onclick="closeMessageDetail()">‚Üê Torna ai messaggi</button>
      </div>`;
    const anchor = document.getElementById('messages');
    if (anchor && anchor.parentNode) anchor.parentNode.insertBefore(screen, anchor.nextSibling);
    else document.body.appendChild(screen);
  }

  // riferimenti
  const titleEl  = document.getElementById('message-window-title');
  const bodyEl   = document.getElementById('message-window-body');
  const deleteBtn= document.getElementById('msgwin-delete');
  const replyBtn = document.getElementById('msgwin-reply');

  // allinea a sinistra il corpo (anche se la sezione esiste gi√†)
  if (bodyEl) bodyEl.style.textAlign = 'left';

  return {
    screen,
    titleEl,
    bodyEl,
    deleteBtn,
    replyBtn
  };
}

function resetComposeForm(){
  const toInput = document.querySelector(
    [
      '#msg-to',                    // tuo id reale
      '#dm-to', '#message-to', '#compose-to', '#recipient', '#destinatario',
      'input[name="dm-to"]', 'input[name="message-to"]', 'input[name="to"]'
    ].join(', ')
  );
  const bodyInput = document.querySelector(
    [
      '#msg-body-input',           // tuo id reale
      '#dm-body', '#message-body', '#compose-body',
      'textarea[name="dm-body"]', 'textarea[name="message-body"]', 'textarea[name="body"]',
    ].join(', ')
  );

  if (toInput) {
    toInput.value = '';
    toInput.dispatchEvent(new Event('input',  { bubbles: true }));
    toInput.dispatchEvent(new Event('change', { bubbles: true }));
  }
  if (bodyInput) {
    bodyInput.value = '';
    bodyInput.dispatchEvent(new Event('input',  { bubbles: true }));
    bodyInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // Se usi storage per bozze, azzera eventuali chiavi comuni (best-effort, non rompe se non esistono)
  try {
    window.userStore?.set && window.userStore.set('draftMessage', null);
    window.userStore?.set && window.userStore.set('composeDraft', null);
  } catch(e){}
}
// Apri l'editor messaggi gi√† indirizzato a <to> e col cursore nel testo
function openComposeTo(to){
  const cleanTo = String(to || '').replace(/<[^>]+>/g, '').trim();
  if (!cleanTo) return;

  // Se il chiamante non ha deciso dove tornare, default: Sala degli Eroi
  if (!window._composeBackTo) window._composeBackTo = 'hero-hall';

  // 1) Porta visivamente l'utente nella pagina "Messaggi"
  const menu        = document.getElementById('menu');
  const messages    = document.getElementById('messages');
  const heroHall    = document.getElementById('hero-hall');
  const heroProfile = document.getElementById('hero-profile-view');
  const guildMembers= document.getElementById('guild-members-view');
  const guildScreen = document.getElementById('guild-screen');

  if (menu)         menu.classList.add('hidden');
  if (heroHall)     heroHall.classList.add('hidden');
  if (heroProfile)  heroProfile.classList.add('hidden');
  if (guildMembers) guildMembers.classList.add('hidden');
  if (guildScreen)  guildScreen.classList.add('hidden');
  if (messages)     messages.classList.remove('hidden');

  // 2) Vista compose + reset bozza
  if (typeof setMessageView === 'function') { try { setMessageView('compose'); } catch(e){} }
  if (typeof resetComposeForm === 'function') { try { resetComposeForm(); } catch(e){} }

  // 3) Attendi che il composer sia renderizzato, poi compila "A:" e metti il focus nel testo
  let attempts = 0;
  const maxAttempts = 15; // ~1.5s
  const timer = setInterval(() => {
    attempts++;

    const toInput = document.querySelector(
      [
        '#msg-to',                    // tuo id reale destinatario
        '#dm-to', '#message-to', '#compose-to', '#recipient', '#destinatario',
        'input[name="dm-to"]', 'input[name="message-to"]', 'input[name="to"]'
      ].join(', ')
    );
    const bodyInput = document.querySelector(
      [
        '#msg-body-input',            // tuo id reale testo
        '#dm-body', '#message-body', '#compose-body',
        'textarea[name="dm-body"]', 'textarea[name="message-body"]', 'textarea[name="body"]',
        'textarea'
      ].join(', ')
    );

    if (toInput) {
      // compila destinatario
      toInput.value = cleanTo;
      toInput.dispatchEvent(new Event('input',  { bubbles: true }));
      toInput.dispatchEvent(new Event('change', { bubbles: true }));

      // focus nel corpo messaggio (caret in fondo)
      if (bodyInput) {
        bodyInput.focus();
        const len = bodyInput.value.length;
        try { bodyInput.setSelectionRange(len, len); } catch(e){}
      }

      clearInterval(timer);
    } else if (attempts >= maxAttempts) {
      clearInterval(timer);
    }
  }, 100);
}


function showMessageWindow(){
  document.getElementById('messages')?.classList.add('hidden');
  document.getElementById('message-window')?.classList.remove('hidden');
}

function closeMessageDetail(nextView){
  document.getElementById('message-window')?.classList.add('hidden');
  document.getElementById('messages')?.classList.remove('hidden');
  // riallinea eventuale lista / vista
  if (typeof setMessageView === 'function') {
    setMessageView(nextView || window._msgView || 'inbox');
  }
}


// chiudi popup
function closeMessagePopup() {
  document.getElementById('message-popup')?.classList.add('hidden');
  document.getElementById('message-overlay')?.classList.add('hidden');
}

// (facoltativo) esponi globalmente in caso di anomalie di scope
window.openMessage = openMessage;
window.closeMessagePopup = closeMessagePopup;

function formatDurationLabel(minutes){
  if (minutes < 1) {
    const sec = Math.round(minutes * 60);
    return `${sec} secondi`;
  }
  return `${minutes} minuti`;
}

function openMissionDetail(mId){
  const m = missions.find(x => x.id === mId);
  if (!m) return;

  // dati base
  const r = calcMissionRewards(m.duration, m.difficulty);
  const rem = getCooldownRemaining(mId);
  const hasActive = !!getActiveMission();

  // popola UI
  document.getElementById('mission-detail-title').textContent = m.name;
  const descLines = missionDescriptions[mId] || ["", "", "", ""];
  document.getElementById('mission-detail-desc').innerHTML = descLines.join('<br>');
  document.getElementById('mission-detail-diff').innerHTML = `<strong>Difficolt√†:</strong> ${m.difficulty}`;
  document.getElementById('mission-detail-rew').innerHTML =
    `<strong>Ricompensa</strong><br>Oro: ${formatGold(r.gold)}<br>Esperienza: ${r.xp} XP<br>Punti Abilit√†: ${r.abilityPoints} <br>Esperienza creatura: ${r.abilityPoints} XP`;

  document.getElementById('mission-detail-dur').innerHTML =
    `<strong>Durata:</strong> ${formatDurationLabel(m.duration)}`;

  // bottone avvio
  const startBtn = document.getElementById('mission-detail-start');
  startBtn.onclick = () => {
    closeMissionDetail();
    startMission(mId);
  };

  // abilita/disabilita il tasto
  if (rem > 0) {
    startBtn.disabled = true;
    startBtn.textContent = `In ricarica ‚Äî disponibile tra ${formatHM(rem)}`;
  } else if (hasActive) {
    startBtn.disabled = true;
    startBtn.textContent = 'Hai gi√† una missione in corso';
  } else {
    startBtn.disabled = false;
    startBtn.textContent = 'Avvia Missione';
  }

  // MOSTRA OVERLAY GENERICO E AGGANCIA CHIUSURA
  const ov = document.getElementById('generic-overlay');
  if (ov) {
    ov.classList.remove('hidden');
    ov.onclick = closeMissionDetail;
  }

  // mostra il popup
  document.getElementById('mission-detail').classList.remove('hidden');
}

// Crea al volo overlay+modale per le creature se mancanti
function ensureCreatureModal() {
  let overlay = document.getElementById('creature-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'creature-overlay';
    overlay.className = 'hidden';
    document.body.appendChild(overlay);
  }

  let modal = document.getElementById('creature-detail');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'creature-detail';
    modal.className = 'hidden';
    modal.innerHTML = `
      <h3 id="creature-detail-title">Creatura</h3>
      <div id="creature-detail-body"></div>
      <div style="margin-top:12px; display:flex; gap:8px; justify-content: flex-end;">
        <button id="creature-detail-buy" class="magic-button" style="width:auto;">Acquista</button>
        <button onclick="closeCreatureDetail()" style="width:auto;">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }

  // chiudi cliccando il backdrop
  overlay.onclick = closeCreatureDetail;
}
function closeCreatureDetail() {
  document.getElementById('creature-overlay')?.classList.add('hidden');
  document.getElementById('creature-detail')?.classList.add('hidden');
  unlockBodyScroll();
}


function closeMissionDetail(){
  document.getElementById('mission-detail')?.classList.add('hidden');
  document.getElementById('generic-overlay')?.classList.add('hidden');
}


function getMissionCooldowns() {
  return userStore.get('missionCooldowns') || {};
}
function setMissionCooldown(id, endTs) {
  const map = getMissionCooldowns();
  map[id] = endTs;
  userStore.set('missionCooldowns', map);
}
function getCooldownRemaining(id) {
  const end = getMissionCooldowns()[id];
  if (!end) return 0;
  return Math.max(0, end - Date.now());
}
function formatHM(ms) {
  const totalMin = Math.ceil(ms / 60000); // arrotondo ai minuti
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  const hh = h === 1 ? 'ora' : 'ore';
  const mm = m === 1 ? 'minuto' : 'minuti';
  if (h > 0) return `${h} ${hh} e ${m} ${mm}`;
  return `${m} ${mm}`;
}

function msToMMSS(ms) {
  // Manteniamo il nome esistente per compatibilit√†.
  const totalSec = Math.max(0, Math.floor(ms / 1000));
  const hh = Math.floor(totalSec / 3600);
  const mm = Math.floor((totalSec % 3600) / 60);
  const ss = totalSec % 60;

  const mmStr = String(mm).padStart(2, '0');
  const ssStr = String(ss).padStart(2, '0');

  // Se ci sono ore (>0) usiamo H:MM:SS (ore senza padding, minuti e secondi a 2 cifre).
  // Se non ci sono ore, manteniamo il comportamento precedente (MM:SS).
  if (hh > 0) {
    return `${hh}:${mmStr}:${ssStr}`;
  } else {
    return `${mmStr}:${ssStr}`;
  }
}

function showGameMessage(title, text) {
  const { overlay, popup } = ensureMessagePopup();
  const t = document.getElementById('message-popup-title');
  const b = document.getElementById('message-popup-body');

  if (t) t.textContent = title || 'Messaggio';
  if (b) b.innerHTML = `<p>${text || ''}</p>`;
  // Nascondi il bottone "Elimina" per i popup generici (vittoria/sconfitta)
  const delBtn = document.querySelector('#message-popup .btn-danger[onclick="deleteOpenMessage()"]');
  if (delBtn) delBtn.classList.add('hidden');

  overlay.classList.remove('hidden');
  popup.classList.remove('hidden');
}


function getActiveMission() {
  const id = userStore.get('missionActive');
  if (!id) return null;
  return missions.find(m => m.id === id) || null;
}

function renderMissionsUI() {
  const active = getActiveMission();
  const activeBox = document.getElementById('mission-active-box');
  const list = document.getElementById('missions-list');

  list.innerHTML = '';

  // --- Pulsante Benefici ---
  const benefitsWrap = document.createElement('div');
  benefitsWrap.style.margin = '6px 0';
  const benefitsBtn = document.createElement('button');
  benefitsBtn.className = 'mini-button mini-button--dark';
  benefitsBtn.textContent = 'Benefici gilda';
  benefitsBtn.onclick = () => renderActiveBonuses('missions');
  benefitsWrap.appendChild(benefitsBtn);
  list.appendChild(benefitsWrap);
  // --- fine Pulsante Benefici ---

// --- Pulsante Bonus personali (solo se almeno un bonus attivo) ---
if (typeof hasAnyPersonalBonusActive==='function' && hasAnyPersonalBonusActive()){
  const personalBtn = document.createElement('button');
  personalBtn.className = 'mini-button mini-button--dark';
  personalBtn.textContent = 'Bonus personali';
  personalBtn.onclick = ()=> renderPersonalBonuses('missions');
  benefitsWrap.appendChild(personalBtn);
}
// --- fine Pulsante Bonus personali ---


  // --- Ultimo risultato missione (toggle) ---
  const last = userStore.get('lastMissionResult');
  if (last) {
    const wrap = document.createElement('div');
    wrap.style.margin = '10px 0 16px';

    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'magic-button';
    toggleBtn.textContent = 'Mostra/Nascondi ultimo risultato';

    const detail = document.createElement('div');
    detail.style.display = 'none';
    detail.style.marginTop = '8px';
    detail.style.padding = '10px';
    detail.style.border = '2px solid #6b4226';
    detail.style.borderRadius = '8px';
    detail.style.background = '#fff8dc';

    const mName = (missions.find(mm => mm.id === last.missionId)?.name) || 'Missione';
    const creatureLine = (last.creatureName && (last.creatureXpGained || last.creatureXpGained === 0))
      ? `<div><strong>Esperienza creatura:</strong> ${last.creatureName} +${last.creatureXpGained} XP</div>`
      : '';

    detail.innerHTML = `
      <div><strong>Missione:</strong> ${mName}</div>
      <div><strong>Completata:</strong> ${fmtDateTime(last.when)}</div>
      <div><strong>Ricompensa:</strong> ${formatGold(last.rewardGold)} oro, ${last.rewardXp} XP, ${last.rewardAP || 0} PA</div>
      ${creatureLine}
    `;

    toggleBtn.onclick = () => {
      detail.style.display = (detail.style.display === 'none') ? 'block' : 'none';
    };

    wrap.appendChild(toggleBtn);
    wrap.appendChild(detail);
    list.appendChild(wrap);
  }
  // --- fine ultimo risultato ---

  // Box missione attiva
  if (active) {
    activeBox.classList.remove('hidden');
    document.getElementById('mission-active-name').textContent =
      `${active.name} (${active.difficulty}, ${active.duration}m)`;
  } else {
    activeBox.classList.add('hidden');
  }

  // --- Elenco missioni: solo titolo; click -> dettaglio ---
  missions.forEach(m => {
    const row = document.createElement('div');
    row.style.marginBottom = '10px';

    const btn = document.createElement('button');
    btn.className = 'magic-button';

    const rem = getCooldownRemaining(m.id);
    // Solo titolo + info disponibilit√† se in ricarica
    btn.textContent = rem > 0
      ? `${m.name} ‚Äî Disponibile tra: ${formatHM(rem)}`
      : `${m.name}`;

    // Il bottone apre il dettaglio (non avvia direttamente)
    btn.onclick = () => openMissionDetail(m.id);

    row.appendChild(btn);
    list.appendChild(row);
  });
}


function startMission(missionId) {
if (isInGuildMine()) {
  showGameMessage('Azione non permessa', 'Non puoi avviare missioni o sfide mentre stai scavando nella Miniera della Gilda.');
  return;
}
if (!canStartActionWithHp('una Missione')) return;

  // se c'√® gi√† una missione in corso, blocco
  if (getActiveMission()) {
    alert('Hai gi√† una missione in corso!');
    return;
  }

  // missione esiste?
  const m = missions.find(x => x.id === missionId);
  if (!m) return;

  // ‚è≥ controllo cooldown 8h
  const rem = getCooldownRemaining(missionId); // usa gli helper aggiunti
  if (rem > 0) {
    alert(`Questa missione sar√† disponibile tra ${formatHM(rem)}.`);
    return;
  }

  // avvio missione
  const endTime = Date.now() + m.duration * 60 * 1000;

  userStore.set('missionActive', m.id);
  userStore.set('missionEndTime', endTime);
  userStore.set('activeMissionRewards', calcMissionRewards(m.duration, m.difficulty));
  userStore.set('activeMissionId', m.id);
  userStore.set('missionStartTime', Date.now());
  // NEW: lock creatura equipaggiata all‚Äôavvio
  const eqAtStart = (typeof window.getEquippedCreature === 'function' && window.getEquippedCreature()) || null;
  userStore.set('missionCreatureAtStart', eqAtStart);

  renderMissionsUI();
  startMissionTick();
}

function startMissionTick() {
  if (missionTimer) {
    clearInterval(missionTimer);
    missionTimer = null;
  }

  const active = getActiveMission();
  if (!active) return;

  const countdownEl = document.getElementById('mission-countdown');

  const tick = () => {
    const end = parseInt(userStore.get('missionEndTime') || 0, 10);
    const remain = end - Date.now();
    countdownEl.textContent = msToMMSS(remain);
    if (remain <= 0) {
      clearInterval(missionTimer);
      missionTimer = null;
      completeMission();
    }
  };

  tick();
  missionTimer = setInterval(tick, 1000);
}
function resumeMissionIfNeeded() {
  const activeId = userStore.get('missionActive');
  if (!activeId) return;

  const end = parseInt(userStore.get('missionEndTime') || 0, 10);
  if (!end) return;

  // Se la missione √® gi√† scaduta mentre eri fuori, completa subito
  if (Date.now() >= end) {
    completeMission();
    return;
  }

  // Altrimenti, riavvia il countdown
  const box = document.getElementById('mission-active-box');
  if (box) box.classList.remove('hidden');
  startMissionTick();
}

function completeMission() {
  const active = getActiveMission();
  if (!active) {
    renderMissionsUI();
    return;
  }

  const rewards = userStore.get('activeMissionRewards') || { gold: 0, xp: 0 };

// Usa l'istante reale di fine missione (anche se sei rientrato dopo)
const endStored  = Number(userStore.get('missionEndTime') || 0);
const finishedAt = (endStored && endStored <= Date.now()) ? endStored : Date.now();

// --- GOLD con bonus gilda ---
  const baseGold = Number(rewards.gold) || 0;
  const finalGold = (typeof applyGuildGoldBonus === 'function')
    ? applyGuildGoldBonus(baseGold)
    : baseGold;

  // --- XP eroe con bonus gilda ---
  const baseXp = Number(rewards.xp) || 0;
  const finalXp = (typeof applyGuildHeroXpBonus === 'function')
    ? applyGuildHeroXpBonus(baseXp)
    : baseXp;

  // accrediti eroe
  addNum('gold', finalGold);
  gainXP(baseXp);
  addAbilityPoints(rewards.abilityPoints || 0);

  // ‚¨áÔ∏è NEW: progresso quest "Effettua 6 missioni"
  incrementQuest('q_daily_6missions', 1);
  updateQuestsBadge();

// ‚ûï Quest settimanale: "Completa 30 missioni"
if (typeof incrementQuest === 'function') incrementQuest('q_weekly_30missions', 1);
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

  // --- XP creatura equipaggiata all‚Äôavvio (uguale ai Punti Abilit√†) ---
  let creatureXpGained = 0;
  let creatureName = userStore.get('missionCreatureAtStart') || null; 
  if (creatureName) {
    if (typeof ensureCreatureXpMap === 'function') ensureCreatureXpMap();
    const baseGain = Number(rewards.abilityPoints || 0) || 0;
    const bonusFlat = (typeof getGuildCreatureXpBonusFlat === 'function') ? getGuildCreatureXpBonusFlat() : 0;
    const gain = baseGain + bonusFlat;
    if (gain > 0 && typeof addCreatureXp === 'function') {
      addCreatureXp(creatureName, gain);
      creatureXpGained = gain;
    }
  }

  // ---------------------------------------------------------------
  // üé≤ Frammento di cristallo dalle missioni: base 20% + bonus Altare (p = base + (1-base)*bonus)
let crystalPartFound = false;
const pFrag = (typeof getMissionCrystalFragChance === 'function')
  ? getMissionCrystalFragChance()
  : 0.20;
if (Math.random() < pFrag) {
  addNum('crystalParts', 1);
  crystalPartFound = true;

  // ‚ûï Quest giornaliera: "Ottieni un frammento di cristallo di potenziamento"
  if (typeof incrementQuest === 'function') incrementQuest('q_daily_get_crystal_part', 1);
  if (typeof renderQuestsUI === 'function') renderQuestsUI();
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

  // --- SALUTE: perdita in base a difficolt√† e livello ---
  try {
    ensureHeroStats(); // inizializza anche l'HP se manca
    const heroLevel = getNum('level', 1);
    const diff = (active.difficulty || 'facile');
    const hpLoss = getMissionHealthLoss(diff, heroLevel);
    if (hpLoss > 0) changeHeroHp(-hpLoss);
  } catch (e) {}


  // riepilogo missione
  const finishedId = userStore.get('activeMissionId') || active.id;
  userStore.set('lastMissionResult', {
    when: finishedAt,
    rewardGold: finalGold,
    rewardXp: finalXp,   // üëà salva l‚ÄôXP reale con bonus
    rewardAP: rewards.abilityPoints || 0,
    missionId: finishedId,
    creatureName: creatureName,
    creatureXpGained: creatureXpGained
  });

  // ‚è≥ cooldown base ridotto dalla Biblioteca del Sapere
const effCd = (typeof getEffectiveMissionCooldownMs === 'function')
  ? getEffectiveMissionCooldownMs()
  : MISSION_COOLDOWN_MS;
setMissionCooldown(finishedId, finishedAt + effCd);

  // Messaggio "Report Missione"
  const missionName = (missions.find(mm => mm.id === finishedId)?.name) || 'Missione';
  const body = [
    `Complimenti, hai terminato la missione.`,
    ``,
    `${missionName}`,
    ``,
    `Oro guadagnato: ${formatGold(finalGold)}`,   // numero corretto
    `Esperienza guadagnata: ${finalXp} XP`,       // numero corretto
    `Punti abilit√† guadagnati: ${rewards.abilityPoints || 0}`,
    `Esperienza creatura guadagnata: ${creatureXpGained} XP`,
    ``,
    ...(crystalPartFound ? [
      `<span style="color:#b00000; font-weight:bold;">COMPLIMENTI, HAI TROVATO 1/3 DEL CRISTALLO DI POTENZIAMENTO!</span>`
    ] : []),
    ``,
    fmtDateTime(finishedAt)
  ].join('\n');

  addMessage({
    id: `msg_${finishedAt}`,
    title: 'Report Missione',
    body,
    when: finishedAt,
    unread: true
  });

  // pulizia stato missione
  userStore.remove('missionActive');
  userStore.remove('missionEndTime');
  userStore.remove('activeMissionRewards');
  userStore.remove('activeMissionId');
  userStore.remove('missionStartTime');
  userStore.remove('missionCreatureAtStart');

  // UI profilo se aperto
  const goldEl = document.getElementById('hero-gold');
  if (goldEl) {
    const gold = getNum('gold', 0);
    goldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;
  }
  updateHeroLevelUI();

  renderMissionsUI();
}


function calcMissionRewards(minutes, difficulty) {
  // base per durata
  const baseByMinutes = {
    5:  { gold: 40,  xp: 20 },
    15: { gold: 120, xp: 40 },
    30: { gold: 250, xp: 60 },
    60: { gold: 520, xp: 90 }
  };

  // Punti Abilit√† per durata (richiesta): 6s=1, 5m=2, 15m=4, 30m=6, 60m=10
  // NB: la missione veloce √® 0.1 minuti (~6s)
  function apFor(minutes) {
    if (minutes < 1) return 1; // copre 0.1m
    if (minutes === 5) return 1;
    if (minutes === 15) return 1;
    if (minutes === 30) return 2;
    if (minutes === 60) return 3;
    return 0;
  }

  // moltiplicatori difficolt√† (oro/xp)
  const multByDiff = {
    'facile':      1.0,
    'intermedia':  1.2,
    'difficile':   1.6,
    'estrema':     1.8
  };

  const base = baseByMinutes[minutes] || { gold: 0, xp: 0 };
  const m = multByDiff[difficulty] || 1;

  return {
    gold: Math.round(base.gold * m),
    xp:   Math.round(base.xp * m),
    abilityPoints: apFor(minutes) // non scala con la difficolt√†
  };
}

// Quanta XP serve per passare dal livello N a N+1
function xpNeededFor(level) {
  const n = Number(level) || 1;
  return 100 + 300 * (n - 1);
}

// XP totale cumulativa dell'eroe
// XP totale cumulativa dell'eroe
function getHeroTotalXp() {
  // Ricostruiamo sempre dalla progressione livelli + xpProgress
  ensureHeroStats();
  const level  = getNum('level', 1);
  const xpProg = getNum('xpProgress', 0);

  let total = xpProg;
  for (let n = 1; n < level; n++) {
    total += xpNeededFor(n);
  }

  // opzionale: teniamo allineata anche la chiave xpTotal nello storage
  setNum('xpTotal', total);

  return total;
}

// Inizializza chiavi se mancano
function ensureHeroStats() {
  let level = getNum('level', 0);
  if (!level) {
    setNum('level', 1);
  }
  let xpProg = getNum('xpProgress', -1);
  if (xpProg < 0) {
    setNum('xpProgress', 0);
  }

  // --- Salute: inizializzazione se mancante ---
  let hpMax = getNum('heroHpMax', 0);
  if (!hpMax) setNum('heroHpMax', 100);          // max di base
  let hp = getNum('heroHp', -1);
  if (hp < 0) setNum('heroHp', getNum('heroHpMax', 100)); // piena alla prima volta
}
// === SALUTE EROE: helper ===
function getHeroHpMax() {
  ensureHeroStats();
  return Number(getNum('heroHpMax', 100)) || 100;
}
function getHeroHp() {
  ensureHeroStats();
  return Number(getNum('heroHp', getHeroHpMax()));
}
function setHeroHp(v) {
  const max = getHeroHpMax();
  const nv = Math.max(0, Math.min(max, Number(v) || 0));
  setNum('heroHp', Number(nv.toFixed(1))); // una cifra decimale (es. 0,5 / 0,2)
  updateHeroHealthUI();
}
function changeHeroHp(delta) {
  setHeroHp(getHeroHp() + Number(delta || 0));
}

function canStartActionWithHp(actionLabel) {
  const hpNow = (typeof getHeroHp === 'function') ? Number(getHeroHp() || 0) : 0;
  if (hpNow > 0) return true;

  if (typeof showGameMessage === 'function') {
    showGameMessage(
      '‚ò† Eroe sfinito',
      `Non puoi avviare <strong>${actionLabel}</strong> con <strong>0</strong> salute.<br>` +
      `Bevi una <strong>pozione</strong> per recuperare almeno 1 salute.`
    );
  }
  return false;
}
window.canStartActionWithHp = canStartActionWithHp;

// UI Salute se presente (non obbligatoria adesso)
function updateHeroHealthUI() {
  const hpEl = document.getElementById('hero-hp');
  const hpMaxEl = document.getElementById('hero-hp-max');
  const bar = document.getElementById('hero-hp-bar');

  const hp = getHeroHp();
  const max = getHeroHpMax();

  // Testo X/Y: niente ",0" se intero
  if (hpEl){
    const s = hp.toFixed(1);
    hpEl.textContent = s.endsWith('.0') ? String(Math.round(hp)) : s.replace('.', ',');
  }
  if (hpMaxEl) hpMaxEl.textContent = String(max);

  // Barra: percentuale e colore
  if (bar && max > 0){
    const pct = Math.max(0, Math.min(100, (hp / max) * 100));
    bar.style.width = pct + '%';
    bar.classList.remove('hp-green','hp-yellow','hp-orange','hp-red');
    bar.classList.add(
      pct >= 80 ? 'hp-green' :
      pct >= 50 ? 'hp-yellow' :
      pct >= 20 ? 'hp-orange' : 'hp-red'
    );
  }
 // üîÑ Aggiorno anche la Potenza eroe
  if (typeof updateHeroPowerUI === 'function') {
    updateHeroPowerUI();
  }
}

// --- Calcolo Potenza Eroe -----------------------------------------

function computeHeroPower() {
  try { ensureHeroStats(); } catch (_) {}

  // Abilit√†
  const abilities = (typeof getAbilities === 'function') ? (getAbilities() || {}) : {};

  // Legge un'abilit√† e, se √® <= 0, la tratta come 1 solo ai fini del calcolo potenza
  const A = (name) => {
    const raw = Number(abilities[name] ?? 0) || 0;
    return raw <= 0 ? 1 : raw;
  };

  const FORZA           = A('Forza');
  const DESTREZZA       = A('Destrezza');
  const COSTITUZIONE    = A('Costituzione');
  const TECNICA         = A('Tecnica');
  const ARTE_MARZIALE   = A('Arte Marziale');
  const SAGGEZZA        = A('Saggezza');
  const FURTIVITA       = A('Furtivit√†');
  const SCHIVARE        = A('Schivare');
  const MAGIA_AB        = A('Magia');
  const LEGAME_CREATURA = A('Legame Creatura');


  // XP eroe (totale cumulativo)
  const XP_EROE = (typeof getHeroTotalXp === 'function') ? getHeroTotalXp() : Number(getNum('xpTotal', 0)) || 0;

  // ---------------- ARMI (somma destra + sinistra) ----------------
// üëâ Ogni arma contribuisce separatamente, poi sommiamo i contributi
let termArmi = 0;

const rightName = userStore.get('rightHand') || null;
const leftName  = userStore.get('leftHand') || null;

const allWeapons = (typeof getAllDefs === 'function')
  ? getAllDefs('weapons')
  : (Array.isArray(window.weaponItems) ? weaponItems : []);

// Bonus percentuale per effetto extra inciso
const EXTRA_EFFECT_MULT = 0.05; // +5%

function addWeaponContribution(name) {
  if (!name) return;
  const weapon = allWeapons.find(w => w && w.name === name);
  if (!weapon) return;

  const tr = weapon.traits || {};
  let danno      = Number(tr.Danno) || 0;
  let velocita   = Number(tr.Velocit√†) || 0;
  let distUso    = Number(tr["Distanza d'uso"] ?? tr["Distanza d‚Äôuso"] ?? 0);
  let velocitaUR = tr["Velocit√† uso e riuso"];
  let peso       = Number(tr.Peso) || 0;

  // Bonus da cristalli
  const upMap = userStore.get('weaponUp') || {};
  const up    = upMap[name] || {};
  danno    += Number(up.Danno)    || 0;
  velocita += Number(up.Velocit√†) || 0;

  const velUsoRiuso = (velocitaUR == null ? 0 : Number(velocitaUR) || 0);
  const dist        = distUso || 1;
  const pesoEff     = Math.max(1, peso || 1);

  // Blocco formula arma singola:
  // ((FORZA * Danno) * (DESTREZZA * VelUsoRiuso) + (ARTE_MARZIALE * Velocit√†) / (TECNICA * Distanza)) / Peso
  const inner1 = (FORZA * danno) * (DESTREZZA * velUsoRiuso);
  const denom2 = Math.max(1, TECNICA * dist);
  const inner2 = denom2 !== 0 ? (ARTE_MARZIALE * velocita) / denom2 : 0;
  let contrib  = (inner1 + inner2) / pesoEff;

  // üî• Effetto extra inciso? Applica +5% alla potenza di QUEST'arma
  const extraMap = userStore.get('weaponExtraChosen') || {};
  const engraved = userStore.get(`weaponExtraEffect_${name}`) || extraMap[name] || null;
  const hasExtra = !!engraved;

  if (hasExtra) {
    contrib = contrib * (1 + EXTRA_EFFECT_MULT);
  }

  termArmi += contrib;
}

addWeaponContribution(rightName);
addWeaponContribution(leftName);



  // ---------------- ARMATURA ----------------
  let aDif = 0, aRes = 0, aAgi = 0, aPeso = 0;

  const armorName = (typeof getEquippedArmor === 'function')
    ? getEquippedArmor()
    : (userStore.get('equippedArmor') || null);

  if (armorName) {
    const allArmors = (typeof getAllDefs === 'function') ? getAllDefs('armors') : [];
    const armor = allArmors.find(a => a && a.name === armorName);
    if (armor) {
      const tr = armor.traits || {};
      aDif  = Number(tr.Difesa)     || 0;
      aRes  = Number(tr.Resistenza) || 0;
      aAgi  = Number(tr.Agilit√†)    || 0;
      aPeso = Number(tr.Peso)       || 0;

      const upMap = userStore.get('armorUp') || {};
      const up    = upMap[armorName] || {};
      aDif += Number(up.Difesa)     || 0;
      aRes += Number(up.Resistenza) || 0;
    }
  }

  let termArmatura = 0;
  if (aDif || aRes || aAgi) {
    const pesoArm = Math.max(1, aPeso || 1);
    termArmatura =
  (((COSTITUZIONE * aDif) * (FURTIVITA * aAgi)) / pesoArm +
    (SCHIVARE * aRes));
  }

  // ---------------- MAGIA ----------------
  let mDanno = 0, mVel = 0;

  const magicName =
    userStore.get('equippedMagic') ||
    userStore.get('magic') ||
    null;

  if (magicName) {
    const allMagics = (typeof getAllDefs === 'function')
      ? getAllDefs('magics')
      : (Array.isArray(window.magicItems) ? magicItems : []);

    const magic = allMagics.find(m => m && m.name === magicName);
    if (magic) {
      const tr = magic.traits || {};
      mDanno = Number(tr.Danno) || 0;
      mVel   = Number(tr.Velocit√†) || 0;

      const upMap = userStore.get('magicUp') || {};
      const up    = upMap[magic.name] || { Danno: 0, Velocit√†: 0 };
      mDanno += Number(up.Danno)    || 0;
      mVel   += Number(up.Velocit√†) || 0;
    }
  }

  let termMagia = 0;
  if (mDanno || mVel) {
    termMagia = ((SAGGEZZA * mVel) + (MAGIA_AB * mDanno));
  }

  // ---------------- CREATURA ----------------
  let cForza = 0, cAgg = 0, cAgi = 0, cAst = 0, cDim = 0, XP_CREA = 0;

  const creatureName = (typeof getEquippedCreature === 'function')
    ? getEquippedCreature()
    : (userStore.get('equippedCreature') || null);

  if (creatureName) {
    if (typeof getCreatureTraits === 'function') {
      const tr = getCreatureTraits(creatureName) || {};
      cForza = Number(tr.Forza) || 0;
      cAgg   = Number(tr.Aggressivit√† ?? tr["Aggressivita'"] ?? 0) || 0;
      cAgi   = Number(tr.Agilit√†) || 0;
      cAst   = Number(tr.Astuzia) || 0;
      cDim   = Number(tr.Dimensioni) || 0;
    }
    if (typeof getCreatureXp === 'function') {
      XP_CREA = Number(getCreatureXp(creatureName) || 0);
    }
  }

  let termCreatura = 0;
  if (cForza || cAgg || cAgi || cAst) {
    const denomC = Math.max(1, cDim || 1);
    const interno =
      ((cForza * cAgg) + (cAgi + cAst)) / denomC;
    termCreatura =
      (LEGAME_CREATURA * interno) + XP_CREA;
  }

  // Somma di tutto
  const sommaBlocchi =
  termArmi +
  termArmatura +
  termMagia +
  termCreatura;

const hp = getHeroHp();
const fattore = hp / 100;

// Formula finale: XP totale eroe + (blocchi √ó salute/100)
const potenza = XP_EROE + (sommaBlocchi * fattore);

  if (!Number.isFinite(potenza) || potenza < 0) return 0;
  return Math.round(potenza);
}

// Aggiorna la UI della Potenza eroe
function updateHeroPowerUI() {
  const el = document.getElementById('hero-power');
  if (!el) return;
  const p = computeHeroPower();
  el.textContent = Number(p || 0).toLocaleString('it-IT');
}

// Perdita Salute per missione in base a difficolt√† e livello
function getMissionHealthLoss(diff, level) {
  const L = Number(level) || 1;
  const d = String(diff || 'facile').toLowerCase();

  if (d === 'facile') {
    if (L <= 5)  return 1.0;
    if (L <= 10) return 0.5;
    return 0.2; // >=11
  }
  if (d === 'intermedia') {
    if (L <= 5)  return 1.5;
    if (L <= 10) return 1.0;
    return 0.5; // >=11
  }
  if (d === 'difficile') {
    if (L <= 5)  return 2.5;
    if (L <= 10) return 2.0;
    if (L <= 15) return 1.5;
    return 1.0; // >=16
  }
  if (d === 'estrema') {
    if (L <= 5)  return 3.0;
    if (L <= 10) return 2.5;
    if (L <= 15) return 2.0;
    if (L <= 20) return 1.5;
    return 1.0; // >=21
  }
  return 0;
}

// Aggiunge XP, applica il bonus gilda, gestisce il level-up, salva e aggiorna la UI
function gainXP(amount) {
  ensureHeroStats();

  // Applica il bonus gilda (se la funzione esiste); fallback: valore numerico puro
  const eff = (typeof applyGuildHeroXpBonus === 'function')
    ? applyGuildHeroXpBonus(amount)
    : (Number(amount) || 0);

  let level  = getNum('level', 1);
  const prev = level;                 // ‚Üê salva il livello iniziale
  let xpProg = getNum('xpProgress', 0);

  xpProg += eff;

  while (xpProg >= xpNeededFor(level)) {
    xpProg -= xpNeededFor(level);
    level += 1;
  }

  setNum('level', level);
  setNum('xpProgress', xpProg);

  // ‚úÖ QUEST settimanale: salire di N livelli (N pu√≤ essere >1 se fai salti multipli)
  const gained = level - prev;
  if (gained > 0) {
    if (typeof incrementQuest === 'function') incrementQuest('q_weekly_level_up', gained);
    if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
  }

  // Totale cumulato: registra l'XP effettiva (post-bonus), non l'input grezzo
  addNum('xpTotal', eff);

  updateHeroLevelUI();
  // ‚¨áÔ∏è aggiorna subito la Sala degli Eroi (livello visibile cross-tab)
  try {
    if (typeof upsertCurrentHeroIntoDirectory === 'function') {
      upsertCurrentHeroIntoDirectory();
    }
  } catch (_) {}
}



// Aggiorna gli span del profilo (livello, XP corrente, XP necessaria, XP totale)
function updateHeroLevelUI() {
  const lvlEl   = document.getElementById('hero-level');
  const xpEl    = document.getElementById('hero-xp');
  const needEl  = document.getElementById('hero-xp-needed');
  const totalEl = document.getElementById('hero-xp-total');  // campo XP totale
  if (!lvlEl || !xpEl || !needEl) return;

  ensureHeroStats();
  const level  = getNum('level', 1);
  const xpProg = getNum('xpProgress', 0);
  const need   = xpNeededFor(level);

  // üî¢ XP totale = somma XP di tutti i livelli precedenti + XP nel livello attuale
  let xpTotal = xpProg;
  for (let n = 1; n < level; n++) {
    xpTotal += xpNeededFor(n);
  }

  lvlEl.textContent  = String(level);
  xpEl.textContent   = xpProg.toLocaleString('it-IT');
  needEl.textContent = need.toLocaleString('it-IT');

  if (totalEl) {
    totalEl.textContent = xpTotal.toLocaleString('it-IT');
  }
}

function showMagicShop() {
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('magic-shop').classList.remove('hidden');

  const gold = getNum('gold', 0);
  document.getElementById('magic-shop-gold').textContent = formatGold(gold);

  const list = document.getElementById('magic-buttons-list');
  list.innerHTML = '';

  const ownedList = userStore.get('magics') || [];

  magicItems.forEach(magic => {
    const btn = document.createElement('button');
    btn.className = 'magic-button';

    const owned = ownedList.includes(magic.name);
    btn.textContent = owned ? `${magic.name} (gi√† posseduta)` : magic.name;

    // apre il popup dettagli
    btn.onclick = () => showMagicDetails(magic);
    list.appendChild(btn);
  });

  // non usiamo pi√π il vecchio #magic-details
  const oldBox = document.getElementById('magic-details');
  if (oldBox) oldBox.classList.add('hidden');
}

function showMagicDetails(magic, fromInventory = false) {
  ensureMagicModal();

  const overlay = document.getElementById('magic-overlay');
  const modal   = document.getElementById('magic-detail');
  const titleEl = document.getElementById('magic-detail-title');
  const bodyEl  = document.getElementById('magic-detail-body');
  const buyBtn  = document.getElementById('magic-detail-buy');

  if (!overlay || !modal || !titleEl || !bodyEl || !buyBtn) {
    console.error('Popup magie: elementi mancanti.');
    return;
  }

  const ownedMagics = userStore.get('magics') || [];
  const owned = ownedMagics.includes(magic.name);

  // Titolo
  titleEl.textContent = magic.name;

  // Descrizione (fallback: mappa legacy -> campo desc nell'item -> stringa vuota)
  const descMap = (typeof magicDescriptions === 'object' && magicDescriptions) ? magicDescriptions : {};
  const desc = descMap[magic.name] || magic.desc || '';

  // Caratteristiche base
  const tr = magic.traits || {};
  const T = {
    Danno: Number(tr.Danno) || 0,
    Velocit√†: Number(tr.Velocit√†) || 0
  };

const rawRarity  = (magic.rarity ?? '').toString().trim().toLowerCase();
const rarity     = rawRarity || 'comune';
const rarityLabel= rarity.charAt(0).toUpperCase() + rarity.slice(1);
const rarityClass= `rarity rarity--${rarity}`;

  // --- BONUS da cristalli ---
  const upMap = userStore.get('magicUp') || {};
  const up = upMap[magic.name] || { Danno: 0, Velocit√†: 0 };
  const bDanno = Number(up.Danno) || 0;
  const bVel   = Number(up.Velocit√†) || 0;

  const traitsHtml = `
  <div class="traits-block">
    <div class="title">Caratteristiche</div>
    <div class="traits-grid">
      <div>Rarit√†: <strong class="${rarityClass}">${rarityLabel}</strong></div>
      <div>${formatStatWithBonus('Danno', T.Danno, bDanno)}</div>
      <div>${formatStatWithBonus('Velocit√†', T.Velocit√†, bVel)}</div>
    </div>
  </div>
`;

  // Prezzo (mostrato solo in bottega)
const safePrice = Number(magic.price || magic.cost || 0);
const priceRow = fromInventory
  ? ''
  : `<p><strong>Prezzo:</strong> ${formatGold(safePrice)} monete d'oro</p>`;

// üëá QUI VA BENISSIMO (subito dopo il prezzo)
const imgSrc = getMagicImageSrc(magic.name);
const baseForAlt = (typeof baseNameFromVariant === 'function')
  ? baseNameFromVariant(magic.name)
  : magic.name;

// Corpo popup (con immagine in alto)
bodyEl.innerHTML = `
  <img class="weapon-thumb"
       src="${imgSrc}"
       alt="${baseForAlt}"
       onerror="this.onerror=null;">

  <p>${desc}</p>
  ${traitsHtml}
  ${priceRow}
  <p><strong>Possiedi:</strong> ${owned ? 'S√¨' : 'No'}</p>
`;


  if (fromInventory) {
    // Inventario: niente acquisto, mostra Equipaggia
    buyBtn.style.display = 'none';
    buyBtn.onclick = null;

    const equipBtn = document.createElement('button');
    equipBtn.className = 'magic-button';
    equipBtn.textContent = 'Equipaggia';
    if (!owned) equipBtn.disabled = true;

    equipBtn.onclick = () => {
      userStore.set('magic', magic.name);
      if (typeof updateMagicDisplay === 'function') {
        updateMagicDisplay(magic.name);
      }
      if (typeof showGameMessage === 'function') {
        showGameMessage('Equipaggiata', `Hai equipaggiato la magia <strong>${magic.name}</strong>.`);
      }
      if (typeof closeMagicDetail === 'function') closeMagicDetail();
    };

    bodyEl.appendChild(document.createElement('hr'));
    bodyEl.appendChild(equipBtn);

// --- Converti in Polvere (solo rarit√† NON comune, e solo se posseduta) ---
    const dustPerRarity = (typeof DUST_BY_RARITY !== 'undefined') ? (DUST_BY_RARITY[rawRarity] || DUST_BY_RARITY[rarity] || 0) : 0;
    if (owned && dustPerRarity > 0) {
      const dustBtn = document.createElement('button');
      dustBtn.className = 'magic-button';
      dustBtn.textContent = `Converti in Polvere (+${dustPerRarity})`;
      dustBtn.onclick = () => {
        // Conferma non chiudibile cliccando dietro (usa helper aggiunto nello step 1)
        confirmConvertToDust(dustPerRarity, () => {
          // Rimuovi la magia dall'inventario (esiste 1 sola copia)
          const list = userStore.get('magics') || [];
          const idx = list.indexOf(magic.name);
          if (idx >= 0) {
            list.splice(idx, 1);
            userStore.set('magics', list);
          }

          // Se era equipaggiata, disequipaggia e aggiorna UI
          if (userStore.get('magic') === magic.name) {
            userStore.remove('magic');
            if (typeof updateMagicDisplay === 'function') updateMagicDisplay('Nessuna');
          }

          // Accredita polvere e aggiorna badge in Bottega Arcana + Sala Forzieri
          if (typeof addArcaneDust === 'function') addArcaneDust(dustPerRarity);
          if (typeof updateDustBadges === 'function') updateDustBadges();

          // Refresh lista inventario magie (mantiene la pagina corrente se usi _invPage)
          if (window._invPage && _invPage.magics) {
            populateStorage('magic-list', 'magics', _invPage.magics);
          }

          if (typeof closeMagicDetail === 'function') closeMagicDetail();
          if (typeof showGameMessage === 'function') {
            showGameMessage('Conversione riuscita', `Hai ottenuto <strong>${dustPerRarity}</strong> unit√† di Polvere Arcana.`);
          }
        });
      };
      bodyEl.appendChild(document.createElement('div')).style.height = '8px';
      bodyEl.appendChild(dustBtn);
    }
// --- Vendi (SOLO se magia comune) ---
    if (rarity === 'comune' && owned) {
      const sellPrice = Math.ceil((safePrice * 2) / 3);
      if (sellPrice > 0) {
        const sellBtn = document.createElement('button');
        sellBtn.className = 'magic-button';
        sellBtn.textContent = `Vendi (+${formatGold(sellPrice)} oro)`;
        sellBtn.onclick = function () {
          confirmSellItem(sellPrice, function () {
            // Rimuovi dall'inventario
            const list = userStore.get('magics') || [];
            const i = list.indexOf(magic.name);
            if (i >= 0) { list.splice(i, 1); userStore.set('magics', list); }
            // Se equipaggiata, disequipaggia
            if (userStore.get('magic') === magic.name) {
              userStore.remove('magic');
              if (typeof updateMagicDisplay === 'function') updateMagicDisplay('Nessuna');
            }
            // Accredita oro
            if (typeof addNum === 'function') addNum('gold', sellPrice);
            if (typeof updateGoldBadges === 'function') updateGoldBadges();

if (typeof incrementQuest === 'function') incrementQuest('q_daily_sell_item_shop', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

            if (window._invPage && _invPage.magics) populateStorage('magic-list', 'magics', _invPage.magics);

            if (typeof closeMagicDetail === 'function') closeMagicDetail();
            if (typeof showGameMessage === 'function') showGameMessage('Vendita riuscita', `Hai ottenuto <strong>${formatGold(sellPrice)}</strong> monete d'oro.`);
          });
        };
        bodyEl.appendChild(document.createElement('div')).style.height = '8px';
        bodyEl.appendChild(sellBtn);
      }
    }
  } else {
    // Bottega: acquisto
    buyBtn.style.display = 'inline-block';
    if (owned) {
      buyBtn.disabled = true;
      buyBtn.textContent = 'Gi√† posseduta';
      buyBtn.onclick = null;
    } else {
      buyBtn.disabled = false;
      buyBtn.textContent = 'Acquista';
      buyBtn.onclick = () => {
        const gold = getNum('gold', 0);
        if (gold < safePrice) { alert('Oro insufficiente.'); return; }
        addNum('gold', -safePrice);
        if (!owned) {
          ownedMagics.push(magic.name);
          userStore.set('magics', ownedMagics);
        }

        // Aggiorna oro (shop + profilo, se presenti)
        const g = getNum('gold', 0);
        const shopGold = document.getElementById('magic-shop-gold');
        if (shopGold) shopGold.textContent = formatGold(g);
        const heroGoldEl = document.getElementById('hero-gold');
        if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;

        if (typeof showGameMessage === 'function') {
          showGameMessage('Acquisto effettuato', `Hai acquistato <strong>${magic.name}</strong>.`);
if (typeof incrementQuest === 'function') incrementQuest('q_daily_classic_shop_buy_equipment', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

        }
        if (typeof closeMagicDetail === 'function') closeMagicDetail();
        if (typeof showMagicShop === 'function') showMagicShop();
      };
    }
  }

    lockBodyScroll();
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');

applyRarityDecor(modal, titleEl, rarity);
// Se viene dall‚Äôinventario, ancora al titolo dell‚Äôinventario magie; altrimenti al titolo della bottega magie
positionModalBelowSectionTitle(modal, fromInventory ? '#magic-storage' : '#magic-shop', 16);

}
function showPotionShop() {
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('potion-shop').classList.remove('hidden');
  const gold = getNum('gold', 0);
  document.getElementById('potion-shop-gold').textContent = formatGold(gold);
  renderPotionShop();
}
function goBackFromPotionShop() {
  if (typeof closePotionDetail === 'function') closePotionDetail(); // chiudi eventuale popup
  document.getElementById('potion-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function renderPotionShop(){
  const box = document.getElementById('potion-buttons-list');
  if (!box) return;
  box.innerHTML = '';
  const cat = (window.potionCatalog || []);
  cat.forEach(p => {
    const btn = document.createElement('button');
    btn.className = 'magic-button';
    btn.style.margin = '4px 0';
    btn.textContent = p.name;
    btn.onclick = () => openPotionDetail(p.id, false);
    box.appendChild(btn);
  });
}
function ensurePotionModal(){
  let overlay = document.getElementById('potion-overlay');
  let modal   = document.getElementById('potion-detail');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'potion-overlay';
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closePotionDetail;
    document.body.appendChild(overlay);
  }
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'potion-detail';
    modal.className = 'hidden modal-common';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');
    modal.innerHTML = `
      <h3 id="potion-detail-title">Dettaglio Pozione</h3>
      <div id="potion-detail-body" class="scroll-area"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="potion-detail-primary" class="magic-button">Acquista</button>
        <button class="magic-button" onclick="closePotionDetail()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
}
function closePotionDetail(){
  document.getElementById('potion-overlay')?.classList.add('hidden');
  document.getElementById('potion-detail')?.classList.add('hidden');
}

// openPotionDetail(id, fromInventory: boolean)
function openPotionDetail(potionId, fromInventory){
  ensurePotionModal();
  const cat = (window.potionCatalog||[]);
  const p = cat.find(x => x.id === potionId);
  if (!p) return;

  const ov   = document.getElementById('potion-overlay');
  const md   = document.getElementById('potion-detail');
  const ttl  = document.getElementById('potion-detail-title');
  const body = document.getElementById('potion-detail-body');
  const prim = document.getElementById('potion-detail-primary');

  ttl.textContent = p.name;
  const owned = getPotionCount(p.id);
  const sellPrice = window.potionSellPrice ? window.potionSellPrice(p.price) : Math.ceil((Number(p.price)||0)*2/3);
const imgSrc = getPotionImageSrc(p.name);
const baseForAlt = p.name;

  body.innerHTML = `
  <img class="weapon-thumb"
       src="${imgSrc}"
       alt="${baseForAlt}"
       onerror="this.onerror=null; this.src='potions/${encodeURIComponent(baseForAlt)}.jpg';">
  <p>${p.desc}</p>
  <p><strong>Ripristina:</strong> ${p.heal} salute</p>
  ${fromInventory ? '' : `<p><strong>Prezzo:</strong> ${formatGold(p.price)} monete d'oro</p>`}
  ${fromInventory ? `<p><strong>Possiedi:</strong> ${owned}</p>` : ''}
`;


  // Footer dinamico
  const actions = md.querySelector('.modal-actions');
  actions.innerHTML = fromInventory
    ? `
      <button id="potion-btn-drink" class="magic-button">Bevi</button>
      <button id="potion-btn-sell" class="magic-button">Vendi (+${formatGold(sellPrice)} oro)</button>
      <button class="magic-button" onclick="closePotionDetail()">Chiudi</button>
    `
    : `
      <button id="potion-btn-buy" class="magic-button">Acquista</button>
      <button class="magic-button" onclick="closePotionDetail()">Chiudi</button>
    `;

  if (fromInventory) {
    const drink = document.getElementById('potion-btn-drink');
    const sell  = document.getElementById('potion-btn-sell');
    drink.disabled = owned <= 0;

    drink.onclick = () => {
  if (!spendPotion(p.id, 1)) return;

  // ‚ûï Quest giornaliera: "Bevi una Pozione Salute Media"
  if (p && p.id === 'pot_medium' && typeof incrementQuest === 'function') {
    incrementQuest('q_daily_drink_medium_health_potion', 1);
    if (typeof renderQuestsUI === 'function') renderQuestsUI();
    if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
  }

  // ripristina salute
  const hpNow = getHeroHp();
  const hpMax = getHeroHpMax();
  setHeroHp(Math.min(hpMax, hpNow + Number(p.heal||0)));

  // aggiorna lista inventario pozioni
  populateStorage('potion-list','potions', window._invPage.potions||1);

  closePotionDetail();
  showGameMessage?.('Glup!', `Hai bevuto <strong>${p.name}</strong> e recuperato <strong>${p.heal}</strong> salute.`);
};


    sell.onclick = () => {
      if (getPotionCount(p.id) <= 0) return;
      confirmSellItem(sellPrice, () => {
        // riduci 1 pozione e dai oro
        if (spendPotion(p.id, 1)) {
          addNum('gold', sellPrice);
          updateGoldBadges?.();

if (typeof incrementQuest === 'function') incrementQuest('q_daily_sell_item_shop', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

          // refresh inventario pozioni
          populateStorage('potion-list','potions', window._invPage.potions||1);

          closePotionDetail();
          showGameMessage?.('Vendita riuscita', `Hai ottenuto <strong>${formatGold(sellPrice)}</strong> monete d'oro.`);
        }
      });
    };
  } else {
    const buy = document.getElementById('potion-btn-buy');
    buy.onclick = () => {
      let gold = getNum('gold', 0);
      if (gold < p.price) {
        showGameMessage?.('Oro insufficiente', 'Non hai abbastanza oro per acquistare questa pozione.');
        return;
      }
      addNum('gold', -p.price);
      addPotion(p.id, 1);
      updateGoldBadges?.();
      const gEl = document.getElementById('potion-shop-gold');
      if (gEl) gEl.textContent = formatGold(getNum('gold',0));
      closePotionDetail();
      showGameMessage?.('Acquisto riuscito', `Hai acquistato <strong>${p.name}</strong>.`);
      // aggiorna lista shop (non necessario qui, ma innocuo)
      renderPotionShop();
    };
  }

  ov.classList.remove('hidden');
  md.classList.remove('hidden');

  // ancoraggio come gli altri popup (sotto H2 della sezione corrente)
  const sec = fromInventory ? '#potion-storage' : '#potion-shop';
  if (typeof positionModalBelowSectionTitle === 'function') {
    positionModalBelowSectionTitle(md, sec, 16);
  }
}
function showPotionStorage(){
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('potion-storage').classList.remove('hidden');
  _invPage.potions = 1;
  populateStorage('potion-list', 'potions', 1);
}

function goBackFromMagicShop() {
  document.getElementById('magic-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function buyMagic(name, price) {
  const magics = userStore.get('magics') || [];
  if (magics.includes(name)) {
    closeMagicDetail();
    showMagicShop();
    return;
  }

  let gold = getNum('gold', 0);
  if (gold < price) {
    showGameMessage("Oro insufficiente", "Non hai abbastanza oro per acquistare questa magia.");
    return;
  }

  gold -= price;
  setNum('gold', gold);
  magics.push(name);
  userStore.set('magics', magics);

  // aggiorna UI oro
  document.getElementById('magic-shop-gold').textContent = formatGold(gold);
  document.getElementById('hero-gold').innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  closeMagicDetail();
  showMagicShop();
  showGameMessage("Complimenti!", "L'acquisto √® andato a buon fine!");
if (typeof incrementQuest === 'function') incrementQuest('q_daily_classic_shop_buy_equipment', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

function buyWeapon(name, price) {
  let gold = getNum('gold', 0);
  if (gold < price) {
    showGameMessage("Oro insufficiente", "Non hai abbastanza oro per acquistare quest'arma.");
    return;
  }

  gold -= price;
  setNum('gold', gold);

  const ownedWeapons = userStore.get('weapons') || {};
  ownedWeapons[name] = (ownedWeapons[name] || 0) + 1;
  userStore.set('weapons', ownedWeapons);

  document.getElementById('weapon-shop-gold').textContent = formatGold(gold);
  document.getElementById('hero-gold').innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  closeWeaponDetail();
  showWeaponPage(currentWeaponPage);
  showGameMessage("Complimenti!", "L'acquisto √® andato a buon fine!");
if (typeof incrementQuest === 'function') incrementQuest('q_daily_classic_shop_buy_equipment', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

function showWeaponShop() {
  // mostra la schermata bottega armi
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('weapon-shop').classList.remove('hidden');

  // aggiorna oro
  const gold = getNum('gold', 0);
  document.getElementById('weapon-shop-gold').textContent = formatGold(gold);

  // assicura lista vuota e nasconde l‚Äôeventuale vecchio box inline
  const list = document.getElementById('weapon-buttons-list');
  if (list) list.innerHTML = '';
  document.getElementById('weapon-details')?.classList.add('hidden');

  // üëâ parte SEMPRE dalla pagina 1
  showWeaponPage(1);
}

function showWeaponPage(page) {
  currentWeaponPage = page;   // üîë salviamo la pagina attuale
  const perPage = 8;
  const start = (page - 1) * perPage;
  const items = weaponItems.slice(start, start + perPage);

  const list = document.getElementById('weapon-buttons-list');
  list.innerHTML = '';

  // Quantit√† possedute: { nomeArma: qty }
  const ownedMap = userStore.get('weapons') || {};

  items.forEach(weapon => {
    const btn = document.createElement('button');
    btn.className = 'magic-button';

    const qty = Number(ownedMap[weapon.name] || 0);
    btn.textContent = qty > 0
                 ? `${formatWeaponName(weapon.name)} (${qty})`
                : formatWeaponName(weapon.name);

    btn.onclick = () => showWeaponDetails(weapon);
    list.appendChild(btn);
  });

// üîú Pulsante "Pagina Successiva"
  if (start + perPage < weaponItems.length) {
    const nextBtn = document.createElement('button');
    nextBtn.textContent = 'Pagina Successiva';
    nextBtn.style.marginTop = '10px';
    nextBtn.onclick = () => showWeaponPage(page + 1);
    list.appendChild(nextBtn);
  }
  // üîô Pulsante "Pagina Precedente"
  if (page > 1) {
    const prevBtn = document.createElement('button');
    prevBtn.textContent = 'Pagina Precedente';
    prevBtn.style.marginTop = '10px';
    prevBtn.onclick = () => showWeaponPage(page - 1);
    list.appendChild(prevBtn);
  }

  
}


// === Popup ARMI ===
function ensureWeaponModal() {
  // overlay (backdrop)
  let overlay = document.getElementById('weapon-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'weapon-overlay';
    // se gi√† usi classi comuni per i popup, riutilizziamole:
    // 'overlay-common' √® la stessa che usi per le magie
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closeWeaponDetail; // chiusura cliccando fuori
    document.body.appendChild(overlay);
  }

  // contenitore modale
  let modal = document.getElementById('weapon-detail');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'weapon-detail';
    // idem: 'modal-common' √® la classe gi√† usata dal modal magie
    modal.className = 'hidden modal-common';
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-labelledby', 'weapon-detail-title');

    modal.innerHTML = `
      <h3 id="weapon-detail-title">Arma</h3>
      <div id="weapon-detail-body" class="scroll-area"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="weapon-detail-buy" class="magic-button">Acquista</button>
        <button class="magic-button" onclick="closeWeaponDetail()">Chiudi</button>
      </div>
    `;

    document.body.appendChild(modal);
  }

  // non ritorna nulla: l'importante √® che gli elementi esistano
}

// ==== Cambia Tipo Eroe (modal) ====
const HERO_CHANGE_COST = 10000;

function ensureHeroChangeModal() {
  // overlay
  let overlay = document.getElementById('hero-change-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'hero-change-overlay';
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closeHeroChange;
    document.body.appendChild(overlay);
  }

  // modal
  let modal = document.getElementById('hero-change-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'hero-change-modal';
    modal.className = 'hidden modal-common';
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-labelledby', 'hero-change-title');

    modal.innerHTML = `
  <p id="hero-change-title" class="hero-change-headline">
    Qui forgi la tua identit√†: scegli la stirpe che risuona col tuo destino.
  </p>
  <div id="hero-change-body"></div>
  <div class="modal-actions modal-actions--stack">
    <button id="hero-change-confirm" class="magic-button" disabled>Conferma</button>
    <button class="magic-button" onclick="closeHeroChange()">Chiudi</button>
  </div>
`;
    document.body.appendChild(modal);
  }
}

function closeHeroChange() {
  document.getElementById('hero-change-overlay')?.classList.add('hidden');
  document.getElementById('hero-change-modal')?.classList.add('hidden');
}

// Apre il popup e costruisce i contenuti
function openHeroChange() {
  ensureHeroChangeModal();

  const overlay   = document.getElementById('hero-change-overlay');
  const modal     = document.getElementById('hero-change-modal');
  const body      = document.getElementById('hero-change-body');
  const confirmBtn= document.getElementById('hero-change-confirm');

  if (!overlay || !modal || !body || !confirmBtn) return;

  // Reset bottone ad ogni apertura
  confirmBtn.textContent = 'Conferma';
  confirmBtn.disabled = true;
  confirmBtn.removeAttribute('title');

  const current = String(userStore.get('hero') || '').trim();
  const gold = getNum('gold', 0);

  // Build body (niente "pannello conferma" inline: useremo il vero popup)
  body.innerHTML = `
    <div class="hero-change-meta">
      <span class="gold">Oro disponibile: <strong>${formatGold(gold)}</strong> monete d'oro</span>
    </div>
    <div class="hero-change-meta">
      <span class="cost">Costo: <strong>${formatGold(HERO_CHANGE_COST)}</strong> monete d'oro</span>
    </div>

    <ul id="hero-change-list"></ul>
    <div id="hero-change-description">Seleziona una stirpe per vedere la descrizione.</div>
    <div id="hero-change-status"></div>
  `;

  // Riferimenti
  const list   = body.querySelector('#hero-change-list');
  const desc   = body.querySelector('#hero-change-description');
  const status = body.querySelector('#hero-change-status');

  // Popola lista razze da heroDescriptions
  const types = Object.keys(heroDescriptions || {});
  let selected = current; // preselezione = attuale

  types.forEach((t) => {
    const li = document.createElement('li');
    li.textContent = t;
    li.setAttribute('data-hero', t);
    if (t === selected) li.classList.add('selected');

    li.addEventListener('click', () => {
      // selezione
      list.querySelectorAll('li').forEach(el => el.classList.remove('selected'));
      li.classList.add('selected');
      selected = t;

      // descrizione
      desc.textContent = heroDescriptions[t] || '';

      // stato bottone / oro
      status.innerHTML = '';
      const same = (selected === current);
      confirmBtn.disabled = same;
      if (same) {
        confirmBtn.title = 'Seleziona una stirpe diversa';
      } else {
        confirmBtn.removeAttribute('title');
      }

      const nowGold = getNum('gold', 0);
      if (!same && nowGold < HERO_CHANGE_COST) {
        const diff = HERO_CHANGE_COST - nowGold;
        confirmBtn.disabled = true;
        confirmBtn.title = `Ti servono altri ${formatGold(diff)} oro`;
        status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
      }
    });

    list.appendChild(li);
  });

  // iniziale
  desc.textContent = heroDescriptions[selected] || '';
  const same = (selected === current);
  confirmBtn.disabled = same || (gold < HERO_CHANGE_COST);
  if (same) {
    confirmBtn.title = 'Seleziona una stirpe diversa';
  } else if (gold < HERO_CHANGE_COST) {
    const diff = HERO_CHANGE_COST - gold;
    confirmBtn.title = `Ti servono altri ${formatGold(diff)} oro`;
    status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
  } else {
    confirmBtn.removeAttribute('title');
  }

  // Click su "Conferma" -> vero popup di conferma
  confirmBtn.onclick = () => {
    if (confirmBtn.disabled) return;

    const same = (selected === current);
    const nowGold = getNum('gold', 0);
    if (same) {
      status.innerHTML = `<span class="err">Seleziona una stirpe diversa.</span>`;
      confirmBtn.title = 'Seleziona una stirpe diversa';
      return;
    }
    if (nowGold < HERO_CHANGE_COST) {
      const diff = HERO_CHANGE_COST - nowGold;
      status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
      confirmBtn.title = `Ti servono altri ${formatGold(diff)} oro`;
      return;
    }

    const _hp = heroPluralInfo(selected);
    showConfirmDialog({
      title: 'Conferma cambio stirpe',
      text: `Sei certo di riforgiare il tuo retaggio e abbracciare la stirpe ${_hp.art} ${_hp.plural}? Il rito consumer√† ${formatGold(HERO_CHANGE_COST)} monete d'oro.`,
      okText: 'S√¨, cambia stirpe',
      cancelText: 'Annulla',
      onConfirm: () => {
        // Applica cambiamento
        addNum('gold', -HERO_CHANGE_COST);
        userStore.set('hero', selected);

// üîπ Aggiorna Sala degli Eroi
        upsertCurrentHeroIntoDirectory();

        // Refresh UI profilo
        const newGold = getNum('gold', 0);
        const goldEl = document.getElementById('hero-gold');
        if (goldEl) goldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(newGold)} monete d'oro`;
        const heroTypeEl = document.getElementById('hero-type');
        if (heroTypeEl) heroTypeEl.textContent = selected;

        // Popup finale
        const _hp2 = heroPluralInfo(selected);
        showGameMessage(
          'Destino riforgiato',
          `La tua essenza √® stata plasmata di nuovo: ora appartieni alla stirpe ${_hp2.art} <strong>${_hp2.plural}</strong>.`
        );

        closeHeroChange();
      }
    });
  };

  // Mostra modal
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');
}

let __bodyScrollY = 0;

function lockBodyScroll() {
  __bodyScrollY = window.scrollY || window.pageYOffset || 0;
  document.body.style.position = 'fixed';
  document.body.style.top = `-${__bodyScrollY}px`;
  document.body.style.left = '0';
  document.body.style.right = '0';
  document.body.style.width = '100%';
  document.body.style.overflow = 'hidden';
}

function unlockBodyScroll() {
  document.body.style.position = '';
  document.body.style.top = '';
  document.body.style.left = '';
  document.body.style.right = '';
  document.body.style.width = '';
  document.body.style.overflow = '';
  window.scrollTo(0, __bodyScrollY);
}

function closeWeaponDetail() {
  document.getElementById('weapon-overlay')?.classList.add('hidden');
  document.getElementById('weapon-detail')?.classList.add('hidden');
  unlockBodyScroll();
}


function showWeaponDetails(weapon, fromInventory = false) {
  ensureWeaponModal();

  const overlay = document.getElementById('weapon-overlay');
  const modal   = document.getElementById('weapon-detail');
  const titleEl = document.getElementById('weapon-detail-title');
  const bodyEl  = document.getElementById('weapon-detail-body');
  const buyBtn  = document.getElementById('weapon-detail-buy');

  if (!overlay || !modal || !titleEl || !bodyEl || !buyBtn) {
    console.error('Popup armi: elementi mancanti.');
    return;
  }

  // Quantit√† posseduta (le armi sono "stackabili")
  const ownedObj = userStore.get('weapons') || {};
  const qtyOwned = Number(ownedObj[weapon.name] || 0);

  // Stato attuale mani
  const right = userStore.get('rightHand');
  const left  = userStore.get('leftHand');

  // Quante copie di questa arma sono gi√† usate tra le due mani
  let used = 0;
  if (right === weapon.name) used++;
  if (left  === weapon.name) used++;
  const remaining = Math.max(0, qtyOwned - used);

  // Titolo
  titleEl.textContent = formatWeaponName(weapon.name);

  // Descrizione & prezzo (il prezzo sparisce se arrivo dal deposito)
  const desc = weapon.desc || '';
  const safePrice = Number(weapon.price || 0);
  const priceRow = fromInventory ? '' : `<p><strong>Prezzo:</strong> ${formatGold(safePrice)} monete d'oro</p>`;

  // --- Caratteristiche arma base ---
  const tr = weapon.traits || {};
const T = {
  Danno: Number(tr.Danno) || 0,
  Velocit√†: Number(tr.Velocit√†) || 0,
  "Distanza d'uso": Number(tr["Distanza d'uso"]) || 0,
  "Velocit√† uso e riuso": (tr["Velocit√† uso e riuso"] !== undefined ? Number(tr["Velocit√† uso e riuso"]) : null),
  Peso: Number(tr.Peso) || 0
};

  // --- BONUS da Cristalli (se presenti) ---
  const wUp = userStore.get('weaponUp') || {};
  const up = wUp[weapon.name] || { Danno: 0, Velocit√†: 0 };

  // --- PROGRESSO Effetto Extra (0..20) ---
  const progMap = userStore.get('weaponExtraProgress') || {};
  const extraProgress = Number(progMap[weapon.name] || 0);
  const extraStatus = extraProgress < 20
    ? `(Cristalli di potenziamento attuali: ${extraProgress}/20)`
    : `(Sbloccato!)`;

  const extraRow = fromInventory
    ? `<div>
         <span id="extra-effect-trigger" class="extra-effect-link">
           <strong><u>Effetto Extra</u></strong>
         </span>
         <span class="muted" style="margin-left:6px;">${extraStatus}</span>
       </div>`
    : `<div><strong>Possibilit√† di aggiungere un effetto extra</strong></div>`;

// Rarit√† (con fallback) + classi CSS
const rawRarity  = (weapon.rarity ?? '').toString().trim().toLowerCase();
const rarity     = rawRarity || 'comune';
const rarityLabel= rarity.charAt(0).toUpperCase() + rarity.slice(1);
const rarityClass= `rarity rarity--${rarity}`;

  const traitsHtml = `
  <div class="traits-block">
    <div class="title">Caratteristiche</div>
    <div class="traits-grid">
      <div>Rarit√†: <strong class="${rarityClass}">${rarityLabel}</strong></div>
      <div>${formatStatWithBonus("Danno", T.Danno, up.Danno)}</div>
      <div>${formatStatWithBonus("Velocit√†", T.Velocit√†, up.Velocit√†)}</div>
      <div>Distanza d'uso: <strong>${T["Distanza d'uso"]}</strong></div>
      ${
        (T["Velocit√† uso e riuso"] !== null && !Number.isNaN(T["Velocit√† uso e riuso"]))
          ? `<div>Velocit√† uso e riuso: <strong>${T["Velocit√† uso e riuso"]}</strong></div>`
          : ''
      }
      <div>Peso: <strong>${T.Peso}</strong></div>
      ${extraRow}
    </div>
  </div>
`;
  const imgSrc = getWeaponImageSrc(weapon.name);
  const baseForAlt = (typeof baseNameFromVariant === 'function') ? baseNameFromVariant(weapon.name) : weapon.name;

  // Corpo base
    bodyEl.innerHTML = `
  <img class="weapon-thumb"
       src="${imgSrc}"
       alt="${baseForAlt}"
       onerror="this.onerror=null; this.src='weapons/${encodeURIComponent(baseForAlt)}.jpg';">

  <p>${desc}</p>

  ${traitsHtml}

  ${priceRow}

  <p><strong>Possiedi:</strong> ${qtyOwned}</p>
`;


  // Se l'effetto extra √® gi√† inciso su questa arma, mostrane il nome
  const chosenMap = userStore.get('weaponExtraChosen') || {};
  const chosenExtra = chosenMap[weapon.name] || userStore.get(`weaponExtraEffect_${weapon.name}`);
  if (chosenExtra) {
    const chosenBlock = document.createElement('div');
    chosenBlock.className = 'traits-block';
    chosenBlock.style.marginTop = '8px';
    chosenBlock.innerHTML = `
      <div class="title">Effetto Extra Inciso</div>
      <p><strong>${chosenExtra}</strong></p>
    `;
    bodyEl.appendChild(chosenBlock);
  }

  // Hook al click su "Effetto Extra" (solo inventario)
  if (fromInventory) {
    const trigger = bodyEl.querySelector('#extra-effect-trigger');
    if (trigger) {
      trigger.onclick = () => {
        if (extraProgress < 20) {
          const msg = "Per sbloccare l'Effetto Extra devi potenziare quest'arma con almeno 20 cristalli nell'attributo Extra.";
          if (typeof showGameMessage === 'function') {
            showGameMessage('Effetto Extra bloccato', msg);
          } else {
            alert(msg);
          }
          return;
        }
        // Apri la scelta effetti (step 3: deve esistere una funzione che gestisce la selezione)
        if (typeof openExtraEffectPopup === 'function') {
          openExtraEffectPopup(weapon.name);
        } else {
          // fallback minimo
          alert("Selettore effetti non ancora disponibile.");
        }
      };
    }
  }

  if (fromInventory) {
    // Dal deposito: niente "Acquista", aggiungo i due bottoni di equip.
    buyBtn.style.display = 'none';
    buyBtn.onclick = null;

    const box = document.createElement('div');
    box.style.marginTop = '10px';
    box.innerHTML = `
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:18px;">
        <button id="equip-right"  class="magic-button" style="margin:0;">Equipaggia mano destra</button>
        <button id="equip-left"   class="magic-button" style="margin:0;">Equipaggia mano sinistra</button>
      </div>
    `;
    bodyEl.appendChild(box);

    const btnR = box.querySelector('#equip-right');
    const btnL = box.querySelector('#equip-left');

    const canEquip = qtyOwned > 0;
    btnR.disabled = !canEquip;
    btnL.disabled = !canEquip;

    const clearText = 'nessuna';
    let moved = false;

    const applyEquip = (hand) => {
      const otherHand = (hand === 'right') ? 'left' : 'right';
      const currentRight = userStore.get('rightHand');
      const currentLeft  = userStore.get('leftHand');

      const handHas  = (hand === 'right') ? (currentRight === weapon.name) : (currentLeft === weapon.name);
      const otherHas = (hand === 'right') ? (currentLeft  === weapon.name) : (currentRight === weapon.name);

      if (handHas) { closeWeaponDetail(); return; }

      if (remaining > 0) {
        if (hand === 'right') userStore.set('rightHand', weapon.name);
        else                  userStore.set('leftHand',  weapon.name);
      } else if (otherHas) {
        moved = true;
        if (hand === 'right') {
          userStore.set('leftHand', null);
          userStore.set('rightHand', weapon.name);
        } else {
          userStore.set('rightHand', null);
          userStore.set('leftHand',  weapon.name);
        }
      } else {
        return;
      }

      const r1 = document.getElementById('right-hand-display');
      const l1 = document.getElementById('left-hand-display');
      const r2 = document.getElementById('hero-weapon-right');
      const l2 = document.getElementById('hero-weapon-left');

      if (hand === 'right') {
        if (r1) r1.textContent = formatWeaponName(weapon.name);
	if (r2) r2.textContent = formatWeaponName(weapon.name);

        if (moved) {
          if (l1) l1.textContent = clearText;
          if (l2) l2.textContent = clearText;
        }
      } else {
        if (l1) l1.textContent = formatWeaponName(weapon.name);
	if (l2) l2.textContent = formatWeaponName(weapon.name);

        if (moved) {
          if (r1) r1.textContent = clearText;
          if (r2) r2.textContent = clearText;
        }
      }

      if (typeof showGameMessage === 'function') {
        const mano = hand === 'right' ? 'destra' : 'sinistra';
        showGameMessage('Equipaggiata', `Hai equipaggiato <strong>${weapon.name}</strong> nella <strong>mano ${mano}</strong>.`);
      }
      updateEquippedWeaponsUI();
      closeWeaponDetail();
    };

    btnR.onclick = () => applyEquip('right');
    btnL.onclick = () => applyEquip('left');
// --- Converti in Polvere (rarit√† non comune; pu√≤ disequipaggiare una mano se serve) ---
const gainDust = (typeof DUST_BY_RARITY !== 'undefined') ? (DUST_BY_RARITY[rarity] || 0) : 0;
if (gainDust > 0) {
  const dustBtn = document.createElement('button');
  dustBtn.className = 'magic-button';
  dustBtn.textContent = `Converti in Polvere (+${gainDust})`;

  dustBtn.onclick = () => {
    // ricalcola stato LIVE
    const mapNow = userStore.get('weapons') || {};
    const qtyNow = Number(mapNow[weapon.name] || 0);
    const rHand  = userStore.get('rightHand');
    const lHand  = userStore.get('leftHand');

    let usedNow = 0;
    if (rHand === weapon.name) usedNow++;
    if (lHand === weapon.name) usedNow++;
    let freeNow = Math.max(0, qtyNow - usedNow);

    // Se non c'√® alcuna copia libera, disequipaggia UNA mano che la usa (priorit√†: sinistra, poi destra)
    if (freeNow <= 0) {
      if (lHand === weapon.name) {
        userStore.remove('leftHand');
        const l1 = document.getElementById('left-hand-display');
        if (l1) l1.textContent = 'nessuna';
        const l2 = document.getElementById('hero-weapon-left');
        if (l2) l2.textContent = 'nessuna';
      } else if (rHand === weapon.name) {
        userStore.remove('rightHand');
        const r1 = document.getElementById('right-hand-display');
        if (r1) r1.textContent = 'nessuna';
        const r2 = document.getElementById('hero-weapon-right');
        if (r2) r2.textContent = 'nessuna';
      }

      if (typeof updateEquippedWeaponsUI === 'function') updateEquippedWeaponsUI();

      // ricalcola dopo l'un-equip
      const r2h = userStore.get('rightHand');
      const l2h = userStore.get('leftHand');
      usedNow = 0;
      if (r2h === weapon.name) usedNow++;
      if (l2h === weapon.name) usedNow++;
      freeNow = Math.max(0, qtyNow - usedNow);
    }

    if (freeNow <= 0 || qtyNow <= 0) {
      // non dovremmo arrivarci, ma nel dubbio‚Ä¶
      if (typeof showGameMessage === 'function') {
        showGameMessage('Nessuna copia disponibile', 'Non hai copie convertibili di questa arma.');
      }
      return;
    }

    confirmConvertToDust(gainDust, () => {
      const map = userStore.get('weapons') || {};
      const cur = Number(map[weapon.name] || 0);
      map[weapon.name] = Math.max(0, cur - 1);
      userStore.set('weapons', map);

      if (typeof addArcaneDust === 'function') addArcaneDust(gainDust);
      if (typeof updateDustBadges === 'function') updateDustBadges();

      // Refresh lista inventario (mantiene pagina)
      if (window._invPage && _invPage.weapons) {
        populateStorage('weapon-list', 'weapons', _invPage.weapons);
      }

      if (typeof closeWeaponDetail === 'function') closeWeaponDetail();
      if (typeof showGameMessage === 'function') {
        showGameMessage('Conversione riuscita', `Hai ottenuto <strong>${gainDust}</strong> unit√† di Polvere Arcana.`);
      }
    });
  };

  const spacer = document.createElement('div');
  spacer.style.height = '8px';
  bodyEl.appendChild(spacer);
  bodyEl.appendChild(dustBtn);
}
// --- Vendi (SOLO se arma comune) ---
if (rarity === 'comune') {
  const basePrice = Number(weapon.price || 0);
  const sellPrice = Math.ceil((basePrice * 2) / 3); // arrotondato per eccesso
  if (sellPrice > 0) {
    const sellBtn = document.createElement('button');
    sellBtn.className = 'magic-button';
    sellBtn.textContent = `Vendi (+${formatGold(sellPrice)} oro)`;

    sellBtn.onclick = function () {
      // stato LIVE
      const mapNow = userStore.get('weapons') || {};
      const qtyNow = Number(mapNow[weapon.name] || 0);
      const rHand  = userStore.get('rightHand');
      const lHand  = userStore.get('leftHand');

      let usedNow = 0;
      if (rHand === weapon.name) usedNow++;
      if (lHand === weapon.name) usedNow++;
      let freeNow = Math.max(0, qtyNow - usedNow);

      // se non ci sono copie libere, disequipaggia una mano (priorit√† sinistra)
      if (freeNow <= 0 && qtyNow > 0) {
        if (lHand === weapon.name) {
          userStore.remove('leftHand');
          const l1 = document.getElementById('left-hand-display'); if (l1) l1.textContent = 'nessuna';
          const l2 = document.getElementById('hero-weapon-left');  if (l2) l2.textContent = 'nessuna';
        } else if (rHand === weapon.name) {
          userStore.remove('rightHand');
          const r1 = document.getElementById('right-hand-display'); if (r1) r1.textContent = 'nessuna';
          const r2 = document.getElementById('hero-weapon-right');  if (r2) r2.textContent = 'nessuna';
        }
        if (typeof updateEquippedWeaponsUI === 'function') updateEquippedWeaponsUI();
        // ricalcola libere
        const rr = userStore.get('rightHand');
        const ll = userStore.get('leftHand');
        usedNow = 0;
        if (rr === weapon.name) usedNow++;
        if (ll === weapon.name) usedNow++;
        freeNow = Math.max(0, qtyNow - usedNow);
      }

      if (qtyNow <= 0 || freeNow <= 0) {
        if (typeof showGameMessage === 'function') showGameMessage('Nessuna copia disponibile', 'Non hai copie vendibili di questa arma.');
        return;
      }

      confirmSellItem(sellPrice, function () {
        // scala 1 dallo stack
        const map = userStore.get('weapons') || {};
        const cur = Number(map[weapon.name] || 0);
        map[weapon.name] = Math.max(0, cur - 1);
        userStore.set('weapons', map);

        // accredita oro
        if (typeof addNum === 'function') addNum('gold', sellPrice);
        updateGoldBadges();

if (typeof incrementQuest === 'function') incrementQuest('q_daily_sell_item_shop', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

        // refresh lista armi
        if (window._invPage && _invPage.weapons) {
          populateStorage('weapon-list', 'weapons', _invPage.weapons);
        }

        if (typeof closeWeaponDetail === 'function') closeWeaponDetail();
        if (typeof showGameMessage === 'function') {
          showGameMessage('Vendita riuscita', `Hai ottenuto <strong>${formatGold(sellPrice)}</strong> monete d'oro.`);
        }
      });
    };

    const spacerSell = document.createElement('div'); spacerSell.style.height = '8px';
    bodyEl.appendChild(spacerSell);
    bodyEl.appendChild(sellBtn);
  }
}

  } else {
    buyBtn.style.display = 'inline-block';
    buyBtn.disabled = false;
    buyBtn.textContent = 'Acquista';
    buyBtn.onclick = () => {
      buyWeapon(weapon.name, safePrice);
      closeWeaponDetail();

      const gold = getNum('gold', 0);
      const gEl1 = document.getElementById('weapon-shop-gold');
      if (gEl1) gEl1.textContent = formatGold(gold);
      const gEl2 = document.getElementById('hero-gold');
      if (gEl2) gEl2.innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;
    };
  }

    lockBodyScroll();
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');

applyRarityDecor(modal, titleEl, rarity);
positionModalBelowSectionTitle(modal, fromInventory ? '#weapon-storage' : '#weapon-shop', 16);
}

// Chiudi cliccando sul backdrop
document.getElementById('weapon-overlay')?.addEventListener('click', closeWeaponDetail);


// === Effetti disponibili (titolo + descrizione) ===
const EXTRA_EFFECTS = [
  { name: 'Sanguinamento',   desc: 'I colpi lasciano una ferita profonda che causa danni nel tempo.' },
  { name: 'Veleno',          desc: 'Infligge un avvelenamento progressivo che indebolisce il nemico.' },
  { name: 'Furia',           desc: 'Aumenta l‚Äôaggressivit√† dell‚Äôarma con picchi di danno improvvisi.' },
  { name: 'Frantumazione',   desc: 'I colpi possono infrangere le difese riducendo l‚Äôarmatura avversaria.' },
  { name: 'Perforazione',    desc: 'Maggior capacit√† di penetrare scudi e corazze pesanti.' },
  { name: 'Impatto',         desc: 'Colpi possenti che possono sbilanciare o stordire per un istante.' }
];

// === Apertura popup scelta effetto ===
function openExtraEffectPopup(weaponName) {
  ensureExtraEffectModal();

  const ov  = document.getElementById('extra-effect-overlay');
  const md  = document.getElementById('extra-effect-modal');
  const ttl = document.getElementById('extra-effect-title');
  const bd  = document.getElementById('extra-effect-body');
  const ft  = document.getElementById('extra-effect-footer');

  // Stato attuale: progresso + effetto inciso
  const progMap  = userStore.get('weaponExtraProgress') || {};
  const progress = Number(progMap[weaponName] || 0);
  const chosen   = userStore.get(`weaponExtraEffect_${weaponName}`) || null;

  ttl.textContent = `Effetto Extra ‚Äî ${weaponName}`;
  bd.innerHTML = '';
  ft.innerHTML = '';

  // 1) gi√† inciso
  if (chosen) {
    bd.innerHTML = `
      <p class="muted">L'effetto extra √® gi√† stato inciso su questa arma e non pu√≤ essere cambiato.</p>
      <div class="traits-block" style="margin-top:8px;">
        <div class="title">Effetto Inciso</div>
        <p><strong>${chosen}</strong></p>
      </div>
    `;
    ft.innerHTML = `<button class="magic-button" onclick="closeExtraEffectPopup()">Chiudi</button>`;
    ov.classList.remove('hidden'); md.classList.remove('hidden');
    return;
  }

  // 2) non sbloccato (<20)
  if (progress < 20) {
    bd.innerHTML = `
      <p><strong>Bloccato</strong>: per sbloccare l'Effetto Extra devi potenziare questa arma con <strong>20 cristalli</strong> nell'attributo <em>Extra</em>.</p>
      <p class="muted">Stato attuale: ${progress}/20</p>
    `;
    ft.innerHTML = `<button class="magic-button" onclick="closeExtraEffectPopup()">Chiudi</button>`;
    ov.classList.remove('hidden'); md.classList.remove('hidden');
    return;
  }

  // 3) sbloccato, scegli effetto
  bd.innerHTML = `
    <p class="muted">Scegli con attenzione: potrai incidere <strong>un solo effetto extra</strong> su questa arma.</p>
    <div class="traits-block" style="margin-top:8px;">
      <div class="title">Seleziona Effetto</div>
      <div class="traits-grid" id="extra-effect-list" style="grid-template-columns: 1fr;">
        ${EXTRA_EFFECTS.map(e => `
          <button class="magic-button extra-effect-option" data-eff="${e.name}">
            <strong>${e.name}</strong><br>
            <span class="muted">${e.desc}</span>
          </button>
        `).join('')}
      </div>
    </div>
  `;
  ft.innerHTML = `
    <button class="magic-button" id="extra-effect-confirm" disabled>Incidi l'effetto</button>
    <button class="magic-button" onclick="closeExtraEffectPopup()">Chiudi</button>
  `;

  let selected = null;
  bd.querySelectorAll('.extra-effect-option').forEach(btn => {
    btn.addEventListener('click', () => {
      bd.querySelectorAll('.extra-effect-option').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      selected = btn.getAttribute('data-eff');
      const confirmBtn = document.getElementById('extra-effect-confirm');
      if (confirmBtn) confirmBtn.disabled = !selected;
    });
  });

  // ‚¨áÔ∏è MODIFICA: conferma prima di incidere
  document.getElementById('extra-effect-confirm')?.addEventListener('click', () => {
    if (!selected) return;

    showConfirmDialog({
      title: 'Conferma incisione',
      text: `Sei sicuro di voler incidere l'effetto <strong>${selected}</strong> sull'arma <strong>${weaponName}</strong>?<br><strong>I cristalli utilizzati per lo sblocco non potranno essere ripristinati.</strong>`,
      okText: 'S√¨, incidi',
      cancelText: 'No',
      onConfirm: () => {
        // Incidi in storage (scelta permanente)
        userStore.set(`weaponExtraEffect_${weaponName}`, selected);

        // (compatibilit√†) allinea anche la mappa legacy
        const map = userStore.get('weaponExtraChosen') || {};
        map[weaponName] = selected;
        userStore.set('weaponExtraChosen', map);

        if (typeof showGameMessage === 'function') {
          showGameMessage('Effetto inciso', `Hai inciso <strong>${selected}</strong> su <strong>${weaponName}</strong>!`);
        }
        closeExtraEffectPopup();

        // Refresh dettaglio arma per mantenere grafica/rarit√† corretta
        try {
          if (typeof openFromInventory === 'function') {
            // usa il risolutore centralizzato (comune + varianti generate)
            openFromInventory('weapons', weaponName);
          } else if (typeof getAllDefs === 'function' && typeof showWeaponDetails === 'function') {
            // fallback: prova a risolvere la variante per nome
            const list = getAllDefs('weapons');
            let w = list.find(x => x && x.name === weaponName);

            if (!w && typeof baseNameFromVariant === 'function' && typeof makeVariant === 'function') {
              const base = baseNameFromVariant(weaponName);
              const m = weaponName.match(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i);
              if (m) {
                const rar = m[1].toLowerCase(); // 'rara' | 'epica' | 'leggendaria' | 'mitica'
                const baseObj = list.find(x => x && x.name === base);
                if (baseObj) w = makeVariant(baseObj, rar, 'weapons');
              }
            }

            showWeaponDetails(w || { name: weaponName }, true);
          }
        } catch (e) {
          // estremo fallback: almeno riapri qualcosa
          if (typeof showWeaponDetails === 'function') {
            showWeaponDetails({ name: weaponName }, true);
          }
        }
      }
    });
  });

  ov.classList.remove('hidden');
  md.classList.remove('hidden');
}



// === Ensure/destroy modal specifico per Effetto Extra ===
function ensureExtraEffectModal() {
  let ov = document.getElementById('extra-effect-overlay');
  let md = document.getElementById('extra-effect-modal');
  if (ov && md) return;

  if (!ov) {
    ov = document.createElement('div');
    ov.id = 'extra-effect-overlay';
    ov.className = 'hidden';
    ov.onclick = closeExtraEffectPopup; // chiudi al click sul backdrop
    document.body.appendChild(ov);
  }
  if (!md) {
    md = document.createElement('div');
    md.id = 'extra-effect-modal';
    md.className = 'hidden';
    md.innerHTML = `
      <h3 id="extra-effect-title">Effetto Extra</h3>
      <div id="extra-effect-body"></div>
      <div id="extra-effect-footer" style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end;"></div>
    `;
    document.body.appendChild(md);
  }
}

function closeExtraEffectPopup() {
  document.getElementById('extra-effect-overlay')?.classList.add('hidden');
  document.getElementById('extra-effect-modal')?.classList.add('hidden');
}


function goBackFromWeaponShop() {
  document.getElementById('weapon-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}
function showCreatureShop() {
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('creature-shop').classList.remove('hidden');

  const gold = getNum('gold', 0);
  const goldEl = document.getElementById('creature-shop-gold');
  if (goldEl) goldEl.textContent = formatGold(gold);

  const list = document.getElementById('creature-buttons-list');
  if (!list) {
    console.warn('Manca #creature-buttons-list nel DOM.');
    return;
  }
  list.innerHTML = '';

  (window.creatureShop || []).forEach(c => {
    const btn = document.createElement('button');
    btn.className = 'magic-button';
    const owned = window.isCreatureOwned && window.isCreatureOwned(c.name);
    btn.textContent = owned ? `${c.name} (Posseduta)` : c.name;
    btn.onclick = () => showCreatureDetails(c);
    list.appendChild(btn);
  });

  // assicura che il popup esista
  ensureCreatureModal();
  closeCreatureDetail();
}

function showCreatureDetails(creature, fromInventory = false) {
  ensureCreatureModal();

  const overlay = document.getElementById('creature-overlay');
  const modal   = document.getElementById('creature-detail');
  const titleEl = document.getElementById('creature-detail-title');
  const bodyEl  = document.getElementById('creature-detail-body');
  const buyBtn  = document.getElementById('creature-detail-buy');

  if (!overlay || !modal || !titleEl || !bodyEl || !buyBtn) {
    console.error('Popup creature: elementi mancanti.');
    return;
  }

  const owned = (typeof window.isCreatureOwned === 'function') && window.isCreatureOwned(creature.name);

  titleEl.textContent = creature.name;

  const imgSrc = getCreatureImageSrc(creature.name);
const baseForAlt = creature.name;


  const rawRarity = String(creature.rarity || 'comune').toLowerCase();
// preferisci i tratti dell‚Äôoggetto (varianti potenziate), fallback ai tratti base da storage
const t = (creature && creature.traits)
  ? creature.traits
  : ((typeof getCreatureTraits === 'function') ? getCreatureTraits(creature.name) : null);
  const rarity = rawRarity; // <- usata per la decorazione di rarit√†

  const traitsHtml = t ? `
    <div class="traits-block">
      <div class="title">Caratteristiche</div>
      <div class="traits-grid">
        <div>Rarit√†: <strong class="rarity rarity--${rawRarity}">${rawRarity}</strong></div>
        <div>Forza: <strong>${t.Forza}</strong></div>
        <div>Agilit√†: <strong>${t.Agilit√†}</strong></div>
        <div>Astuzia: <strong>${t.Astuzia}</strong></div>
        <div>Aggressivit√†: <strong>${t.Aggressivit√†}</strong></div>
        <div>Dimensioni: <strong>${t.Dimensioni}</strong></div>
      </div>
    </div>
  ` : '';

  // --- NEW: XP visibile solo dall'inventario ---
  if (fromInventory && typeof ensureCreatureXpMap === 'function') {
    ensureCreatureXpMap(); // copre salvataggi vecchi senza mappa XP
  }
  const creatureXpVal = (typeof getCreatureXp === 'function')
    ? getCreatureXp(creature.name)
    : 0;
  const xpRow = fromInventory ? `<p><strong>Esperienza:</strong> ${creatureXpVal} XP</p>` : '';
  // ------------------------------------------------

  const costNum = Number(creature.cost || 0);
  const safeCost = isNaN(costNum) ? 0 : costNum;
  const priceRow = fromInventory ? '' : `<p><strong>Prezzo:</strong> ${formatGold(safeCost)} monete d'oro</p>`;

  bodyEl.innerHTML = `
  <img class="weapon-thumb creature-thumb--frame"
       src="${imgSrc}"
       alt="${creature.name}"
       onerror="this.onerror=null; this.src='Creatures/${encodeURIComponent(creature.name)}.png';">
  ${traitsHtml}
  ${xpRow}
  ${priceRow}
`;



  if (fromInventory) {
    buyBtn.style.display = 'none';
    buyBtn.onclick = null;

    const equipBtn = document.createElement('button');
    equipBtn.className = 'magic-button';
    equipBtn.textContent = 'Equipaggia';
    if (!owned) equipBtn.disabled = true;

    equipBtn.onclick = () => {
      if (typeof window.setEquippedCreature === 'function') {
        window.setEquippedCreature(creature.name);
      } else {
        // fallback
        userStore.set('equippedCreature', creature.name);
        const ce = document.getElementById('equipped-creature');
        if (ce) ce.textContent = creature.name;
      }
      showGameMessage('Equipaggiata', `Hai equipaggiato <strong>${creature.name}</strong>.`);
      closeCreatureDetail();
    };

    bodyEl.appendChild(document.createElement('hr'));
    bodyEl.appendChild(equipBtn);
// --- Converti in Polvere (solo rarit√† non comune) ---
const gainDust = (typeof DUST_BY_RARITY !== 'undefined') ? (DUST_BY_RARITY[rawRarity] || 0) : 0;
if (gainDust > 0) {
  const dustBtn = document.createElement('button');
  dustBtn.className = 'magic-button';
  dustBtn.textContent = `Converti in Polvere (+${gainDust})`;
  dustBtn.onclick = () => {
    confirmConvertToDust(gainDust, () => {
      // rimuovi dalla collezione
      const list = (userStore.get('creatures') || []).slice();
      const i = list.indexOf(creature.name);
      if (i >= 0) { list.splice(i, 1); userStore.set('creatures', list); }

      // se equipaggiata, pulisci
      const eq = userStore.get('equippedCreature');
      if (eq === creature.name) {
        userStore.remove('equippedCreature');
        const el = document.getElementById('equipped-creature');
        if (el) el.textContent = 'Nessuna';
      }

      if (typeof addArcaneDust === 'function') addArcaneDust(gainDust);
      updateDustBadges();

      if (window._invPage && _invPage.creatures) populateStorage('creature-list','creatures', _invPage.creatures);

      closeCreatureDetail?.();
      showGameMessage('Conversione riuscita', `Hai ottenuto <strong>${gainDust}</strong> unit√† di Polvere Arcana.`);
    });
  };
  bodyEl.appendChild(dustBtn);
}
// Vendi (SOLO comune)
    if (rarity === 'comune' && owned) {
      const sellPrice = Math.ceil((safeCost * 2) / 3);
      if (sellPrice > 0) {
        const sellBtn = document.createElement('button');
        sellBtn.className = 'magic-button';
        sellBtn.textContent = `Vendi (+${formatGold(sellPrice)} oro)`;
        sellBtn.onclick = function () {
          confirmSellItem(sellPrice, function () {
            const list = (userStore.get('creatures') || []).slice();
            const idx = list.indexOf(creature.name);
            if (idx >= 0) { list.splice(idx, 1); userStore.set('creatures', list); }

            const eq = userStore.get('equippedCreature');
            if (eq === creature.name) {
              userStore.remove('equippedCreature');
              const ce = document.getElementById('equipped-creature'); if (ce) ce.textContent = 'Nessuna';
            }

            if (typeof addNum === 'function') addNum('gold', sellPrice);
            if (typeof updateGoldBadges === 'function') updateGoldBadges();
if (typeof incrementQuest === 'function') incrementQuest('q_daily_sell_item_shop', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

            if (window._invPage && _invPage.creatures) populateStorage('creature-list', 'creatures', _invPage.creatures);

            closeCreatureDetail();
            showGameMessage('Vendita riuscita', `Hai ottenuto <strong>${formatGold(sellPrice)}</strong> monete d'oro.`);
          });
        };
        bodyEl.appendChild(document.createElement('div')).style.height = '8px';
        bodyEl.appendChild(sellBtn);
      }
    }
  } else {
    buyBtn.style.display = 'inline-block';
    buyBtn.disabled = !!owned;
    buyBtn.textContent = owned ? 'Gi√† posseduta' : 'Acquista';
    buyBtn.onclick = owned
      ? null
      : () => { buyCreature(creature.name, safeCost); closeCreatureDetail(); };
  }

    lockBodyScroll();
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');


  // Decorazioni visive in base alla rarit√† (banda superiore + underline titolo estesa)
  applyRarityDecor(modal, titleEl, rarity);
positionModalBelowSectionTitle(modal, fromInventory ? '#creature-storage' : '#creature-shop', 16);

}


function buyCreature(name, cost) {
  if (window.isCreatureOwned && window.isCreatureOwned(name)) {
    closeCreatureDetail();
    showCreatureShop();
    return;
  }

  let gold = getNum('gold', 0);
  if (gold < cost) {
    showGameMessage("Oro insufficiente", "Non hai abbastanza oro per acquistare questa creatura.");
    return;
  }

  gold -= cost;
  setNum('gold', gold);

  const creatures = userStore.get('creatures') || [];
  if (!creatures.includes(name)) {
    creatures.push(name);
    userStore.set('creatures', creatures);
  }

  // aggiorna UI oro
  document.getElementById('creature-shop-gold').textContent = formatGold(gold);
  document.getElementById('hero-gold').innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  closeCreatureDetail();
  showCreatureShop();
  showGameMessage("Complimenti!", "L'acquisto √® andato a buon fine!");
if (typeof incrementQuest === 'function') incrementQuest('q_daily_classic_shop_buy_equipment', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

// === Selezione creatura da equipaggiare (popup nuovo) ===
function openCreatureSelect() {
  // elenco possedute
  const owned = (window.getOwnedCreatures && window.getOwnedCreatures()) || [];
  const list  = document.getElementById('creature-choice-list');
  if (!list) return;

  const PER_PAGE = 10;
  let page = 1;

  function render() {
    list.innerHTML = owned.length
      ? ''
      : '<p class="muted">Non hai creature disponibili.</p>';

    if (!owned.length) return;

    const start = (page - 1) * PER_PAGE;
    const slice = owned.slice(start, start + PER_PAGE);

    // Calcolo XP una volta a render
    if (typeof ensureCreatureXpMap === 'function') ensureCreatureXpMap();

    slice.forEach(name => {
      const btn = document.createElement('button');
      btn.className = 'magic-button';

      const xp = (typeof getCreatureXp === 'function') ? getCreatureXp(name) : 0;
      btn.textContent = `${name} (${xp} xp)`;

      btn.onclick = () => selectCreatureFor(name);
      list.appendChild(btn);
    });

    // Pager
    const hasNext = (start + PER_PAGE) < owned.length;
    const hasPrev = page > 1;

    if (hasNext || hasPrev) {
      const pager = document.createElement('div');
      pager.style.display = 'flex';
pager.style.flexDirection = 'column';
pager.style.alignItems = 'flex-start';
pager.style.gap = '8px';
pager.style.marginTop = '10px';


      if (hasNext) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = 'Pagina successiva';
        nextBtn.onclick = () => { page++; render(); };
        pager.appendChild(nextBtn);
      }
      if (hasPrev) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = 'Pagina precedente';
        prevBtn.onclick = () => { page--; render(); };
        pager.appendChild(prevBtn);
      }

      list.appendChild(pager);
    }
  }

  render();

  document.getElementById('creature-select-overlay')?.classList.remove('hidden');
  document.getElementById('creature-select-popup')?.classList.remove('hidden');
  positionModalUnderHeroType(document.getElementById('creature-select-popup'), 12);

}

function selectCreatureFor(name) {
  if (window.setEquippedCreature) window.setEquippedCreature(name);

  const el = document.getElementById('equipped-creature');
  if (el) {
    if (name) {
      if (typeof ensureCreatureXpMap === 'function') ensureCreatureXpMap();
      const xp = (typeof getCreatureXp === 'function') ? getCreatureXp(name) : 0;
      el.textContent = `${name} (${xp} xp)`;
    } else {
      el.textContent = 'Nessuna';
    }
  }

  if (typeof updateHeroPowerUI === 'function') updateHeroPowerUI();
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    upsertCurrentHeroIntoDirectory();
  }

  closeCreatureSelect();
}


function unequipCreature() {
  if (window.setEquippedCreature) window.setEquippedCreature(null);
  const el = document.getElementById('equipped-creature');
  if (el) el.textContent = 'Nessuna';

  if (typeof updateHeroPowerUI === 'function') updateHeroPowerUI();
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    upsertCurrentHeroIntoDirectory();
  }

  closeCreatureSelect();
}


function closeCreatureSelect() {
  document.getElementById('creature-select-overlay')?.classList.add('hidden');
  document.getElementById('creature-select-popup')?.classList.add('hidden');
}

// chiudi anche cliccando il backdrop
document.getElementById('creature-select-overlay')?.addEventListener('click', closeCreatureSelect);

function goBackFromCreatureShop() {
  closeCreatureDetail(); // chiude eventuale popup
  document.getElementById('creature-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function goBackToShop() {
  document.getElementById('magic-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function showMagicStorage() {
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('magic-storage').classList.remove('hidden');
  _invPage.magics = 1;
populateStorage('magic-list', 'magics', 1);

}

// =========================
// üìò TUTORIAL (schermate non-popup)
// =========================
function showTutorial() {
  // chiudi overlay/popup se presenti (best effort)
  try { closeAllPopups?.(); } catch(e) {}

  // Nascondi le schermate principali (best effort)
  const hideIds = [
    'menu','hero-profile','inventory','shop','chest-room','missions','challenges',
    'messages','settings','leaderboard','abilities','hero-hall','guild-screen',
    'crystals-screen','crystal-spend-screen'
  ];
  hideIds.forEach(id => document.getElementById(id)?.classList.add('hidden'));

  // Mostra tutorial
  document.getElementById('tutorial-screen')?.classList.remove('hidden');

  renderTutorialHome();
}
function leaveTutorialThen(fn){
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  if (typeof fn === 'function') fn();
}

function renderTutorialHome() {
  const body = document.getElementById('tutorial-body');
  if (!body) return;

  body.innerHTML = `
    <div class="traits-block tutorial-card">
      <div class="title">Benvenuto nel Tutorial</div>
      <div class="muted" style="margin-top:6px;">
        Qui trovi una guida rapida alle funzioni principali di <strong>Mitharia</strong>.
        Il tutorial √® <strong>sempre disponibile</strong>: puoi tornare quando vuoi per ripassare
        meccaniche, schermate e consigli utili.
      </div>
    </div>

    <div class="traits-block tutorial-card">
      <div class="title">Sezioni</div>

      <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:10px;">
        <button class="magic-button" data-tut="equip">Equipaggiamento</button>
        <button class="magic-button" data-tut="chests">Sala dei Forzieri</button>
        <button class="magic-button" data-tut="missions">Missioni</button>
        <button class="magic-button" data-tut="quests">Quest</button>
        <button class="magic-button" data-tut="pvp">Sfide PVP</button>
        <button class="magic-button" data-tut="dungeon">Dungeon</button>
        <button class="magic-button" data-tut="tower">Torre delle Prove</button>
        <button class="magic-button" data-tut="crystals">Cristalli di Potenziamento</button>
        <button class="magic-button" data-tut="guild">Gilda</button>
        <button class="magic-button" data-tut="abilities">Punti Abilit√†</button>
        <button class="magic-button" data-tut="shield">Scudo</button>
        <button class="magic-button" data-tut="power">Potenza</button>
      </div>
    </div>
  
<div style="margin-top:12px; text-align:center;">
  <button class="menu-button" id="tut-back-menu">Men√π principale</button>
</div>
`;
  document.getElementById('tut-back-menu')?.addEventListener('click', () => {
    document.getElementById('tutorial-screen')?.classList.add('hidden');
    document.getElementById('menu')?.classList.remove('hidden');
  });

  body.querySelectorAll('[data-tut]').forEach(btn => {
    btn.addEventListener('click', () => renderTutorialSection(btn.getAttribute('data-tut')));
  });
}

function renderTutorialSection(key) {
  const body = document.getElementById('tutorial-body');
  if (!body) return;

  const goHome = `
    <div style="margin:6px 0 10px;">
      <button class="mini-button mini-button--dark" id="tut-back-home">‚Üê Indietro</button>
    </div>
  `;

  const set = (html) => {
    body.innerHTML = html;
    document.getElementById('tut-back-home')?.addEventListener('click', renderTutorialHome);
  };

  if (key === 'equip') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Equipaggiamento</div>
        ${goHome}
        <div class="muted">
          Scegli e acquista con cura <strong>armi, armature, magie e creature</strong> in base allo stile del tuo eroe.
          Il tuo equipaggiamento influenza direttamente la <strong>potenza</strong> e le prestazioni in missioni e sfide.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-shop">Acquista il tuo equipaggiamento</button>
          <button class="magic-button" id="tut-go-inv">Indossa il tuo equipaggiamento</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-shop')?.addEventListener('click', () => leaveTutorialThen(showShop));
document.getElementById('tut-go-inv')?.addEventListener('click', () => leaveTutorialThen(showInventory));
    return;
  }

  if (key === 'chests') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Sala dei Forzieri</div>
        ${goHome}
        <div class="muted">
          Nella Sala dei Forzieri puoi ottenere <strong>armi, armature, magie e creature</strong> di rarit√† superiore
          (Rara, Epica, Leggendaria, Mitica). Pi√π la rarit√† √® alta, migliori saranno le caratteristiche.
          Guadagna <strong>Polvere Arcana</strong> e chiavi completando attivit√† e quest.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-chests">Vai alla Sala dei Forzieri</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-chests')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showShop();
  showChestsRoom?.();
});
    return;
  }

  if (key === 'missions') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Missioni</div>
        ${goHome}
        <div class="muted">
          Completa le <strong>missioni giornaliere</strong> per ottenere oro, EXP eroe, punti abilit√† e EXP creatura.
          In base alla difficolt√† e alla tua potenza potresti perdere salute: ricordati di recuperarla con le pozioni.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-missions">Completa una missione</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-missions')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showMissions();
  setMissionsTab?.('daily');
});
    return;
  }

  if (key === 'quests') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Quest</div>
        ${goHome}
        <div class="muted">
          Completa le quest <strong>giornaliere, settimanali e principali</strong> per ottenere ricompense.
          Ricordati di <strong>riscuotere</strong> le ricompense quando sono pronte.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-quests">Riscuoti una ricompensa quest</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-quests')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showMissions();
  setMissionsTab?.('quests');
});
    return;
  }

  if (key === 'pvp') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Sfide PVP</div>
        ${goHome}
        <div class="muted">
          Sfida altri eroi, guadagna punti e scala le classifiche.
          Ogni sfida consuma <strong>4 punti energia</strong>. Recuperi 1 energia ogni ora e a mezzanotte l‚Äôenergia si ripristina.
          Non puoi sfidare lo stesso eroe pi√π di <strong>2 volte al giorno</strong>.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-pvp">Effettua una sfida PVP</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-pvp')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showChallenges();
  setChallengesTab?.('sfide');
});

    return;
  }

  if (key === 'dungeon') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Dungeon</div>
        ${goHome}
        <div class="muted">
          Combatti nel dungeon contro bot generati dal gioco e guadagna oro ed esperienza.
          Ogni sfida consuma energia in base alla difficolt√†. Recuperi 1 energia ogni <strong>15 minuti</strong> e a mezzanotte si ripristina.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-dungeon">Effettua una sfida Dungeon</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-dungeon')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showChallenges();
  setChallengesTab?.('dungeon');
});
    return;
  }

  if (key === 'tower') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Torre delle Prove</div>
        ${goHome}
        <div class="muted">
          Una delle sfide pi√π ardue del mondo di Mitharia.
          Supera i piani della torre per ottenere ricchi premi: hai <strong>5 sfide giornaliere</strong>.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-tower">Vai alla Torre delle Prove</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-tower')?.addEventListener('click', () => {
  document.getElementById('tutorial-screen')?.classList.add('hidden');
  showChallenges();
  setChallengesTab?.('tower');
});
    return;
  }

  if (key === 'crystals') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Cristalli di Potenziamento</div>
        ${goHome}
        <div class="muted">
          I Cristalli di Potenziamento servono per potenziare le caratteristiche delle tue armi, armature e magie.
          Usali con saggezza per aumentare danno, difesa, velocit√† e persino sbloccare effetti extra unici!
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-crystals">Cristalli di potenziamento</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-crystals')?.addEventListener('click', () => leaveTutorialThen(showCrystalsScreen));
    return;
  }

  if (key === 'guild') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Gilda</div>
        ${goHome}
        <div class="muted">
          Crea o entra a far parte di una Gilda. Ti aspetta un negozio con oggetti segreti e speciali,
          edifici con benefici, guerre e trattati di pace, e la miniera della gilda per scavare oro.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-guild">Gilda</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-guild')?.addEventListener('click', () => leaveTutorialThen(showGuildScreen));
    return;
  }

  if (key === 'abilities') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Punti Abilit√†</div>
        ${goHome}
        <div class="muted">
          Assegna con saggezza i punti abilit√† in base al tuo equipaggiamento.
          Distribuire correttamente i punti aumenta la tua potenza in modo molto pi√π efficace.
          Se vuoi riassegnarli, puoi sempre usare il <strong>Rituale di riassetto</strong>.
        </div>

        <div class="tutorial-actions">
          <button class="magic-button" id="tut-go-abilities">Assegna punti abilit√†</button>
        </div>
      </div>
    `);

    document.getElementById('tut-go-abilities')?.addEventListener('click', () => leaveTutorialThen(showAbilities));
    return;
  }

  if (key === 'shield') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Scudo</div>
        ${goHome}
        <div class="muted">
          Lo Scudo ti protegge dalle sfide tra eroi. Finch√© √® attivo non puoi essere sfidato e non puoi sfidare altri eroi.
          Puoi comunque fare missioni, dungeon e torre delle prove.
          Hai <strong>30 scudi</strong> disponibili ogni mese e ogni scudo dura <strong>5 ore</strong>.
        </div>
      </div>
    `);
    return;
  }

  if (key === 'power') {
    set(`
      <div class="traits-block tutorial-card">
        <div class="title">Potenza</div>
        ${goHome}
        <div class="muted">
          La potenza √® una delle cose pi√π importanti nel mondo di Mitharia: cresce con equipaggiamento, EXP eroe,
          EXP creatura e abilit√†. Una potenza maggiore ti permette di affrontare sfide sempre pi√π difficili.
          <div style="margin-top:8px; font-weight:900; text-transform:uppercase;">
            La salute influenza la tua potenza, ricaricala spesso!
          </div>
        </div>
      </div>
    `);
    return;
  }

  // fallback
  set(`
    <div class="traits-block tutorial-card">
      <div class="title">Tutorial</div>
      ${goHome}
      <div class="muted">Sezione non disponibile.</div>
    </div>
  `);
}

function showMissions() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('missions').classList.remove('hidden');

  // ‚úÖ Prima completa eventuali missioni scadute (cos√¨ contano per il giorno in cui sono finite)
  try { if (typeof resumeMissionIfNeeded === 'function') resumeMissionIfNeeded(); } catch (_) {}

  // Poi i reset (giornaliero e settimanale)
  try { if (typeof resetDailyQuestsIfNeeded === 'function') resetDailyQuestsIfNeeded(); } catch (_) {}
  try { if (typeof resetWeeklyQuestsIfNeeded === 'function') resetWeeklyQuestsIfNeeded(); } catch (_) {}

  // Aggiorna layout Missioni/Quest (CREA il badge qui)
  upgradeMissionsLayout();
  setMissionsTab('daily'); // default

  // Ora che il badge ESISTE, aggiornalo
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

  renderMissionsUI();
  startMissionTick();
}

// Crea i tab "Missioni giornaliere" / "Quest" una sola volta e sposta dentro l'UI attuale
function upgradeMissionsLayout() {
  const root = document.getElementById('missions'); // root della pagina Missioni
  if (!root || root.dataset.upgraded === '1') return;

  // 1) Crea la barra tab
  const tabbar = document.createElement('div');
  tabbar.id = 'missions-tabbar';
  tabbar.className = 'missions-tabbar';
  // layout inline (cos√¨ non dipende da vecchi CSS)
  tabbar.style.display = 'flex';
  tabbar.style.gap = '8px';
  tabbar.style.marginBottom = '10px';

  tabbar.innerHTML = `
  <button id="btn-tab-main" class="tab-button">
  Quest principali <span id="main-badge" class="dot hidden"></span>
</button>
  <button id="btn-tab-quests" class="tab-button">Quest giornaliere <span id="quests-badge" class="dot hidden"></span></button>
  <button id="btn-tab-weekly" class="tab-button">Quest settimanali <span id="weekly-badge" class="dot hidden"></span></button>
`;
// Barra inferiore: solo "Missioni giornaliere"
const tabbarBottom = document.createElement('div');
tabbarBottom.id = 'missions-tabbar-bottom';
tabbarBottom.className = 'missions-tabbar';
tabbarBottom.style.display = 'flex';
tabbarBottom.style.gap = '8px';
tabbarBottom.style.margin = '0 0 10px 0';

tabbarBottom.innerHTML = `
  <button id="btn-tab-daily" class="tab-button active">Missioni giornaliere</button>
`;


  // 2) Contenitori tab
  const daily  = document.createElement('div');
  daily.id = 'missions-tab-daily';

const main = document.createElement('div');
main.id = 'missions-tab-main';
main.classList.add('hidden');
main.innerHTML = `
  <div class="traits-block">
    <div class="title">Quest principali</div>

    <div class="traits-grid" style="grid-template-columns:1fr;">
      <div class="muted">Al momento non ci sono quest principali attive.</div>
    </div>

    <!-- üîô Pulsante Torna indietro (uguale agli altri) -->
    <div class="back-button-container">
      <button type="button" id="main-quests-back-btn">Torna indietro</button>
    </div>
  </div>
`;

  const quests = document.createElement('div');
  quests.id = 'missions-tab-quests';
  quests.classList.add('hidden'); // parte nascosto
  quests.innerHTML = `
    <div class="traits-block">
      <div class="title">Quest giornaliere</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div class="muted">Nessuna quest disponibile al momento.</div>
      </div>
    </div>
  `;
const weekly = document.createElement('div');
weekly.id = 'missions-tab-weekly';
weekly.classList.add('hidden');
weekly.innerHTML = `
  <div class="traits-block">
    <div class="title">Quest settimanali</div>

    <div class="traits-grid" style="grid-template-columns:1fr;">
      <div id="weekly-quests-list">
        <div class="muted">Nessuna quest disponibile al momento.</div>
      </div>
    </div>

    <!-- üîô Pulsante Torna indietro (stesso stile delle giornaliere) -->
    <div class="back-button-container">
      <button type="button" id="weekly-quests-back-btn">Torna indietro</button>
    </div>
  </div>
`;

// Handler "Torna indietro" (stesso identico del weekly)
const mainBackBtn = main.querySelector('#main-quests-back-btn');
if (mainBackBtn && !mainBackBtn._bound) {
  mainBackBtn._bound = true;
  mainBackBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();

    if (typeof stopEnergyTicker === 'function') stopEnergyTicker();

    if (typeof backToMenuFromMissions === 'function') {
      backToMenuFromMissions();
    } else {
      document.getElementById('missions')?.classList.add('hidden');
      document.getElementById('menu')?.classList.remove('hidden');
    }
  });
}

// Handler identico a quello delle "Quest giornaliere"
const weeklyBackBtn = weekly.querySelector('#weekly-quests-back-btn');
if (weeklyBackBtn && !weeklyBackBtn._bound) {
  weeklyBackBtn._bound = true;
  weeklyBackBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();

    // stoppa eventuale countdown energia (coerente con giornaliere)
    if (typeof stopEnergyTicker === 'function') stopEnergyTicker();

    // torna alla schermata principale (stessa funzione delle giornaliere)
    if (typeof backToMenuFromMissions === 'function') {
      backToMenuFromMissions();
    } else {
      // fallback di sicurezza
      document.getElementById('missions')?.classList.add('hidden');
      document.getElementById('menu')?.classList.remove('hidden');
    }
  });
}


  // 3) Sposta TUTTO il contenuto attuale di #missions dentro "daily"
  const fragment = document.createDocumentFragment();
  Array.from(root.childNodes).forEach(node => {
    // sposta solo nodi utili (elementi/testo), ignora commenti
    if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
      fragment.appendChild(node);
    }
  });
  daily.appendChild(fragment);

  // 4) Monta: barra alta, barra bassa (sotto), poi i contenitori
root.appendChild(tabbar);
root.appendChild(tabbarBottom);
root.appendChild(main);
root.appendChild(quests);
root.appendChild(weekly);
root.appendChild(daily);

// Aggiorna il tab "Quest principali" quando cambiano i dati (es. livello)
window.addEventListener('storage', () => {
  const missions = document.getElementById('missions');
  const mainVisible = !document.getElementById('missions-tab-main')?.classList.contains('hidden');
  if (missions && !missions.classList.contains('hidden') && mainVisible) {
    if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI();
  }
});

  // 5) Hook tab
document.getElementById('btn-tab-main')
  .addEventListener('click', () => setMissionsTab('main'));
document.getElementById('btn-tab-quests')
  .addEventListener('click', () => setMissionsTab('quests'));
document.getElementById('btn-tab-weekly')
  .addEventListener('click', () => setMissionsTab('weekly'));
document.getElementById('btn-tab-daily')
  .addEventListener('click', () => setMissionsTab('daily'));

  root.dataset.upgraded = '1';
  // ‚úÖ AGGIUNTA: ora il badge esiste di sicuro
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

// Mostra il tab richiesto
function setMissionsTab(tab) {
  const main    = document.getElementById('missions-tab-main');
  const daily   = document.getElementById('missions-tab-daily');
  const quests  = document.getElementById('missions-tab-quests');
  const weekly  = document.getElementById('missions-tab-weekly');

  const bMain   = document.getElementById('btn-tab-main');
  const bDaily  = document.getElementById('btn-tab-daily');
  const bQuest  = document.getElementById('btn-tab-quests');
  const bWeekly = document.getElementById('btn-tab-weekly');
  if (!main || !daily || !quests || !weekly || !bMain || !bDaily || !bQuest || !bWeekly) return;

  const isMain   = (tab === 'main');
  const isDaily  = (tab === 'daily');
  const isQuests = (tab === 'quests');
  const isWeekly = (tab === 'weekly');

  main.classList.toggle('hidden',   !isMain);
  daily.classList.toggle('hidden',  !isDaily);
  quests.classList.toggle('hidden', !isQuests);
  weekly.classList.toggle('hidden', !isWeekly);

  bMain.classList.toggle('active',   isMain);
  bDaily.classList.toggle('active',  isDaily);
  bQuest.classList.toggle('active',  isQuests);
  bWeekly.classList.toggle('active', isWeekly);

  if (isDaily && typeof renderMissionsUI === 'function') {
    renderMissionsUI();
  }
  if (isQuests) {
    if (typeof resetDailyQuestsIfNeeded === 'function') resetDailyQuestsIfNeeded();
    renderQuestsUI();              // giornaliere
  }
  if (isWeekly) {
    if (typeof resetWeeklyQuestsIfNeeded === 'function') resetWeeklyQuestsIfNeeded();
    renderWeeklyQuestsUI();        // settimanali
  }
    if (isMain) {
  if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI(); // ‚Üê QUEST PRINCIPALI
}
}

function showChallenges() {
  // Mostra la sezione (senza limitazione missione attiva)
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('challenges').classList.remove('hidden');
// üîÑ RESET vista "Ultime sfide" quando rientro in Sfide e Dungeon
{
  // titolo grande
  const bigTitle = document.querySelector('#challenges > h2');
  if (bigTitle) bigTitle.textContent = 'Sfide e Dungeon';

window._pvpHistQuery = '';

  // nascondi/azzera la vista storico
  const hist = document.getElementById('pvp-history-view');
  if (hist) { hist.classList.add('hidden'); hist.innerHTML = ''; }

  // ri-mostra tabbar e tab Sfide
  const tabbar = document.getElementById('challenges-tabbar');
  const tabSfide = document.getElementById('challenges-tab-sfide');
  if (tabbar) tabbar.classList.remove('hidden');
  if (tabSfide) tabSfide.classList.remove('hidden');

  // ri-mostra i pulsanti piccoli sotto al titolo
  ['challenges-benefits-btn','challenges-personal-btn','challenges-history-btn'].forEach(id=>{
    const btn = document.getElementById(id);
    if (btn && btn.parentElement) btn.parentElement.style.display = '';
  });
}

  // Prepara layout a tab (una sola volta)
  upgradeChallengesLayout();

  // Reset ricerca e salta direttamente alla mia pagina in classifica
if (window.sfideState) {
  // (opzionale ma consigliato) assicura che il mio eroe sia presente/aggiornato in directory
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    try { upsertCurrentHeroIntoDirectory(); } catch (_) {}
  }
  sfideState.query = '';
  sfideState.page = getMySfidePage();  // üëà eccola
}

  const searchInput = document.getElementById('sfide-search');
  if (searchInput) searchInput.value = '';

  // Tab di default: "Sfide"
  setChallengesTab('sfide');
  // niente renderDungeonList qui: verr√† fatto quando entri nel tab Dungeon
}
// --- Tab "Sfide" / "Dungeon" (UI base + primo contenuto dungeon) ---
let _challengesLayoutReady = false;

function upgradeChallengesLayout() {
  if (_challengesLayoutReady) return;
  _challengesLayoutReady = true;

  const root = document.getElementById('challenges-root');
  if (!root) return;

  // Barra tab
  const tabbar = document.createElement('div');
  tabbar.id = 'challenges-tabbar';
  tabbar.className = 'tabbar';
  tabbar.style.display = 'flex';
  tabbar.style.gap = '8px';
  tabbar.style.flexWrap = 'nowrap';
    tabbar.innerHTML = `
    <button id="btn-tab-sfide" class="tab-button active">Sfide PVP</button>
    <button id="btn-tab-dungeon" class="tab-button">Dungeon</button>
    <button id="btn-tab-tower" class="tab-button">Torre delle Prove</button>
  `;


  // Contenitori
  const sfide  = document.createElement('div');
  sfide.id = 'challenges-tab-sfide';
  sfide.innerHTML = `
    <div class="traits-block sfide-compact">
      <div class="title">Sfide</div>

<!-- ENERGIA SFIDE -->
<div id="sfide-energy">
  <div class="label">Barra energia</div>
  <div class="bar"><div class="fill" id="sfide-energy-fill"></div></div>
  <div class="meta" id="sfide-energy-meta">0/20</div>
</div>

      <!-- BARRA RICERCA -->
      <div style="margin:8px 0;">
        <input id="sfide-search" type="text" placeholder="Cerca per nome..." style="width:100%; padding:8px; box-sizing:border-box;">
      </div>

      <!-- TABELLA CLASSIFICA -->
      <div class="table-wrap">
        <table class="hero-table">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Tag</th>
              <th>Nome</th>
              <th>Livello</th>
              <th>Punti</th>
              <th style="width:1%;">&nbsp;</th>
            </tr>
          </thead>
          <tbody id="sfide-body">
            <!-- righe generate via JS -->
          </tbody>
        </table>
      </div>

      <!-- PAGINAZIONE (senza contatore centrale) -->
      <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
        <button id="sfide-prev" class="mini-button">Pagina precedente</button>
        <button id="sfide-next" class="mini-button">Pagina successiva</button>
      </div>
    </div>
  `;

  const dungeon = document.createElement('div');
  dungeon.id = 'challenges-tab-dungeon';
  dungeon.classList.add('hidden');
  dungeon.innerHTML = `
    <div class="traits-block">
      <div class="title">Dungeon</div>

      <!-- ENERGIA -->
      <div id="dungeon-energy">
        <div class="label">Barra energia</div>
        <div class="bar"><div class="fill" id="dungeon-energy-fill"></div></div>
        <div class="meta" id="dungeon-energy-meta">0/20</div>
      </div>

      <div id="dungeon-list" class="traits-grid" style="grid-template-columns:1fr;"></div>
    </div>
  `;

  const tower = document.createElement('div');
  tower.id = 'challenges-tab-tower';
  tower.classList.add('hidden');
  tower.innerHTML = `
    <div class="traits-block">
      <div class="title">Torre delle Prove</div>

      <div id="tower-hero-power" class="muted" style="margin-bottom:4px;"></div>
      <div id="tower-daily-counter" class="muted" style="margin-bottom:8px;"></div>

      <div id="tower-list" class="traits-grid" style="grid-template-columns:1fr;"></div>

      <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
        <button id="tower-prev" class="mini-button">Pagina precedente</button>
        <button id="tower-next" class="mini-button">Pagina successiva</button>
      </div>
    </div>
  `;

  root.innerHTML = '';
  root.appendChild(tabbar);

  // Pulsante "Benefici" sotto i tab (stile come ‚Üê Indietro)
  const benRow = document.createElement('div');
  benRow.style.margin = '8px 0 10px';
  benRow.innerHTML = `<button class="mini-button mini-button--dark" id="challenges-benefits-btn">Benefici gilda</button>`;
  root.appendChild(benRow);

  if (typeof hasAnyPersonalBonusActive==='function' && hasAnyPersonalBonusActive()){
    const pBtn = document.createElement('button');
    pBtn.className = 'mini-button mini-button--dark';
    pBtn.id = 'challenges-personal-btn';
    pBtn.textContent = 'Bonus personali';
    benRow.appendChild(pBtn);
    pBtn.addEventListener('click', ()=> renderPersonalBonuses('challenges'));
  }

  root.appendChild(sfide);
  root.appendChild(dungeon);
  root.appendChild(tower);


// --- Bottone "Ultime sfide" (sopra al Men√π principale) ---
const histRow = document.createElement('div');
histRow.style.margin = '8px 0 10px';
histRow.innerHTML = `
  <button class="mini-button mini-button--dark" id="challenges-history-btn">Ultime sfide</button>
`;
root.appendChild(histRow);

// --- Contenitore della vista "Ultime sfide" (non popup, inizialmente nascosta) ---
const histView = document.createElement('div');
histView.id = 'pvp-history-view';
histView.className = 'hidden';
root.appendChild(histView);

document.getElementById('challenges-history-btn')?.addEventListener('click', () => {
  renderPvpHistoryWindow(0); // pagina 1 (indice 0)
});

  document.getElementById('challenges-benefits-btn')
    ?.addEventListener('click', () => renderActiveBonuses('challenges'));

  // Eventi tab
    document.getElementById('btn-tab-sfide').addEventListener('click', () => {
    setChallengesTab('sfide');
  });

  document.getElementById('btn-tab-dungeon').addEventListener('click', () => {
    setChallengesTab('dungeon');
    renderDungeonList(); // assicura refresh lista + energia
  });

  const towerBtn = document.getElementById('btn-tab-tower');
  if (towerBtn) {
    towerBtn.addEventListener('click', () => {
      setChallengesTab('tower');
    });
  }

  const towerPrev = document.getElementById('tower-prev');
  const towerNext = document.getElementById('tower-next');
  if (towerPrev && towerNext) {
    towerPrev.addEventListener('click', () => {
      if (window.towerState.page > 1) {
        window.towerState.page--;
        renderTowerList();
      }
    });
    towerNext.addEventListener('click', () => {
      const totalPages = Math.ceil(TOWER_LEVELS.length / TOWER_PAGE_SIZE);
      if (window.towerState.page < totalPages) {
        window.towerState.page++;
        renderTowerList();
      }
    });
  }
}


// === Sfide: stato e costanti ===
const SFIDE_PAGE_SIZE = 20;
window.sfideState = window.sfideState || { page: 1, query: '' };

// Calcola a quale pagina (da 1) si trova il mio eroe in classifica (20 per pagina)
function getMySfidePage() {
  try {
    const me = (typeof currentUser === 'string') ? currentUser : null;
    if (!me) return 1;

    const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
    // Ordina come fa la tab "Sfide": per punti decrescente
    const sorted = dir.slice().sort((a, b) => (Number(b.points || 0) - Number(a.points || 0)));
    const idx = sorted.findIndex(h => h && h.name === me);
    if (idx < 0) return 1;

    // 0..19 -> pag1, 20..39 -> pag2, ecc.
    return Math.floor(idx / SFIDE_PAGE_SIZE) + 1;
  } catch (_) {
    return 1;
  }
}

// Abilita UI e binding per la tab Sfide (una sola volta)
function setupSfideInteractions(){
  const input = document.getElementById('sfide-search');
  if (input && !input._bound) {
    input._bound = true;
    input.addEventListener('input', () => {
      sfideState.query = (input.value || '').trim().toLowerCase();
      sfideState.page = 1;
      renderSfideList();
    });
  }
  const prev = document.getElementById('sfide-prev');
  const next = document.getElementById('sfide-next');
  if (prev && !prev._bound) {
    prev._bound = true;
    prev.addEventListener('click', () => {
      if (sfideState.page > 1) { sfideState.page--; renderSfideList(); }
    });
  }
  if (next && !next._bound) {
    next._bound = true;
    next.addEventListener('click', () => {
      const dir = getHeroDirectory() || [];
      const filtered = filterHeroes(dir, sfideState.query);
      const totalPages = Math.max(1, Math.ceil(filtered.length / SFIDE_PAGE_SIZE));
      if (sfideState.page < totalPages) { sfideState.page++; renderSfideList(); }
    });
  }
}
// Filtro per nome (riuso lo stesso della Sala degli Eroi)
function filterHeroes(list, query) {
  if (!query) return list;
  return list.filter(h => (h.name || '').toLowerCase().includes(query));
}

// Trova gilda di un utente (id e tag) scorrendo i registri gilda
function findGuildOfUser(username){
  try {
    const all = (typeof getGuilds === 'function') ? getGuilds() : {};
    for (const gid of Object.keys(all)) {
      const members = (typeof getGuildMembers === 'function') ? getGuildMembers(gid) : [];
      if (members.some(m => m && m.user === username)) {
        return { id: gid, tag: all[gid]?.tag || '' };
      }
    }
  } catch(e){}
  return { id: null, tag: '' };
}

// Rende/aggiorna la lista ‚ÄúSfide‚Äù
function renderSfideList(){
  const body = document.getElementById('sfide-body');
  if (!body) return;

  const prevBtn = document.getElementById('sfide-prev');
  const nextBtn = document.getElementById('sfide-next');

  // prendi directory e arricchisci con tag gilda se manca
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const augmented = dir.map(h => {
    if (!h) return h;
    if (!h.tag || h.tag === '') {
      const g = findGuildOfUser(h.name || '');
      if (g.tag) return Object.assign({}, h, { tag: g.tag });
    }
    return h;
  });

  // ORDINE GLOBALE: punti decrescenti + mappa id -> rank
const dirSorted = augmented.slice().sort((a,b)=> Number(b.points||0) - Number(a.points||0));
const rankOf = Object.create(null);
dirSorted.forEach((h,i)=>{ if (h && h.id) rankOf[h.id] = i + 1; });

// Filtro applicato sulla lista ORDINATA (mantiene posizioni globali)
const filtered = filterHeroes(dirSorted, sfideState.query);

  // paginazione
  const total = filtered.length;
  const totalPages = Math.max(1, Math.ceil(total / SFIDE_PAGE_SIZE));
  const cur = Math.min(Math.max(1, sfideState.page), totalPages);
  sfideState.page = cur;

  // mostra/nascondi i bottoni come richiesto
  if (prevBtn) prevBtn.style.display = (cur > 1) ? '' : 'none';
  if (nextBtn) nextBtn.style.display = (cur < totalPages) ? '' : 'none';

  const start = (cur - 1) * SFIDE_PAGE_SIZE;
  const pageItems = filtered.slice(start, start + SFIDE_PAGE_SIZE);

  // mio utente e mia gilda (per bloccare sfide a me stesso / stessa gilda)
  const me = (typeof currentUser === 'string') ? currentUser : '';
  const myGuild = findGuildOfUser(me);

  if (pageItems.length === 0) {
    body.innerHTML = `<tr><td colspan="6" class="muted">Nessun eroe.</td></tr>`;
    return;
  }

  body.innerHTML = pageItems.map((h) => {
  const rank = Number(rankOf[h.id] || 0);

  const g4tag = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { tag: '' };
const tagTxt = g4tag.tag ? `[${escapeHtml(g4tag.tag)}]` : '';

  // --- icona relazione gilda (alleato/guerra) ---
  let tagWithIcon = tagTxt;
  try {
    const myGid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    const opp = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { id: null };
    const oppId = opp && opp.id;
    if (myGid && oppId && typeof areAllied === 'function' && typeof atWar === 'function') {
      if (areAllied(myGid, oppId)) {
        tagWithIcon += ' <span class="ally-icon" title="Alleanza">üïäÔ∏è</span>';
      } else if (atWar(myGid, oppId)) {
        tagWithIcon += ' <span class="war-icon" title="Guerra">‚öîÔ∏è</span>';
      }
    }
  } catch(_) {}

  const name   = escapeHtml(h.name || '');
  const lvl    = Number(h.level || 0);
  const pts    = Number(h.points || 0);

  const isMe     = (h.name === me);
  const oppGuild = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { id: null };
  const sameGuild = !!(myGuild.id && oppGuild.id && myGuild.id === oppGuild.id);

  const B = (s) => isMe ? `<strong>${s}</strong>` : s;

  const actionCell = (!isMe && !sameGuild)
    ? `<button class="mini-button"
               data-id="${escapeHtml(h.id || '')}"
               data-name="${name}"
               onclick="startHeroChallenge(this.getAttribute('data-id'))">Sfida</button>`
    : '';
const shieldOn = (Number(h.shieldEndAt || 0) > Date.now());
const shieldIcon = shieldOn
  ? ' <span title="Scudo attivo" style="text-decoration:none; display:inline-block;">üõ°Ô∏è</span>'
  : '';


  return `
    <tr>
      <td class="muted">${rank})</td>
      <td>${tagWithIcon}</td>
      <td>${B(name + shieldIcon)}</td>
      <td>${B(lvl)}</td>
      <td>${B(pts)}</td>
      <td>${actionCell}</td>
    </tr>
  `;
}).join('');
}

function setChallengesTab(tab) {
  // Nasconde "Ultime sfide" quando NON sono nella tab Sfide
  const historyBtn = document.getElementById('challenges-history-btn');
  if (historyBtn && historyBtn.parentElement) {
    historyBtn.parentElement.style.display = (tab === 'sfide') ? '' : 'none';
  }

  const btnSfide    = document.getElementById('btn-tab-sfide');
  const btnDungeon  = document.getElementById('btn-tab-dungeon');
  const btnTower    = document.getElementById('btn-tab-tower');
  const tabSfide    = document.getElementById('challenges-tab-sfide');
  const tabDungeon  = document.getElementById('challenges-tab-dungeon');
  const tabTower    = document.getElementById('challenges-tab-tower');

  if (!btnSfide || !btnDungeon || !tabSfide || !tabDungeon) return;

  sfideState.page = getMySfidePage();

  // reset classi
  btnSfide.classList.remove('active');
  btnDungeon.classList.remove('active');
  if (btnTower) btnTower.classList.remove('active');

  tabSfide.classList.add('hidden');
  tabDungeon.classList.add('hidden');
  if (tabTower) tabTower.classList.add('hidden');

  if (tab === 'sfide') {
    btnSfide.classList.add('active');
    tabSfide.classList.remove('hidden');

    // üî¥ ferma countdown energia Dungeon
    stopEnergyTicker?.();

    // ‚úÖ Sfide: mostra subito la barra e avvia ticker
    renderSfideEnergyBar?.();
    startSfideEnergyTicker?.();

    // Popola lista Sfide
    setupSfideInteractions?.();
    renderSfideList?.();

  } else if (tab === 'dungeon') {
    btnDungeon.classList.add('active');
    tabDungeon.classList.remove('hidden');

    // üî¥ ferma ticker Sfide
    stopSfideEnergyTicker?.();

    // üü¢ Dungeon: lista + ticker energia
    renderDungeonList?.();
    startEnergyTicker?.();

  } else if (tab === 'tower') {
    if (btnTower && tabTower) {
      btnTower.classList.add('active');
      tabTower.classList.remove('hidden');
    }

    // üî¥ ferma entrambi i ticker energia
    stopEnergyTicker?.();
    stopSfideEnergyTicker?.();

    // Calcola la pagina della prossima sfida da fare
    const maxCleared = (typeof getTowerMaxCleared === 'function') ? getTowerMaxCleared() : 0;
    const nextLevel  = Math.min(200, Math.max(1, maxCleared + 1));

    const totalPages = Math.max(1, Math.ceil(TOWER_LEVELS.length / TOWER_PAGE_SIZE));
    const targetPage = Math.max(1, Math.min(totalPages, Math.ceil(nextLevel / TOWER_PAGE_SIZE)));

    window.towerState = window.towerState || {};
    window.towerState.page = targetPage;

    // Render Torre delle Prove
    renderTowerList?.();
  }

}


// --------- DUNGEON: nemici L1..L20 + limiti tentativi giornalieri ---------

// Genera 20 bot "Scheletro L1" ... (qui puoi cambiare nomi se vuoi)
function getDungeonEnemies() {
  const names = ['Scheletro','Goblin','Orco','Non Morto','Bandito','Lupo','Troll','Spettro','Golem','Stregone'];
  const out = [];
  for (let lvl = 1; lvl <= 20; lvl++) {
    const baseName = names[(lvl-1) % names.length];
    out.push({
      id: 'botL' + lvl,
      name: `${baseName} L${lvl}`,
      level: lvl,
      rewardGold: lvl * 10, // Step 4
      rewardXP: lvl * 3
    });
  }
  return out;
}

// Tentativi consentiti per livello (Step 4: 1‚Äì5:3, 6‚Äì15:2, 16‚Äì20:1)
function attemptsPerLevel(level) {
  if (level <= 5) return 3;
  if (level <= 15) return 2;
  return 1;
}

// Reset giornaliero a mezzanotte: salviamo la data "YYYY-MM-DD" e azzeriamo
function _todayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const dd= String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}

function getDungeonAttemptsState() {
  const state = userStore.get('dungeonAttempts') || { date: _todayKey(), attempts: {} };
  if (state.date !== _todayKey()) {
    state.date = _todayKey();
    state.attempts = {}; // reset a mezzanotte
    userStore.set('dungeonAttempts', state);
  }
  return state;
}
// ======== ENERGIA DUNGEON ========
const ENERGY_MAX = 20;
const ENERGY_REGEN_EVERY_MS = 15 * 60 * 1000; // 15 minuti

function initEnergyIfNeeded() {
  // init valori base
  if (typeof userStore.get('energy') !== 'number') {
    userStore.set('energy', ENERGY_MAX);
  }
  if (!userStore.get('energyLastRegen')) {
    userStore.set('energyLastRegen', Date.now());
  }

  // ‚úÖ reset giornaliero a mezzanotte: energia piena
  const today = _todayKey();
  const lastReset = userStore.get('energyDailyReset');
  if (lastReset !== today) {
    userStore.set('energy', ENERGY_MAX);
    userStore.set('energyLastRegen', Date.now());
    userStore.set('energyDailyReset', today);
  }
}


// +1 energia ogni 15 minuti (fino a max)
function regenEnergyIfNeeded() {
  initEnergyIfNeeded();
  const now = Date.now();
  let energy = userStore.get('energy');
  let last = userStore.get('energyLastRegen');

  if (energy >= ENERGY_MAX) {
    // pieno: aggiorna solo il timestamp per evitare accumulo
    userStore.set('energyLastRegen', now);
    return;
  }

  const elapsed = now - last;
  if (elapsed >= ENERGY_REGEN_EVERY_MS) {
    const gained = Math.floor(elapsed / ENERGY_REGEN_EVERY_MS);
    energy = Math.min(ENERGY_MAX, energy + gained);
    // avanza il "last" della quantit√† usata (evitiamo drift)
    last += gained * ENERGY_REGEN_EVERY_MS;
    userStore.set('energy', energy);
    userStore.set('energyLastRegen', last);
  }
}

function getEnergy() {
  regenEnergyIfNeeded();
  return userStore.get('energy') || 0;
}

function setEnergy(val, opts = {}) {
  const v = Math.max(0, Math.min(ENERGY_MAX, Number(val) || 0));
  userStore.set('energy', v);
  // ‚õîÔ∏è NON resettare il timer di rigenerazione, a meno che non venga richiesto
  if (opts.resetTimer === true) {
    userStore.set('energyLastRegen', Date.now());
  }
  renderEnergyBar();
}

// costo per livello
function energyCostForLevel(level) {
  if (level <= 5) return 2;
  if (level <= 10) return 3;
  if (level <= 15) return 4;
  return 5; // 16-20
}

// UI barra energia
function renderEnergyBar() {
  const energy = getEnergy(); // rigenera anche
  const fill = document.getElementById('dungeon-energy-fill');
  const meta = document.getElementById('dungeon-energy-meta');
  const pct = Math.round((energy / ENERGY_MAX) * 100);

  if (fill) {
    fill.style.width = pct + '%';
    // reset classi colore
    fill.classList.remove('yellow', 'red');
    if (pct < 15) {
      fill.classList.add('red');
    } else if (pct < 30) {
      fill.classList.add('yellow');
    }
  }

  if (meta) {
    let text = `Energia: ${energy}/${ENERGY_MAX} ‚ö°`;

    if (energy < ENERGY_MAX) {
      const last = userStore.get('energyLastRegen') || Date.now();
      const nextAt = last + ENERGY_REGEN_EVERY_MS;
      const diffMs = Math.max(0, nextAt - Date.now());
      const mins = Math.floor(diffMs / 60000);
      const secs = Math.floor((diffMs % 60000) / 1000);
      const mm = String(mins).padStart(2,'0');
      const ss = String(secs).padStart(2,'0');

      text += `<br><span class="regen-timer">+1 energia ‚ö° fra ${mm}:${ss}</span>`;
    }

    // usa innerHTML per supportare <br>
    meta.innerHTML = text;
  }
}

function incDungeonAttempt(enemyId) {
  const state = getDungeonAttemptsState();
  state.attempts[enemyId] = (state.attempts[enemyId] || 0) + 1;
  userStore.set('dungeonAttempts', state);
}

function attemptsUsed(enemyId) {
  const state = getDungeonAttemptsState();
  return state.attempts[enemyId] || 0;
}

// === TORRE DELLE PROVE ======================================================

const TOWER_PAGE_SIZE = 10;
const TOWER_DAILY_MAX = 5;

// Stato pagina Torre
window.towerState = window.towerState || { page: 1 };

// Costruisce la chiave data "YYYY-MM-DD" (esiste gi√† _todayKey per dungeon)
function _towerTodayKey() {
  if (typeof _todayKey === 'function') return _todayKey();
  return new Date().toISOString().slice(0, 10);
}

// Tentativi giornalieri Torre (5 al giorno, globali per la torre)
function getTowerAttemptsState() {
  const today = _towerTodayKey();
  let st = userStore.get('towerAttempts') || { date: today, used: 0 };
  if (st.date !== today) {
    st = { date: today, used: 0 };
  }
  userStore.set('towerAttempts', st);
  return st;
}
function getTowerAttemptsUsed() {
  const st = getTowerAttemptsState();
  return Number(st.used || 0);
}
function incTowerAttempt() {
  const st = getTowerAttemptsState();
  st.used = Number(st.used || 0) + 1;
  userStore.set('towerAttempts', st);
}

// Livello massimo completato (0 = nessun livello)
function getTowerMaxCleared() {
  return Number(userStore.get('towerMaxCleared') || 0);
}
function setTowerMaxCleared(level) {
  const cur = getTowerMaxCleared();
  const lv = Number(level || 0);
  if (lv > cur) userStore.set('towerMaxCleared', lv);
}

// --- Definizione livelli (1..200) ---
// Ogni entry: { level, enemyType, count, isBoss, name, power }

function buildTowerLevels() {
  const out = {};

  function addWave(startLevel, enemyType, perPower, labelSuffix = '') {
    for (let i = 1; i <= 9; i++) {
      const lvl = startLevel + (i - 1);
      const suffix = labelSuffix || '';
      out[lvl] = {
        level: lvl,
        enemyType,
        count: i,
        isBoss: false,
        name: `${enemyType}${suffix} x${i}`,
        power: i * perPower
      };
    }
  }
  function addBoss(level, name, power) {
    out[level] = {
      level,
      enemyType: 'Boss',
      count: 1,
      isBoss: true,
      name,
      power
    };
  }

  // ‚Äî Ciclo 1 (1‚Äì100) ‚Äî
  addWave(1,  'Scheletro',  500);
  addBoss(10,  'Signore delle Ossa', 5000);

  addWave(11, 'Goblin',    1500);
  addBoss(20,  'Re dei Goblin', 15000);

  addWave(21, 'Orco',      3000);
  addBoss(30,  'Condottiero degli Orchi', 30000);

  addWave(31, 'Non Morto', 5000);
  addBoss(40,  'Signore dei Non Morti', 50000);

  addWave(41, 'Bandito',   10000);
  addBoss(50,  'Capobanda delle Lame Nere', 100000);

  addWave(51, 'Lupo',      20000);
  addBoss(60,  'Alfa dei Lupi', 200000);

  addWave(61, 'Troll',     40000);
  addBoss(70,  'Re dei Troll di Pietra', 400000);

  addWave(71, 'Spettro',   80000);
  addBoss(80,  'Re degli Spettri', 800000);

  addWave(81, 'Golem',     130000);
  addBoss(90,  'Titano di Pietra', 1300000);

  addWave(91, 'Stregone',  195000);
  addBoss(100, 'Arcistregone del Vuoto', 1950000);

  // ‚Äî Ciclo 2 (101‚Äì200, potenziati) ‚Äî
  function addWave2(startLevel, enemyType, perPower) {
    addWave(startLevel, enemyType, perPower, ' potenziato');
  }

  addWave2(101, 'Scheletro', 290000);
  addBoss(110, 'Signore delle Ossa supremo', 2900000);

  addWave2(111, 'Goblin',   440000);
  addBoss(120, 'Re dei Goblin supremo', 4400000);

  addWave2(121, 'Orco',     660000);
  addBoss(130, 'Condottiero degli Orchi supremo', 6600000);

  addWave2(131, 'Non Morto', 990000);
  addBoss(140, 'Signore dei Non Morti supremo', 9900000);

  addWave2(141, 'Bandito', 1500000);
  addBoss(150, 'Capobanda delle Lame Nere supremo', 15000000);

  addWave2(151, 'Lupo',    2200000);
  addBoss(160, 'Alfa dei Lupi supremo', 22000000);

  addWave2(161, 'Troll',   3300000);
  addBoss(170, 'Re dei Troll di Pietra supremo', 33000000);

  addWave2(171, 'Spettro', 5000000);
  addBoss(180, 'Re degli Spettri supremo', 50000000);

  addWave2(181, 'Golem',   7500000);
  addBoss(190, 'Titano di Pietra supremo', 75000000);

  addWave2(191, 'Stregone',11500000);
  addBoss(200, 'Arcistregone del Vuoto supremo', 115000000);

  const arr = [];
  for (let lvl = 1; lvl <= 200; lvl++) {
    arr.push(out[lvl]);
  }
  return arr;
}

// === Ricompense Torre delle Prove ===========================================
// TOWER_REWARDS[level] = { gold, arcaneDust, potionId, potionQty, crystalParts, crystals, keyId, keyQty }

function buildTowerRewards() {
  const rewards = {};

  function ensure(level) {
    if (!rewards[level]) rewards[level] = {};
    return rewards[level];
  }

  function merge(base, src) {
    if (!src) return;
    if (src.gold)       base.gold       = (base.gold || 0) + src.gold;
    if (src.arcaneDust) base.arcaneDust = (base.arcaneDust || 0) + src.arcaneDust;
    if (src.crystalParts) base.crystalParts = (base.crystalParts || 0) + src.crystalParts;
    if (src.crystals)     base.crystals     = (base.crystals || 0) + src.crystals;
    if (src.potionId) {
      base.potionId  = src.potionId;
      base.potionQty = (base.potionQty || 0) + (src.potionQty || 1);
    }
  }

  const base1 = {
    1: { potionId: 'pot_small',  potionQty: 4 },         // 4 poz. salute piccola
    2: { crystalParts: 1 },                              // 1 frammento
    3: { potionId: 'pot_medium', potionQty: 4 },         // 4 poz. salute media
    4: { arcaneDust: 10 },                               // 10 polvere arcana
    5: { gold: 5000 },                                   // 5000 oro
    6: { potionId: 'pot_large', potionQty: 4 },          // 4 poz. salute grande
    7: { crystals: 1 },                                  // 1 cristallo pieno
    8: { potionId: 'pot_extra', potionQty: 4 },          // 4 poz. salute extra
    9: { gold: 10000 }                                   // 10000 oro
  };

  const base2 = {
    1: { potionId: 'pot_small',  potionQty: 8 },         // 8 poz. salute piccola
    2: { crystalParts: 3 },                              // 3 frammenti
    3: { potionId: 'pot_medium', potionQty: 8 },         // 8 poz. salute media
    4: { arcaneDust: 25 },                               // 25 polvere arcana
    5: { gold: 10000 },                                  // 10000 oro
    6: { potionId: 'pot_large', potionQty: 8 },          // 8 poz. salute grande
    7: { crystals: 3 },                                  // 3 cristalli pieni
    8: { potionId: 'pot_extra', potionQty: 8 },          // 8 poz. salute extra
    9: { gold: 15000 }                                   // 15000 oro
  };

  // Livelli 1‚Äì99 (esclusi multipli di 10: 10,20,...,90,100)
  for (let lvl = 1; lvl <= 99; lvl++) {
    if (lvl % 10 === 0) continue; // i boss hanno solo chiave
    const idx = ((lvl - 1) % 10) + 1; // 1..10
    if (idx >= 1 && idx <= 9) {
      const base = base1[idx];
      if (base) merge(ensure(lvl), base);
    }
  }

  // Livelli 101‚Äì199 (esclusi multipli di 10: 110,120,...,190,200)
  for (let lvl = 101; lvl <= 199; lvl++) {
    if (lvl % 10 === 0) continue;
    const idx = ((lvl - 1) % 10) + 1;
    if (idx >= 1 && idx <= 9) {
      const base = base2[idx];
      if (base) merge(ensure(lvl), base);
    }
  }

  // Chiavi speciali
  // 10,20,30,40,50: chiave del Mercante (ottone)
  [10, 20, 30, 40, 50].forEach(lvl => {
    const r = ensure(lvl);
    r.keyId  = 'ottone';
    r.keyQty = (r.keyQty || 0) + 1;
  });

  // 60,70,80,90,100: chiave dell‚ÄôAvventuriero (argento)
  [60, 70, 80, 90, 100].forEach(lvl => {
    const r = ensure(lvl);
    r.keyId  = 'argento';
    r.keyQty = (r.keyQty || 0) + 1;
  });

  // 110,120,130,140,150: chiave del Re (oro)
  [110, 120, 130, 140, 150].forEach(lvl => {
    const r = ensure(lvl);
    r.keyId  = 'oro';
    r.keyQty = (r.keyQty || 0) + 1;
  });

  // 160,170,180,190,200: chiave Arcana (runica)
  [160, 170, 180, 190, 200].forEach(lvl => {
    const r = ensure(lvl);
    r.keyId  = 'runica';
    r.keyQty = (r.keyQty || 0) + 1;
  });

  return rewards;
}

// Tabelle precalcolate
const TOWER_LEVELS  = buildTowerLevels();
const TOWER_REWARDS = buildTowerRewards();

function formatTowerPower(n) {
  const num = Number(n) || 0;
  // Riutilizza formatGold se esiste (stesso stile con il puntino)
  if (typeof formatGold === 'function') {
    return formatGold(num);
  }
  // Fallback: formattazione italiana
  return num.toLocaleString('it-IT');
}

// Accredita una ricompensa Torre
function grantTowerReward(level) {
  const r = TOWER_REWARDS[level];
  if (!r) return;

  // Oro
  if (Number(r.gold || 0) > 0 && typeof addNum === 'function') {
    addNum('gold', Number(r.gold || 0));
    if (typeof updateGoldBadges === 'function') updateGoldBadges();
  }

  // Polvere arcana
  if (Number(r.arcaneDust || 0) > 0 && typeof addArcaneDust === 'function') {
    addArcaneDust(Number(r.arcaneDust || 0));
    if (typeof updateDustBadges === 'function') updateDustBadges();
  }

  // Frammenti di cristallo
  if (Number(r.crystalParts || 0) > 0 && typeof addNum === 'function') {
    addNum('crystalParts', Number(r.crystalParts || 0));
  }

  // Cristalli completi
  if (Number(r.crystals || 0) > 0 && typeof addNum === 'function') {
    addNum('crystals', Number(r.crystals || 0));
  }

  // Pozioni
  if (r.potionId && typeof addPotion === 'function') {
    const q = Number(r.potionQty || 1);
    if (q > 0) addPotion(r.potionId, q);
  }

  // Chiavi
  if (r.keyId && typeof addKey === 'function') {
    const q = Number(r.keyQty || 1);
    if (q > 0) addKey(r.keyId, q);
  }
}

function renderTowerList() {
  const listEl    = document.getElementById('tower-list');
  const powerEl   = document.getElementById('tower-hero-power');
  const counterEl = document.getElementById('tower-daily-counter');
  const prevBtn   = document.getElementById('tower-prev');
  const nextBtn   = document.getElementById('tower-next');
  if (!listEl || !powerEl || !counterEl || !prevBtn || !nextBtn) return;

  const heroPower = (typeof getHeroPower === 'function') ? getHeroPower() : 0;
  powerEl.innerHTML = `<strong>Potenza eroe:</strong> ${heroPower}`;

  const used = getTowerAttemptsUsed();
  const left = Math.max(0, TOWER_DAILY_MAX - used);
  counterEl.innerHTML = `Sfide giornaliere Torre: ${used}/${TOWER_DAILY_MAX}`;

  const totalPages = Math.max(1, Math.ceil(TOWER_LEVELS.length / TOWER_PAGE_SIZE));
  let page = Number(window.towerState.page || 1);
  if (page < 1) page = 1;
  if (page > totalPages) page = totalPages;
  window.towerState.page = page;

  const start = (page - 1) * TOWER_PAGE_SIZE;
  const slice = TOWER_LEVELS.slice(start, start + TOWER_PAGE_SIZE);

  const maxCleared = getTowerMaxCleared();

  listEl.innerHTML = slice.map((lvl, idx) => {
    const level      = lvl.level;
    const isCleared  = (maxCleared >= level);
    const unlocked   = (level <= maxCleared + 1);
    const reward     = TOWER_REWARDS[level] || null;
    const neededPower = Math.ceil(lvl.power * 1.08); // +8% per vincere

    let rewardText = '';
    if (isCleared) {
      rewardText = '<span class="muted">Ricompensa ritirata</span>';
    } else if (!reward) {
      rewardText = '<span class="muted">‚Äî</span>';
    } else {
      const parts = [];
      if (reward.gold) {
        parts.push(`${formatGold ? formatGold(reward.gold) : reward.gold} oro`);
      }
      if (reward.arcaneDust) {
        parts.push(`${reward.arcaneDust} Polvere arcana`);
      }
      if (reward.potionId) {
        const qty = Number(reward.potionQty || 1);
        const lab = reward.potionId === 'pot_small'
          ? 'Pozione salute piccola'
          : reward.potionId === 'pot_medium'
          ? 'Pozione salute media'
          : reward.potionId === 'pot_large'
          ? 'Pozione salute grande'
          : reward.potionId === 'pot_extra'
          ? 'Pozione salute extra'
          : 'Pozione';
        parts.push(`${qty} ${lab}`);
      }
      if (reward.crystalParts) {
        parts.push(`${reward.crystalParts} frammento${reward.crystalParts > 1 ? 'i' : ''} di cristallo`);
      }
      if (reward.crystals) {
        parts.push(`${reward.crystals} cristallo${reward.crystals > 1 ? 'i' : ''} di potenziamento`);
      }
      if (reward.keyId) {
        const qty = Number(reward.keyQty || 1);
        const labKey = reward.keyId === 'ottone'
          ? 'Chiave del Mercante'
          : reward.keyId === 'argento'
          ? 'Chiave dell‚ÄôAvventuriero'
          : reward.keyId === 'oro'
          ? 'Chiave del Re'
          : reward.keyId === 'runica'
          ? 'Chiave Arcana'
          : 'Chiave';
        parts.push(`${qty} ${labKey}`);
      }
      rewardText = parts.length ? parts.join(' + ') : '‚Äî';
    }

    let statusLabel = '';
const attemptsLeft = left;

if (isCleared) {
  statusLabel = '<span class="claimable">Completato</span>';
} else if (!unlocked) {
  statusLabel = '<span class="muted">Bloccato</span>';
} else if (attemptsLeft <= 0) {
  statusLabel = '<span class="muted">Nessuna sfida rimasta oggi</span>';
} else {
  statusLabel = '<span class="claimable">Pronto alla sfida</span>';
}


    const canClick = unlocked && !isCleared && attemptsLeft > 0;

    const btnHtml = canClick
      ? `<button class="mini-button" onclick="startTowerBattle(${level})">Sfida</button>`
      : '';

    const isLast = (idx === slice.length - 1);
    const separatorStyle = isLast
      ? ''
      : 'border-bottom:1px solid rgba(0,0,0,0.12); padding-bottom:6px; margin-bottom:6px;';

       return `
      <div class="trait-card" style="${separatorStyle}">
        <div class="trait-header">
          <div><strong>Livello ${level}</strong> ${lvl.isBoss ? '(Boss)' : ''}</div>
          <div class="muted">${statusLabel}</div>
        </div>
        <div class="trait-body">
          <div>Nemico: <strong>${escapeHtml(lvl.name)}</strong></div>
<div>Potenza mostro: <strong>${formatTowerPower(lvl.power)}</strong></div>
<div>Ricompensa: ${rewardText}</div>
        </div>
        <div class="trait-footer" style="display:flex; justify-content:flex-end; gap:8px; margin-top:6px;">
          ${btnHtml}
        </div>
      </div>
    `;

  }).join('');

  // Paginazione: prima pagina solo "successiva", ultima solo "precedente", in mezzo entrambe
  prevBtn.disabled = (page <= 1);
  nextBtn.disabled = (page >= totalPages);

  prevBtn.style.visibility = (page <= 1) ? 'hidden' : 'visible';
  nextBtn.style.visibility = (page >= totalPages) ? 'hidden' : 'visible';
}

function startTowerBattle(level) {
  const lvlCfg = TOWER_LEVELS.find(l => l.level === level);
  if (!lvlCfg) return;
if (!canStartActionWithHp('la Torre delle Prove')) return;

  const used = getTowerAttemptsUsed();
  if (used >= TOWER_DAILY_MAX) {
    if (typeof showGameMessage === 'function') {
      showGameMessage('Torre delle Prove', 'Hai gi√† usato tutte le 5 sfide giornaliere della Torre per oggi.');
    }
    return;
  }

  const maxCleared = getTowerMaxCleared();
  if (level > maxCleared + 1) {
    showGameMessage?.('Torre delle Prove', 'Devi prima completare il livello precedente.');
    return;
  }
  if (maxCleared >= level) {
    showGameMessage?.('Torre delle Prove', 'Hai gi√† completato questo livello della Torre.');
    return;
  }

  const heroPower = (typeof getHeroPower === 'function') ? getHeroPower() : 0;
  const neededPower = Math.ceil(lvlCfg.power * 1.08); // +8%, es: 100 ‚Üí 108

  // Consuma il tentativo
  incTowerAttempt();

  const win = (heroPower >= neededPower);

  // üîî Mostra overlay "battaglia in corso" come nel Dungeon
  if (typeof showBattleOverlay === 'function') showBattleOverlay();
  if (typeof startBattlePhrases === 'function') startBattlePhrases();

  // ‚è≥ aspetta 4 secondi, poi esito
  setTimeout(() => {
    if (typeof stopBattlePhrases === 'function') stopBattlePhrases();
    if (typeof hideBattleOverlay === 'function') hideBattleOverlay();

    if (win) {
      // Ricompensa
      grantTowerReward(level);
      setTowerMaxCleared(level);

      showGameMessage?.(
        'üèÜ Vittoria nella Torre',
        `Hai sconfitto il nemico del livello ${level}!<br>Ricompensa ottenuta.`
      );
    } else {
      showGameMessage?.(
        'üíÄ Sconfitta nella Torre',
        `Sei stato sconfitto al livello ${level}. Torna quando sarai pi√π forte!`
      );
    }

    // Refresh UI
    renderTowerList();
  }, 4000);
}


// --------- SFIDE: limite tentativi per avversario (max 2/d√¨) ---------

function getPvpAttemptsState() {
  // struttura: { date: "YYYY-MM-DD", attempts: { [opponentId]: count } }
  const today = _todayKey(); // esiste gi√† (usata anche dal dungeon)
  const st = userStore.get('pvpAttempts') || { date: today, attempts: {} };
  if (st.date !== today) {
    st.date = today;
    st.attempts = {}; // reset a mezzanotte
    userStore.set('pvpAttempts', st);
  }
  return st;
}

function pvpAttemptsUsed(opponentId) {
  const st = getPvpAttemptsState();
  return Number(st.attempts[opponentId] || 0);
}

function incPvpAttempt(opponentId) {
  const st = getPvpAttemptsState();
  st.attempts[opponentId] = (st.attempts[opponentId] || 0) + 1;
  userStore.set('pvpAttempts', st);
}

// ======== ENERGIA SFIDE (indipendente dal Dungeon) ========
const SFIDE_ENERGY_MAX = 20;
const SFIDE_REGEN_EVERY_MS = 60 * 60 * 1000; // 60 minuti
const SFIDE_ENERGY_COST = 4;

function initSfideEnergyIfNeeded() {
  // init valori base
  if (typeof userStore.get('sfideEnergy') !== 'number') {
    userStore.set('sfideEnergy', SFIDE_ENERGY_MAX);
  }
  if (!userStore.get('sfideEnergyLastRegen')) {
    userStore.set('sfideEnergyLastRegen', Date.now());
  }

  // ‚úÖ reset giornaliero a mezzanotte: energia piena
  const today = _todayKey();
  const lastReset = userStore.get('sfideEnergyDailyReset');
  if (lastReset !== today) {
    userStore.set('sfideEnergy', SFIDE_ENERGY_MAX);
    userStore.set('sfideEnergyLastRegen', Date.now());
    userStore.set('sfideEnergyDailyReset', today);
  }
}


// +1 ogni 60 minuti fino al massimo
function regenSfideEnergyIfNeeded() {
  initSfideEnergyIfNeeded();
  const now = Date.now();
  let energy = userStore.get('sfideEnergy');
  let last   = userStore.get('sfideEnergyLastRegen');

  if (energy >= SFIDE_ENERGY_MAX) {
    userStore.set('sfideEnergyLastRegen', now);
    return;
  }
  const elapsed = now - last;
  if (elapsed >= SFIDE_REGEN_EVERY_MS) {
    const gained = Math.floor(elapsed / SFIDE_REGEN_EVERY_MS);
    energy = Math.min(SFIDE_ENERGY_MAX, energy + gained);
    last += gained * SFIDE_REGEN_EVERY_MS;
    userStore.set('sfideEnergy', energy);
    userStore.set('sfideEnergyLastRegen', last);
  }
}

function getSfideEnergy() {
  regenSfideEnergyIfNeeded();
  return userStore.get('sfideEnergy') || 0;
}

function setSfideEnergy(val, opts = {}) {
  const v = Math.max(0, Math.min(SFIDE_ENERGY_MAX, Number(val) || 0));
  userStore.set('sfideEnergy', v);
  // ‚õîÔ∏è NON resettare il timer, a meno che non venga richiesto
  if (opts.resetTimer === true) {
    userStore.set('sfideEnergyLastRegen', Date.now());
  }
  renderSfideEnergyBar();
}

// UI barra energia Sfide
function renderSfideEnergyBar() {
  const energy = getSfideEnergy();
  const fill = document.getElementById('sfide-energy-fill');
  const meta = document.getElementById('sfide-energy-meta');
  const pct = Math.round((energy / SFIDE_ENERGY_MAX) * 100);

  if (fill) {
    fill.style.width = pct + '%';
    fill.classList.remove('yellow', 'red');
    if (pct < 15) fill.classList.add('red');
    else if (pct < 30) fill.classList.add('yellow');
  }

  if (meta) {
    let text = `Energia: ${energy}/${SFIDE_ENERGY_MAX} ‚ö°`;
    if (energy < SFIDE_ENERGY_MAX) {
      const last  = userStore.get('sfideEnergyLastRegen') || Date.now();
      const nextAt = last + SFIDE_REGEN_EVERY_MS;
      const diffMs = Math.max(0, nextAt - Date.now());
      const mins = Math.floor(diffMs / 60000);
      const secs = Math.floor((diffMs % 60000) / 1000);
      const mm = String(mins).padStart(2, '0');
      const ss = String(secs).padStart(2, '0');
      text += `<br><span class="regen-timer">+1 energia ‚ö° fra ${mm}:${ss}</span>`;
    }
    meta.innerHTML = text;
  }
}

// Ticker per aggiornare la barra mentre resti nella tab Sfide
let _sfideEnergyInterval = null;
function startSfideEnergyTicker() {
  if (_sfideEnergyInterval) return;
  _sfideEnergyInterval = setInterval(() => {
    renderSfideEnergyBar();
  }, 1000);
}
function stopSfideEnergyTicker() {
  if (_sfideEnergyInterval) {
    clearInterval(_sfideEnergyInterval);
    _sfideEnergyInterval = null;
  }
}


// --- Calcolo forza (Step 3 semplificato) ---

// --- Perdita salute in Dungeon (in base a lv Dungeon e lv Eroe) ---
function dungeonHpLoss(dungeonLevel, heroLevel){
  // DUNGEON 1‚Äì5
  if (dungeonLevel <= 5) {
    if (heroLevel <= 5)  return 0.5;
    if (heroLevel <= 10) return 0.3;
    return 0.2; // >=11
  }
  // DUNGEON 6‚Äì10
  if (dungeonLevel <= 10) {
    if (heroLevel <= 5)  return 1.0;
    if (heroLevel <= 10) return 0.8;
    return 0.4; // >=11
  }
  // DUNGEON 11‚Äì15
  if (dungeonLevel <= 15) {
    if (heroLevel <= 5)  return 2.0;
    if (heroLevel <= 10) return 1.5;
    if (heroLevel <= 15) return 1.0;
    return 0.5; // >=16
  }
  // DUNGEON >=16
  // (interpretato come "oltre 16" ‚Üí 16+ cos√¨ non lasciamo buchi)
  if (heroLevel <= 5)   return 2.5;
  if (heroLevel <= 10)  return 2.0;
  if (heroLevel <= 15)  return 1.5;
  if (heroLevel <= 20)  return 1.0;
  return 0.5; // >=21
}

// --- SALUTE: perdita in Sfide PvP (in base alla differenza di Potenza) ---
// diffPower = |myPower - oppPower|
// isWinner = true se l'eroe considerato ha vinto la sfida
function pvpHpLossByPowerDiff(diffPower, isWinner){
  const d = Math.max(0, Number(diffPower) || 0);
  let lossWinner, lossLoser;

  if (d < 2000)              { lossWinner = 1.2; lossLoser = 1.4; }
  else if (d < 4000)         { lossWinner = 1.1; lossLoser = 1.6; }
  else if (d < 6000)         { lossWinner = 1.0; lossLoser = 1.8; }
  else if (d < 8000)         { lossWinner = 0.9; lossLoser = 2.0; }
  else if (d < 10000)        { lossWinner = 0.8; lossLoser = 2.2; }
  else if (d < 15000)        { lossWinner = 0.7; lossLoser = 2.4; }
  else if (d < 20000)        { lossWinner = 0.6; lossLoser = 2.6; }
  else if (d < 25000)        { lossWinner = 0.5; lossLoser = 2.8; }
  else if (d < 30000)        { lossWinner = 0.4; lossLoser = 3.0; }
  else if (d < 35000)        { lossWinner = 0.3; lossLoser = 3.2; }
  else if (d < 50000)        { lossWinner = 0.2; lossLoser = 3.4; }
  else /* d >= 50000 */      { lossWinner = 0.1; lossLoser = 4.0; }

  // Clamp di sicurezza: mai meno di 0.1, mai pi√π di 4.0
  lossWinner = Math.min(4, Math.max(0.1, lossWinner));
  lossLoser  = Math.min(4, Math.max(0.1, lossLoser));

  return isWinner ? lossWinner : lossLoser;
}


// Estrai un tratto arma dal catalogo weaponItems (gi√† presente nel file)
function getWeaponTrait(weaponName, trait) {
  try {
    if (!weaponName) return 0;
    const item = (window.weaponItems || []).find(w => w.name === weaponName);
    if (!item || !item.traits) return 0;
    return Number(item.traits[trait] || 0);
  } catch { return 0; }
}

// Estrai un tratto armatura dal catalogo armorCatalog (gi√† presente nel file)
function getArmorTrait(armorName, trait) {
  try {
    if (!armorName) return 0;
    const item = (window.armorCatalog || []).find(a => a.name === armorName);
    if (!item || !item.traits) return 0;
    return Number(item.traits[trait] || 0);
  } catch { return 0; }
}

// Forza nemico = potenza nascosta
function enemyPowerForDungeon(level) {
  const lvl = Number(level) || 1;

  switch (lvl) {
    case 1:  return 500;
    case 2:  return 1500;
    case 3:  return 3000;
    case 4:  return 5000;
    case 5:  return 10000;
    case 6:  return 20000;
    case 7:  return 40000;
    case 8:  return 80000;
    case 9:  return 130000;
    case 10: return 195000;
    case 11: return 290000;
    case 12: return 440000;
    case 13: return 660000;
    case 14: return 990000;
    case 15: return 1500000;
    case 16: return 2200000;
    case 17: return 3300000;
    case 18: return 5000000;
    case 19: return 7500000;
    case 20: return 11500000;
    default:
      // fallback: sopra il 20 (se mai servir√†) lo trattiamo come il 20
      return 11500000;
  }
}



// --- Render lista nemici + bottone "Sfida" ---
function renderDungeonList() {
  // aggiorna rigenerazione e barra energia
  regenEnergyIfNeeded();
  renderEnergyBar();

  const list = document.getElementById('dungeon-list');
  if (!list) return;

  const enemies = getDungeonEnemies();
  const currentEnergy = getEnergy(); // dopo regen

  list.innerHTML = enemies.map((e, idx) => {
    const cost = energyCostForLevel(e.level);
    const canFight = currentEnergy >= cost;

    // üëâ stile per la riga di separazione (solo se NON √® l'ultimo mostro)
    const isLast = (idx === enemies.length - 1);
    const separatorStyle = isLast
      ? ''
      : 'border-bottom:1px solid rgba(0,0,0,0.12); padding-bottom:6px; margin-bottom:6px;';

    return `
      <div class="card" style="display:flex; gap:12px; align-items:center; justify-content:space-between; ${separatorStyle}">
        <div>
          <div><strong>${e.name}</strong> (Livello ${e.level})</div>
          <div class="muted">Ricompensa: ${formatGold(e.rewardGold)} oro, ${e.rewardXP} XP</div>
          <div class="muted">Costo energia: ${cost} ‚ö°</div>
        </div>
        <div>
          <button class="magic-button" onclick="tryDungeonBattle('${e.id}', ${e.level}, ${e.rewardGold}, ${e.rewardXP})">Sfida</button>
        </div>
      </div>
    `;
  }).join('');
}

let _energyInterval = null;


function startEnergyTicker() {
  if (_energyInterval) return;
  _energyInterval = setInterval(() => {
    renderEnergyBar();
  }, 1000);
}

function stopEnergyTicker() {
  if (_energyInterval) {
    clearInterval(_energyInterval);
    _energyInterval = null;
  }
}

function showBattleOverlay() {
  const el = document.getElementById('dungeon-battle-overlay');
  if (el) el.style.display = 'flex';
}
function hideBattleOverlay() {
  const el = document.getElementById('dungeon-battle-overlay');
  if (el) el.style.display = 'none';
}
// Frasi casuali che appaiono durante l'attesa della battaglia
const battlePhrases = [
  "‚öîÔ∏è Il nemico ti osserva con occhi di fuoco‚Ä¶",
  "üõ°Ô∏è Stai affondando il colpo con forza‚Ä¶",
  "üí• Le armi si scontrano fragorosamente!",
  "üë£ Ti muovi con cautela nel dungeon‚Ä¶",
  "üî• L‚Äôaria √® carica di tensione‚Ä¶",
  "ü©∏ Il duello √® nel vivo!"
];

let _battlePhraseTimeout = null;

function startBattlePhrases() {
  const textEl = document.getElementById('dbo-random-text');
  if (!textEl) return;

  // prima frase subito
  textEl.textContent = battlePhrases[Math.floor(Math.random() * battlePhrases.length)];

  // seconda frase dopo 2s
  _battlePhraseTimeout = setTimeout(() => {
    textEl.textContent = battlePhrases[Math.floor(Math.random() * battlePhrases.length)];
  }, 2000);
}

function stopBattlePhrases() {
  if (_battlePhraseTimeout) {
    clearTimeout(_battlePhraseTimeout);
    _battlePhraseTimeout = null;
  }
}
// === SFIDE: avvio e risoluzione ===

// Trova entry directory per un utente
function _findHeroByName(name){
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  return dir.find(h => h && (h.name === name)) || null;
}
// Aggiorna la directory globale
function _saveHeroDir(arr){
  if (typeof setHeroDirectory === 'function') setHeroDirectory(arr);
}

function hasOnlyCreatureEquipped() {
  const creature = (window.getEquippedCreature && window.getEquippedCreature())
    || userStore.get('equippedCreature') || null;

  const armor   = (window.getEquippedArmor && window.getEquippedArmor())
    || userStore.get('equippedArmor') || null;

  const rHand = userStore.get('rightHand') || null;
  const lHand = userStore.get('leftHand')  || null;

  const magic = userStore.get('magic');
  const hasMagic = !!(magic && String(magic).toLowerCase() !== 'nessuna');

  return !!creature && !armor && !rHand && !lHand && !hasMagic;
}

// Calcolo esito (vince se livello >= avversario) + gestione punti
function startHeroChallenge(opponentId){
if (isInGuildMine()) {
  showGameMessage('Azione non permessa', 'Non puoi avviare missioni o sfide mentre stai scavando nella Miniera della Gilda.');
  return;
}
if (!canStartActionWithHp('una Sfida')) return;

// üõ°Ô∏è SCUDO: se ho scudo attivo non posso lanciare sfide
if (typeof isShieldActive === 'function' && isShieldActive()) {
  showGameMessage('Scudo attivo', 'Hai uno scudo attivo: non puoi lanciare sfide tra eroi finch√© √® attivo.');
  return;
}

  const me = (typeof currentUser === 'string') ? currentUser : null;
  if (!me) { showGameMessage?.('Errore', 'Devi essere loggato per sfidare.'); return; }

  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const mine = _findHeroByName(me);
  const opp  = dir.find(h => h && (h.id === opponentId));
if (!opp) { showGameMessage?.('Errore', 'Eroe avversario non trovato.'); return; }

// üõ°Ô∏è SCUDO: se l'avversario ha scudo attivo non √® sfidabile
if (Number(opp.shieldEndAt || 0) > Date.now()) {
  showGameMessage('Scudo attivo', "L'eroe avversario ha uno scudo attivo e non pu√≤ essere sfidato.");
  return;
}

if (opp.name === me){ showGameMessage?.('Oops', 'Non puoi sfidare te stesso.'); return; }
let _thisWarInitiatorGid = null;
  // Blocca sfide stessa gilda
  const myGuild  = (typeof findGuildOfUser === 'function') ? findGuildOfUser(me) : {id:null};
  const oppGuild = (typeof findGuildOfUser === 'function') ? findGuildOfUser(opp.name) : {id:null};
  if (myGuild.id && oppGuild.id && myGuild.id === oppGuild.id){
    showGameMessage?.('Non consentito', 'Non puoi sfidare un eroe della tua stessa gilda.');
    return;
  }

// --- [WAR CHECKS] ------------------------------------------------------------
try {
  const meUser = (typeof currentUser === 'string') ? currentUser : '';
  const myG    = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
  const oppG   = (typeof findGuildOfUser === 'function') ? findGuildOfUser(opp.name || '') : { id:null };

  if (myG && oppG?.id && typeof atWar === 'function' && atWar(myG, oppG.id)) {
    // A) limite giornaliero 5 sfide di guerra verso quella gilda
    if (typeof canInitiateWarChallenge==='function' && !canInitiateWarChallenge(myG, oppG.id, meUser)) {
      showGameMessage('Limite giornaliero raggiunto',
        'Hai terminato il limite giornaliero di sfide di guerra contro questa gilda per oggi.');
      return;
    }

    // B) stesso eroe in guerra: 1 volta al giorno PER DIREZIONE (A‚ÜíB e B‚ÜíA sono indipendenti)
    if (typeof getWarPvpCount === 'function' && getWarPvpCount(meUser, opp.name) >= 1) {
      showGameMessage('‚öîÔ∏è Guerra: limite contro questo eroe',
        'Durante una guerra puoi sfidare lo stesso avversario una sola volta al giorno.');
      return;
    }

        // se passiamo i check, segna che ho "iniziato" una sfida guerra (per quota 5/giorno)
    if (typeof addWarInitiated==='function') addWarInitiated(myG, oppG.id, meUser);
    // <<< AGGIUNGI QUI
    _thisWarInitiatorGid = myG;
  }
} catch(_) {}



// ‚Äî Energia Sfide: check e consumo (4)
regenSfideEnergyIfNeeded();
const need = SFIDE_ENERGY_COST; // 4
const nowEnergy = getSfideEnergy();
if (nowEnergy < need) {
  showGameMessage?.("‚ö° Energia insufficiente", "Non hai abbastanza energia per affrontare questo nemico.");
  return;
}
// Limite tentativi vs lo stesso eroe: max 2 al giorno
const usedVsThis = pvpAttemptsUsed(opponentId);
if (usedVsThis >= 2) {
  showGameMessage?.(
    "Limite giornaliero",
    "Non √® possibile sfidare lo stesso eroe pi√π di due volte al giorno."
  );
  return;
}

// Conta SUBITO il tentativo valido (cos√¨ evitiamo doppi click paralleli)
incPvpAttempt(opponentId);

// Consuma subito per evitare spam paralleli
setSfideEnergy(nowEnergy - need);

    // Dati livello
  const myLvl  = (typeof getHeroLevelOfUser === 'function')
    ? (getHeroLevelOfUser(me) || 1)
    : Number(getNum('level',1)) || 1;

  const oppLvl = (typeof getHeroLevelOfUser === 'function')
    ? (getHeroLevelOfUser(opp.name) || 1)
    : Number(opp.level || 1) || 1;

  // üî• Calcolo Potenza eroe per la sfida
  let myPower = 0;
  try {
    if (typeof computeHeroPower === 'function') {
      myPower = Number(computeHeroPower() || 0);
    }
  } catch (e) {
    myPower = 0;
  }

  // Potenza dell'avversario presa dalla heroDirectory (campo "power" salvato prima)
  const oppPower = (opp && opp.power != null)
    ? (Number(opp.power) || 0)
    : 0;

  // Mostra overlay + frasi ‚Äúbattaglia in corso‚Ä¶‚Äù per ~2 secondi
  showBattleOverlay();
  startBattlePhrases();

  setTimeout(() => {
    // Esito: vince chi ha pi√π Potenza; livello usato come tie-breaker / fallback
    let iWin;

    if (myPower > 0 || oppPower > 0) {
      if (myPower > oppPower) {
        iWin = true;
      } else if (myPower < oppPower) {
        iWin = false;
      } else {
        // pareggio di potenza ‚Üí usa il livello
        if (myLvl > oppLvl)      iWin = true;
        else if (myLvl < oppLvl) iWin = false;
        else                     iWin = Math.random() < 0.5;
      }
    } else {
      // Se per qualche motivo non abbiamo potenze valide (dati vecchi, ecc.),
      // usiamo il vecchio comportamento basato sul livello
      if (myLvl > oppLvl)      iWin = true;
      else if (myLvl < oppLvl) iWin = false;
      else                     iWin = Math.random() < 0.5;
    }
    // --- SALUTE: applica danno a entrambi gli eroi in base alla differenza di potenza ---
    //   (teniamo traccia anche delle perdite HP per messaggi, popup e storico)
    let myHpLossForMsg  = 0;    // perdita HP del mio eroe (sfidante)
    let oppHpLossForMsg = 0;    // perdita HP dell'avversario (sfidato)

    try {
      const diffPower = Math.abs((Number(myPower) || 0) - (Number(oppPower) || 0));

      // Quanto perde il mio eroe (vincitore o perdente) secondo la tabella
      const myHpLoss  = pvpHpLossByPowerDiff(diffPower, iWin);
      // Quanto perde l'avversario (ruolo opposto: se io vinco, lui perde da perdente e viceversa)
      const oppHpLoss = pvpHpLossByPowerDiff(diffPower, !iWin);

      // Salviamo i valori per usarli nei messaggi/popup/log
      myHpLossForMsg  = myHpLoss;
      oppHpLossForMsg = oppHpLoss;

      // 1) Il mio eroe: aggiorna storage + UI
      if (typeof changeHeroHp === 'function') {
        changeHeroHp(-myHpLoss);
      }

      // 2) L'avversario: aggiorna solo heroDirectory (verr√† letta al suo prossimo login)
      if (typeof applyHpDeltaToHeroInDirectory === 'function' && opp && opp.id) {
        applyHpDeltaToHeroInDirectory(opp.id, -oppHpLoss);
      }

      // 3) Aggiorna la mia entry in directory con gli HP aggiornati (dopo changeHeroHp)
      try {
        if (typeof upsertCurrentHeroIntoDirectory === 'function') {
          upsertCurrentHeroIntoDirectory();
        }
      } catch (_) {}
    } catch (e) {
      console.warn('Errore calcolo/perdita HP PvP:', e);
    }

    // ‚¨áÔ∏è Da qui in gi√π lasci TUTTO com‚Äôera (uso di iWin, punti, messaggi, log sfide, ecc.)

    // ‚¨áÔ∏è Da qui in gi√π lasci TUTTO com‚Äôera (uso di iWin, punti, messaggi, log sfide, ecc.)


    // Punti attuali (di default 0 se assenti)
    const myPts  = Number(mine?.points || 0);
    const oppPts = Number(opp?.points  || 0);

    // Stabilisco se l'avversario √® sopra/sotto/pari in classifica
    const higher = oppPts > myPts;
    const lower  = oppPts < myPts;
    const equal  = oppPts === myPts;

    // 10% della differenza, arrotondato, ma con minimo 1 punto se diff > 0
const diff = Math.abs(myPts - oppPts);
const ten  = (diff > 0) ? Math.max(1, Math.round(diff * 0.10)) : 0;

    // Delta punti secondo le regole
    let gainMe = 0, lossMe = 0, gainOpp = 0, lossOpp = 0;

    if (iWin){
      if (higher)       { gainMe = ten; lossOpp = ten; }
      else if (lower)   { gainMe = 1;   lossOpp = 1;   }
      else /* equal */  { gainMe = 1;   lossOpp = 1;   }
    } else {
      if (higher)       { lossMe = 1;   gainOpp = 1;   }
      else if (lower)   { lossMe = ten; gainOpp = ten; }
      else /* equal */  { lossMe = 1;   gainOpp = 1;   }
    }

    // Applica (clamp minimo 0 per evitare negativi)
    const newMy  = Math.max(0, myPts  + gainMe - lossMe);
    const newOpp = Math.max(0, oppPts + gainOpp - lossOpp);

    // Scrivi in directory globale
    const updated = (getHeroDirectory() || []).map(h => {
      if (!h) return h;
      if (h.name === me)       return Object.assign({}, h, { points: newMy });
      if (h.id   === opp.id)   return Object.assign({}, h, { points: newOpp });
      return h;
    });
// --- NEW: aggiorna il contatore vittorie (vince solo uno)
function incWinsOn(arr, userName){
  const idx = arr.findIndex(h => h && h.name === userName);
  if (idx >= 0) {
    const cur = Number(arr[idx].wins || 0);
    arr[idx] = Object.assign({}, arr[idx], { wins: cur + 1 });
  }
}

if (iWin) {
  incWinsOn(updated, me);        // io ho vinto
} else {
  incWinsOn(updated, opp.name);  // ha vinto l'avversario
}

    _saveHeroDir(updated);

    // Aggiorna anche il mio store per coerenza (chiave corretta)
try {
  userStore.set('heroPoints', newMy); // usato al login
  userStore.set('points', newMy);     // retrocompatibilit√†
} catch (_){}

    // Chiudi overlay
    stopBattlePhrases();
    hideBattleOverlay();

    // Messaggio popup allo sfidante (io)
const deltaMe = (gainMe - lossMe);
const resultTitle = iWin ? 'Vittoria!' : 'Sconfitta';
const sign = deltaMe >= 0 ? '+' : '‚àí';
const absDelta = Math.abs(deltaMe);
const oppTagStr = (oppGuild && oppGuild.tag) ? `[${escapeHtml(oppGuild.tag)}] ` : '';

// Salute persa dal mio eroe, formattata
let myHpLostStr = '';
try {
  if (typeof myHpLossForMsg === 'number' && !isNaN(myHpLossForMsg)) {
    myHpLostStr = myHpLossForMsg.toFixed(1).replace('.', ',');
  }
} catch (_) {}

showGameMessage?.(
  `${iWin ? 'üèÜ' : 'üíÄ'} ${resultTitle}`,
  `
    <div>Hai sfidato <strong>${oppTagStr}${escapeHtml(opp.name)}</strong> (Lv ${oppLvl}).</div>
    <div style="margin-top:6px;">Punti: <strong>${sign}${absDelta}</strong></div>
    <div>Salute persa: <strong>-${myHpLostStr}</strong></div>
  `
);

// ‚ûï Quest giornaliera: "Completa 5 sfide" (conta win/lose)
if (typeof incrementQuest === 'function') incrementQuest('q_daily_5sfide', 1);
// ‚ûï Quest settimanale: "Completa 30 sfide"
if (typeof incrementQuest === 'function') incrementQuest('q_weekly_30challenges', 1);

if (iWin) {
// ‚ûï Main Quest: Vittorie PvP (solo in caso di vittoria)
if (typeof incrementMainWinsOnVictory === 'function') incrementMainWinsOnVictory(1);
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

  // ‚ûï Vittoria con sola creatura equipaggiata
  try {
    if (typeof hasOnlyCreatureEquipped === 'function' && hasOnlyCreatureEquipped()) {
      incrementQuest('q_daily_win_creature_only', 1);
    }
  } catch (_) {}
}

// üîÑ Un solo refresh UI/badge alla fine
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();


    // Messaggio in casella allo sfidato
try {
  const stamp = fmtDateTimeShort(Date.now());
  const delta = (gainOpp || lossOpp) || 0;
  const myTagStr = (myGuild && myGuild.tag) ? `[${escapeHtml(myGuild.tag)}] ` : '';

  // üëâ Salute persa dallo sfidato (valore calcolato prima e salvato in oppHpLossForMsg)
  let hpLostStr = '';
  try {
    if (typeof oppHpLossForMsg === 'number' && !isNaN(oppHpLossForMsg)) {
      hpLostStr = oppHpLossForMsg.toFixed(1).replace('.', ',');
    }
  } catch (_) {}

  const bodyOpp = iWin
    ? `<strong>üíÄ Sconfitta</strong><br>` +
      `Hai ricevuto una sfida da <strong>${myTagStr}${escapeHtml(me)}</strong>.<br>` +
      `Punti: -${delta}<br>` +
      `Salute persa: -${hpLostStr}<br>` +
      `${stamp}`
    : `<strong>üèÜ Vittoria!</strong><br>` +
      `Hai ricevuto una sfida da <strong>${myTagStr}${escapeHtml(me)}</strong>.<br>` +
      `Punti: +${delta}<br>` +
      `Salute persa: -${hpLostStr}<br>` +
      `${stamp}`;


  deliverMessageToUser(opp.name, {
    id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
    type: 'pvp_challenge',
    from: me,
    to: opp.name,
    title: 'Sfida ricevuta',
    body: bodyOpp,
    when: Date.now(),
    unread: true
  });
} catch(_){}


// --- [WAR LOG RESULT] --------------------------------------------------------
try {
  const meUser = (typeof currentUser === 'string') ? currentUser : '';
  const myG    = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
  const oppG   = (typeof findGuildOfUser === 'function') ? findGuildOfUser(opp.name || '') : { id:null };

  // segna l'accoppiata eroe-eroe consumata oggi e registra progressi guerra SOLO se √® una guerra
  if (myG && oppG?.id && typeof atWar === 'function' && atWar(myG, oppG.id)) {
    if (typeof incWarPvpCount === 'function') incWarPvpCount(meUser, opp.name);

    // registra la vittoria per la soglia 2000 (usa il tuo boolean "iWin")
    const winnerGuildId = iWin ? myG : oppG.id;
const loserGuildId  = iWin ? oppG.id : myG;

if (typeof recordWarResult === 'function') {
  const winsNow = recordWarResult(myG, oppG.id, winnerGuildId, _thisWarInitiatorGid);
  // chiudi la guerra appena QUALSIASI gilda raggiunge 2000 vittorie complessive
  if (Number(winsNow) >= 2000 && typeof endWarByVictory === 'function') {
    endWarByVictory(winnerGuildId, loserGuildId);
  }
}
  }
} catch(_) {}


// === LOG "Ultime sfide" (solo PvP) =========================================
try {
  // Tag gilda lato mio e lato avversario (helper gi√† esistente)
  const myTag  = (myGuild && myGuild.tag) ? myGuild.tag : '';
  const oppTag = (oppGuild && oppGuild.tag) ? oppGuild.tag : '';

  // Delta punti per l'avversario: stesso unsigned usato nel messaggio
  const unsignedOpp = (gainOpp || lossOpp) || 0;
  const deltaOpp    = iWin ? -unsignedOpp : unsignedOpp;

    const entry = {
    // struttura simmetrica A vs B
    id: 'pvp_' + Date.now() + '_' + Math.floor(Math.random()*1e6),
    aUser: me,         aTag: myTag,
    bUser: opp.name,   bTag: oppTag,
    aDelta: Number(deltaMe || 0),
    bDelta: Number(deltaOpp || 0),

    // üëá nuove info: salute persa da ciascun lato (coerente con aUser/bUser)
    aHpLoss: Number(myHpLossForMsg  || 0),
    bHpLoss: Number(oppHpLossForMsg || 0),

    winner: iWin ? 'a' : 'b',
    when: Date.now()
  };


  if (typeof appendPvpLogFor === 'function') {
    appendPvpLogFor(me, entry);         // log lato mio
    appendPvpLogFor(opp.name, entry);   // log lato avversario (se presente su questo device)
  }
} catch(_) {}
// ===========================================================================


    // Rinfresca classifica (subito dopo la sfida)
    renderSfideList();
  }, 2000);
}

// --- Esito automatico (Step 2+3+4) ---
function tryDungeonBattle(enemyId, enemyLevel, rewardGold, rewardXP) {
if (isInGuildMine()) {
  showGameMessage('Azione non permessa', 'Non puoi avviare missioni o sfide mentre stai scavando nella Miniera della Gilda.');
  return;
}
if (!canStartActionWithHp('un Dungeon')) return;

  // energia necessaria
  regenEnergyIfNeeded(); // aggiorna prima
  const cost = energyCostForLevel(enemyLevel);
  const energyNow = getEnergy();

  if (energyNow < cost) {
  showGameMessage?.("‚ö° Energia insufficiente", "Non hai abbastanza energia per affrontare questo nemico.");
  return;
}


  // consuma subito l'energia (evita spam paralleli)
  setEnergy(energyNow - cost);

//‚¨áÔ∏è Perdita salute in base a livello Dungeon/Eroe
const heroLevel = getNum('level', 1);
const hpLoss = dungeonHpLoss(enemyLevel, heroLevel);
changeHeroHp(-hpLoss);

  // calcolo esito (lo memorizziamo, ma lo mostriamo dopo il timer)
  const heroPow  = getHeroPower();
  const enemyPow = enemyPowerForDungeon(enemyLevel);
  const isWin    = heroPow > enemyPow;

  // mostra overlay di "battaglia in corso"
  showBattleOverlay();
  startBattlePhrases();

  // ‚è≥ attesa 4 secondi (4000 ms)
  setTimeout(() => {
    // ferma il cambio frasi e chiudi overlay
    stopBattlePhrases();
    hideBattleOverlay();

    if (isWin) {
      /// Vittoria: accredita ricompense (applica bonus gilda)
const baseGold = Number(rewardGold) || 0;
const finalGold = (typeof applyGuildGoldBonus === 'function') ? applyGuildGoldBonus(baseGold) : baseGold;

const baseXp = Number(rewardXP) || 0;
const finalXp = (typeof applyGuildHeroXpBonus === 'function') ? applyGuildHeroXpBonus(baseXp) : baseXp;

addNum('gold', finalGold);
gainXP(rewardXP);

      // UI oro (se presente)
      const heroGoldEl = document.getElementById('hero-gold');
      if (heroGoldEl) {
        const g = getNum('gold', 0);
        heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;
      }

      // Messaggio con i numeri reali
showGameMessage?.(
  `üèÜ Vittoria!`,
  `Hai sconfitto il nemico e ottenuto ${formatGold(finalGold)} oro e ${finalXp} XP.`
);
    } else {
      // SCONFITTA: penalit√† extra +0,5 oltre alla perdita base gi√† applicata
         changeHeroHp(-0.5);
      showGameMessage?.("üíÄ Sconfitta", "Sei stato sconfitto. Riprova quando sarai pi√π forte!");
    }

// ‚ûï Progresso quest: conta qualsiasi sfida nel dungeon (win/lose)
incrementQuest('q_daily_dungeon_5challenges', 1);
incrementQuest('q_weekly_dungeon_30challenges', 1); // ‚¨ÖÔ∏è NUOVO
// ‚ûï Main Quest: Vittorie Dungeon (solo in caso di vittoria)
if (isWin) {
  if (typeof incrementMainDungeonOnVictory === 'function') incrementMainDungeonOnVictory(1);
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

    // refresh lista (aggiorna energia + pulsanti)
    renderDungeonList();
  }, 4000);
}

function populateListFromArray(listId, userSuffix){
  const container = document.getElementById(listId);
  const items = userStore.get(userSuffix) || [];
  container.innerHTML = items.length
    ? items.map(x => `<li>${x}</li>`).join('')
    : '<li>Deposito vuoto</li>';
}
// === Inventario: paginazione ===
const INVENTORY_PER_PAGE = 10;
const _invPage = { weapons: 1, armors: 1, magics: 1, creatures: 1, potions: 1 };

// === Inventario: paginazione (inizializzazione safe) ===
window.INVENTORY_PER_PAGE = window.INVENTORY_PER_PAGE || 10;
window._invPage = window._invPage || { weapons: 1, armors: 1, magics: 1, creatures: 1, potions: 1 };

/**
 * Popola l'elenco inventario con paginazione.
 * - Max 10 elementi per pagina (configurabile via INVENTORY_PER_PAGE)
 * - Prima pagina: mostra solo "Pagina Successiva"
 * - Pagine centrali: "Pagina Successiva" e sotto "Pagina Precedente"
 * - Ultima pagina: mostra solo "Pagina Precedente"
 * @param {string} elementId - ul/ol container id (es. 'weapon-list')
 * @param {'weapons'|'armors'|'magics'|'creatures'} type
 * @param {number} [page] - pagina da mostrare (opzionale)
 */
function populateStorage(elementId, type, page) {
  const container = document.getElementById(elementId);
  if (!container) return;

  // pagina corrente (se non passata, usa quella salvata)
  const curPage = Math.max(1, Number(page || window._invPage[type] || 1));
  window._invPage[type] = curPage;

  // helper: pulsanti paginazione secondo le regole richieste
  const renderNav = (totalPages) => {
  if (totalPages <= 1) return '';

  const isFirst = curPage === 1;
  const isLast  = curPage === totalPages;

  // ‚ñº NIENTE class="magic-button" per avere lo stesso look di "Indietro"
  const nextBtn = `<button type="button" style="width:100%; margin-top:10px;"
                     onclick="populateStorage('${elementId}','${type}', ${curPage + 1})">Pagina Successiva</button>`;
  const prevBtn = `<button type="button" style="width:100%; margin-top:10px;"
                     onclick="populateStorage('${elementId}','${type}', ${curPage - 1})">Pagina Precedente</button>`;

  if (isFirst) return nextBtn;
  if (isLast)  return prevBtn;
  return nextBtn + prevBtn;
};


  // === WEAPONS: oggetto { nome: quantit√† } ===
  if (type === 'weapons') {
    const weaponsObj = userStore.get('weapons') || {};
    const names = Object.keys(weaponsObj);

    if (names.length === 0) {
      container.innerHTML = '<li>Deposito vuoto</li>';
      return;
    }

    const total = names.length;
    const totalPages = Math.ceil(total / window.INVENTORY_PER_PAGE);
    const start = (curPage - 1) * window.INVENTORY_PER_PAGE;
    const slice = names.slice(start, start + window.INVENTORY_PER_PAGE);

    const itemsHtml = slice.map(name => `
      <li>
        <button class="magic-button" style="width:100%;"
          onclick="openFromInventory('weapons','${name.replace(/'/g, "\\'")}')">
          ${formatWeaponName(name)} x${weaponsObj[name]}
        </button>
      </li>
    `).join('');

    container.innerHTML = itemsHtml + renderNav(totalPages);
    return;
  }
// === POZIONI: oggetto { id: quantit√† } ===
if (type === 'potions') {
  const map = userStore.get('potions') || {};
  const ids = Object.keys(map);

  if (ids.length === 0) {
    container.innerHTML = '<li>Deposito vuoto</li>';
    return;
  }

  const total = ids.length;
  const totalPages = Math.ceil(total / window.INVENTORY_PER_PAGE);
  const start = (curPage - 1) * window.INVENTORY_PER_PAGE;
  const slice = ids.slice(start, start + window.INVENTORY_PER_PAGE);

  // helper: risolve metadati dal catalogo
  const cat = (window.potionCatalog||[]);
  const byId = Object.fromEntries(cat.map(x => [x.id, x]));

  const itemsHtml = slice.map(id => {
    const meta = byId[id];
    const label = meta ? `${meta.name} (x${map[id]})` : `${id} (x${map[id]})`;
    return `
      <li>
        <button class="magic-button" style="width:100%;"
          onclick="openPotionDetail('${id}', true)">${label}</button>
      </li>
    `;
  }).join('');

  container.innerHTML = itemsHtml + renderNav(totalPages);
  return;
}

  // === Altri tipi: 'magics' | 'armors' | 'creatures' (array di nomi) ===
  const items = userStore.get(type) || [];
  if (items.length === 0) {
    container.innerHTML = '<li>Deposito vuoto</li>';
    return;
  }

  // --- mostra XP accanto alle creature (compat con salvataggi vecchi) ---
  if (type === 'creatures' && typeof ensureCreatureXpMap === 'function') {
    ensureCreatureXpMap();
  }

  const total = items.length;
  const totalPages = Math.ceil(total / window.INVENTORY_PER_PAGE);
  const start = (curPage - 1) * window.INVENTORY_PER_PAGE;
  const slice = items.slice(start, start + window.INVENTORY_PER_PAGE);

  const itemsHtml = slice.map(name => {
    const label = (type === 'creatures')
      ? `${name} (${(typeof getCreatureXp === 'function' ? getCreatureXp(name) : 0)} xp)`
      : name;

    return `
      <li>
        <button class="magic-button" style="width:100%;"
          onclick="openFromInventory('${type}','${String(name).replace(/'/g, "\\'")}')">
          ${label}
        </button>
      </li>
    `;
  }).join('');

  container.innerHTML = itemsHtml + renderNav(totalPages);
}
/* =========================
   Varianti di rarit√† (auto)
   ========================= */
const RARITY_KEYS = ['rara','epica','leggendaria','mitica'];
const RARITY_TAG  = { rara:' [Rara]', epica:' [Epica]', leggendaria:' [Leggendaria]', mitica:' [Mitica]' };

// moltiplicatori costo se mai servono in futuro (non toccano la bottega)
const RARITY_COST_X = { rara: 6, epica: 8, leggendaria: 12, mitica: 20 };

// incremento per rarit√† (come richiesto)
const UP = { rara:2, epica:4, leggendaria:6, mitica:8 };

function toNum(x){ return Number(x) || 0; }
function baseNameFromVariant(n){
  return String(n||'').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');
}

function enhanceTraits(tr, cat, r){
  if (!tr) return tr;
  const t = { ...tr };
  const up = UP[r]||0;

  // Armi: Danno, Velocit√†, Distanza d'uso, Velocit√† uso e riuso (+)
  if (cat==='weapons'){
    ['Danno','Velocit√†',"Distanza d'uso","Velocit√† uso e riuso"].forEach(k => { if (k in t) t[k]= toNum(t[k]) + up; });
  }
  // Armature: Difesa, Resistenza, Agilit√† (+)
  else if (cat==='armors'){
    ['Difesa','Resistenza','Agilit√†'].forEach(k => { if (k in t) t[k]= toNum(t[k]) + up; });
  }
  // Magie: Danno, Velocit√† (+)
  else if (cat==='magics'){
    ['Danno','Velocit√†'].forEach(k => { if (k in t) t[k]= toNum(t[k]) + up; });
  }
  // Creature: Forza, Agilit√†, Astuzia, Aggressivit√†, Dimensioni (+)
  else if (cat==='creatures'){
    ['Forza','Agilit√†','Astuzia','Aggressivit√†','Dimensioni'].forEach(k => { if (k in t) t[k]= toNum(t[k]) + up; });
  }
  return t;
}

function makeVariant(item, r, cat){
  const name = `${item.name}${RARITY_TAG[r]}`;
  const baseCost = Number(item.cost ?? item.price ?? 0) || 0;
  const costX = RARITY_COST_X[r] || 1;
  const boostedCost = Math.round(baseCost * costX);

  return {
    ...item,
    id: (item.id||item.name) + '-' + r,
    name,
    rarity: r,
    // lascia cost/price se esistevano (non usati in shop per le varianti)
    ...(item.cost  !== undefined ? { cost:  boostedCost } : {}),
    ...(item.price !== undefined ? { price: boostedCost } : {}),
    traits: enhanceTraits(item.traits, cat, r)
  };
}

// cache lazy (comuni + varianti auto)
let _defsCache = null;

/** Elenco completo (comuni + varianti) per categoria */
function getAllDefs(cat){
  if (!_defsCache){
    _defsCache = { weapons:[], armors:[], magics:[], creatures:[] };
    try{
      const W = (typeof weaponItems!=='undefined') ? weaponItems : (window.weaponItems||[]);
      _defsCache.weapons = W.concat(W.flatMap(w => RARITY_KEYS.map(r => makeVariant(w,r,'weapons'))));
    }catch{}
    try{
      const A = (typeof armorCatalog!=='undefined') ? armorCatalog : (window.armorCatalog||[]);
      _defsCache.armors = A.concat(A.flatMap(a => RARITY_KEYS.map(r => makeVariant(a,r,'armors'))));
    }catch{}
    try{
      const M = (typeof magicItems!=='undefined') ? magicItems : (window.magicItems||[]);
      _defsCache.magics = M.concat(M.flatMap(m => RARITY_KEYS.map(r => makeVariant(m,r,'magics'))));
    }catch{}
    try{
      const C = (typeof creatureShop!=='undefined') ? creatureShop : (window.creatureShop||[]);
      _defsCache.creatures = C.concat(C.flatMap(c => RARITY_KEYS.map(r => makeVariant(c,r,'creatures'))));
    }catch{}
  }
  return _defsCache[cat] || [];
}

// (facoltativo) esponi global se ti torna utile
window.getAllDefs = getAllDefs;
window.baseNameFromVariant = baseNameFromVariant;

function openFromInventory(type, name){
  if (!type || !name) return;
  const targetName = String(name).trim();

  // Usa le definizioni "comuni + varianti" se il generatore √® presente,
  // altrimenti cade sui cataloghi base (solo comuni).
  const useAll = (cat, baseArr) =>
    (typeof getAllDefs === 'function')
      ? getAllDefs(cat)
      : (Array.isArray(baseArr) ? baseArr : []);

  const stripVariant = (n) => {
    if (typeof baseNameFromVariant === 'function') return baseNameFromVariant(n);
    return String(n||'').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');
  };

  if (type === 'weapons') {
    const base = (typeof weaponItems !== 'undefined') ? weaponItems : (window.weaponItems || []);
    const list = useAll('weapons', base);
    const item = list.find(x => x && x.name === targetName);
    if (item) showWeaponDetails(item, true);
    return;
  }

  if (type === 'armors') {
    const base = (typeof armorCatalog !== 'undefined') ? armorCatalog : (window.armorCatalog || []);
    const list = useAll('armors', base);
    const item = list.find(x => x && x.name === targetName);
    if (item) showArmorDetails(item, true);
    return;
  }

  if (type === 'magics') {
    const base = (typeof magicItems !== 'undefined') ? magicItems : (window.magicItems || []);
    const list = useAll('magics', base);
    const item = list.find(x => x && x.name === targetName);
    if (item) {
      // Descrizione: prova col nome completo; se manca, usa il nome base (senza suffisso)
      const descMap = (typeof magicDescriptions === 'object' && magicDescriptions) ? magicDescriptions : {};
      const baseName = stripVariant(item.name);
      const full = { ...item, desc: descMap[item.name] || descMap[baseName] || item.desc || '' };
      showMagicDetails(full, true);
    }
    return;
  }

  if (type === 'creatures') {
    const base = (typeof creatureShop !== 'undefined') ? creatureShop : (window.creatureShop || []);
    const list = useAll('creatures', base);
    const item = list.find(x => x && x.name === targetName);
    if (item) showCreatureDetails(item, true);
    return;
  }

  console.warn('openFromInventory: tipo non riconosciuto:', type, name);
}

function showRegister() {
  document.getElementById('register-section').classList.remove('hidden');
  document.getElementById('login-section').classList.add('hidden');
}

// Sincronizza HP dell'eroe corrente leggendo da heroDirectory
function syncHeroHpFromDirectory(username){
  if (!username) return;
  try {
    if (typeof getHeroDirectory !== 'function') return;
    const dir  = getHeroDirectory() || [];
    const myId = 'user:' + username;
    const meEntry = dir.find(h => h && h.id === myId);

    if (meEntry && (meEntry.hp != null || meEntry.hpMax != null)) {
      // max: prova hpMax, poi fallback sensato
let max = (meEntry.hpMax != null) ? Number(meEntry.hpMax)
        : (meEntry.hp != null)   ? Number(meEntry.hp)
        : 100;

if (!Number.isFinite(max) || max <= 0) max = 100;

// hp: se presente, usa anche 0; se manca usa max
let hp = (meEntry.hp != null) ? Number(meEntry.hp) : max;
if (!Number.isFinite(hp)) hp = max;

setNum('heroHpMax', Math.round(max));
setNum('heroHp', Math.max(0, Math.min(Math.round(max), +hp.toFixed(1))));


      // Aggiorna anche la barra vita se la funzione esiste
      if (typeof updateHeroHealthUI === 'function') {
        updateHeroHealthUI();
      }
    }
  } catch (e) {
    console.warn('Sync HP from directory failed', e);
  }
}

async function login() {
  const username = document.getElementById('username').value;
  const password = document.getElementById('password').value;

  // Verifica credenziali
  const ok = await accountStore.verifyPassword(username, password);
  if (!ok) {
    alert("Login fallito!");
    return;
  }

  // Utente corrente + migrazione chiavi legacy nello spazio utente
  currentUser = username;
  migrateLegacyToUserStore();

// Pulizia una tantum abilit√† (salvataggi legacy/valori strani)
if (typeof normalizeAbilitiesObject === 'function') normalizeAbilitiesObject();

ensureKeyStores?.();

  // Mostra menu
  document.getElementById('login-section').classList.add('hidden');
  document.getElementById('menu').classList.remove('hidden');

// ‚úÖ PRIMA completa eventuali missioni scadute
resumeMissionIfNeeded();

// POI fai i reset / quest di login
try {
  if (typeof resetDailyQuestsIfNeeded === 'function') resetDailyQuestsIfNeeded();
  // ‚úÖ quest giornaliera "accesso di oggi"
  if (typeof setQuestProgress === 'function') setQuestProgress('q_daily_login', 1);
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
  if (typeof bumpWeeklyLoginIfNewDay === 'function') bumpWeeklyLoginIfNewDay();
} catch {}

  // Dati base profilo
  ensureHeroStats();
  // Sincronizza HP da heroDirectory (se esiste una entry con HP salvati)
  if (typeof syncHeroHpFromDirectory === 'function') {
    syncHeroHpFromDirectory(username);
  }


  document.getElementById('user-display').textContent = username;
  document.getElementById('hero-type').textContent = userStore.get('hero') || 'Nessuno';

  const gold = getNum('gold', 0);
  document.getElementById('hero-gold').innerHTML =
    `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  // Magia + Mani equipaggiate
  const savedMagic = userStore.get('magic') || 'Nessuna';
  updateMagicDisplay(savedMagic);

  const rightEl = document.getElementById('right-hand-display');
  if (rightEl) rightEl.textContent = userStore.get('rightHand') || 'Nessuna';

  const leftEl = document.getElementById('left-hand-display');
  if (leftEl) leftEl.textContent  = userStore.get('leftHand')  || 'Nessuna';

  // ‚úÖ Creatura equipaggiata
  if (typeof window.getEquippedCreature === 'function') {
    const ce = document.getElementById('equipped-creature');
    if (ce) ce.textContent = window.getEquippedCreature() || 'Nessuna';
  }

  // ‚úÖ Armatura equipaggiata
  if (typeof window.getEquippedArmor === 'function') {
    const ae = document.getElementById('equipped-armor');
    if (ae) ae.textContent = window.getEquippedArmor() || 'Nessuna';
  }

  // Badge messaggi (protetto)
  try { updateMessagesBadge(); } catch {}
// üî¥ Gilda: genera/aggiorna l‚Äôofferta segreta e i pallini subito al login
try { ensureGuildSpecialForCurrentWeek?.(); } catch {}
try { updateGuildBadges?.(); } catch {}
upsertCurrentHeroIntoDirectory();

}

// Normalizza nickname per il controllo "parolacce/bestemmie":
// - minuscole
// - sostituisce leet (0->o, 1->i, 3->e, 4->a, 5->s, 7->t, @->a, $->s)
// - rimuove tutto tranne lettere (toglie numeri e underscore)
// - collassa ripetizioni (es: caaaazzo -> caazo)
function normalizeNameForFilter(name){
  let s = String(name || '').toLowerCase();

  // leetspeak / sostituzioni comuni
  s = s
    .replace(/[@]/g, 'a')
    .replace(/[$]/g, 's')
    .replace(/[0]/g, 'o')
    .replace(/[1]/g, 'i')
    .replace(/[3]/g, 'e')
    .replace(/[4]/g, 'a')
    .replace(/[5]/g, 's')
    .replace(/[7]/g, 't');

  // tieni solo lettere (togli numeri e underscore)
  s = s.replace(/[^a-z]/g, '');

  // collassa ripetizioni: aaa -> a, cazzooo -> cazzo
  s = s.replace(/(.)\1+/g, '$1');

  return s;
}

async function register() {
  const raw = document.getElementById('reg-username').value || '';
  const username = raw.trim();
  const password = document.getElementById('reg-password').value;
  const email = document.getElementById('reg-email').value;

  // 1Ô∏è‚É£ lunghezza
  if (username.length < 3 || username.length > 12) {
    alert('Il nome utente deve avere tra 3 e 12 caratteri.');
    return;
  }

  // 2Ô∏è‚É£ caratteri consentiti
  if (!/^[A-Za-z0-9_]+$/.test(username)) {
    alert('Il nome utente pu√≤ contenere solo lettere, numeri e underscore (_).');
    return;
  }

  // 3Ô∏è‚É£ blacklist (match ESATTO)
  const USERNAME_BLACKLIST = [
    'admin','administrator','root','system','sys','gm',
    'game_master','gamemaster','moderator','mod','staff',
    'support','helper','dev','developer','owner'
  ];

  if (USERNAME_BLACKLIST.includes(username.toLowerCase())) {
    alert('Questo nome utente √® riservato e non pu√≤ essere utilizzato.');
    return;
  }
// üö´ FILTRO PAROLACCE/BESTEMMIE (normalizzato) ‚Äî messaggio generico
const normalized = normalizeNameForFilter(username);

// 1) Parolacce/insulti: blocco per "radici" (match dentro la stringa normalizzata)
const PROFANITY_ROOTS = [
  'cazz', 'merd', 'stronz', 'minch', 'vaff', 'puttan', 'troi', 'bastard',
  'cogl', 'figa', 'suca', 'incul', 'fott', 'scop'
];

// 2) Bestemmie: blocco SOLO se c'√® una combo "sacro + insulto"
// (evita falsi positivi tipo "diogene" che contiene "dio")
const SACRED = ['dio', 'gesu', 'cristo', 'madonna'];
const BLASPHEMY_MOD = ['porc', 'cane', 'boia', 'ladro', 'bestia', 'schif'];

const hasProfanity = PROFANITY_ROOTS.some(r => normalized.includes(r));

const hasBlasphemyCombo =
  SACRED.some(s => normalized.includes(s)) &&
  BLASPHEMY_MOD.some(m => normalized.includes(m));

if (hasProfanity || hasBlasphemyCombo) {
  alert('Il nome utente contiene termini non consentiti.');
  return;
}

  if (username && password && email) {
    await accountStore.setPassword(username, password); // ‚Üê HASH + SALT
    accountStore.setEmail(username, email);
    currentUser = username;
    document.getElementById('register-section').classList.add('hidden');
    document.getElementById('hero-choice').classList.remove('hidden');
  } else {
    alert("Compila tutti i campi!");
  }
}

// Variabile per tracciare eroe selezionato
let selectedHero = null;

// Setup eventi per scelta eroe
const heroListItems = document.querySelectorAll('#hero-choice-list li');
heroListItems.forEach(li => {
  li.addEventListener('click', () => {
    // Rimuovi classe selected da tutti
    heroListItems.forEach(el => el.classList.remove('selected'));
    // Aggiungi classe selected a quello cliccato
    li.classList.add('selected');
    selectedHero = li.getAttribute('data-hero');
    // Aggiorna descrizione
    document.getElementById('hero-description').textContent = heroDescriptions[selectedHero];
    // Abilita il pulsante conferma
    document.getElementById('hero-confirm-btn').disabled = false;
  });
});

function confirmHero() {
  if (!selectedHero) return;

  // salva eroe scelto
  userStore.set('hero', selectedHero);

  // registra/aggiorna subito nella Sala degli Eroi
  upsertCurrentHeroIntoDirectory();

  // oro iniziale + stats base
  setNum('gold', 20000);
  ensureHeroStats();
  ensureKeyStores?.();

  // Coerenza iniziale abilit√† anche per i nuovi account
  if (typeof normalizeAbilitiesObject === 'function') normalizeAbilitiesObject();

  // Frammenti e Cristalli iniziali (NEW: sempre zero alla registrazione)
  userStore.set('crystalParts', 0);
  userStore.set('crystals', 0);

  // Coerenza stato catena "Cristalli"
  userStore.set('mainCrystalUsed', 0);
  userStore.set('mainCrystalStep', 0);
  userStore.set('mainCrystalFinalClaimed', false);


  // UI oro
  const gold = getNum('gold', 0);
  document.getElementById('hero-gold').innerHTML =
    `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  // vai al menu
  document.getElementById('hero-choice').classList.add('hidden');
  document.getElementById('menu').classList.remove('hidden');
  document.getElementById('user-display').textContent = currentUser;
  document.getElementById('hero-type').textContent = selectedHero;
// azzera stato magie al primo avvio eroe
userStore.remove('magic');   // nessuna equipaggiata
userStore.set('magics', []); // inventario vuoto

  updateMagicDisplay('Nessuna');
  updateMessagesBadge();
  updateEquippedWeaponsUI();

  if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
  if (typeof updateGuildBadges === 'function') updateGuildBadges();
}


function logout() {
  currentUser = null;
  location.reload();
}
function showHeroProfile() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('hero-profile').classList.remove('hidden');
  document.getElementById('warrel-screen')?.classList.add('hidden');

  // Nasconde la schermata Abilit√† se era aperta
  document.getElementById('abilities')?.classList.add('hidden');

document.getElementById('motto-screen')?.classList.add('hidden');

  // Tipo eroe sempre aggiornato
  document.getElementById('hero-type').textContent = userStore.get('hero') || 'Nessuno';

  // [TAG] Nome eroe sotto il titolo
  (function updateHeroNameTag(){
    // Nome eroe = username (non modificabile)
    const username =
      (typeof currentUser === 'string' && currentUser) ?
      currentUser :
      (document.getElementById('user-display')?.textContent || '');

    // Ricava il TAG gilda dell‚Äôutente corrente
    let tagTxt = '';
    try {
      const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
      if (gid) {
        const all = (typeof getGuilds === 'function') ? getGuilds() : {};
        const g = all[gid];
        if (g && g.tag) tagTxt = `[${g.tag}] `;
      }
    } catch(e) {}

    const line = document.getElementById('hero-name-tag');
if (line) {
  // punti del mio eroe: preferisci directory ‚Üí fallback userStore
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const myId = 'user:' + username;
  const me = dir.find(h => h && h.id === myId) || {};
  const points = Number(
    (me.points != null ? me.points : (userStore.get('heroPoints') || userStore.get('points')))
    || 0
  );

  // calcolo rank globale (ordino per punti decrescenti)
  const sorted = dir.slice().sort((a,b)=> Number(b?.points||0) - Number(a?.points||0));
  const idx = sorted.findIndex(h => h && h.id === myId);
  const rank = (idx >= 0) ? (idx + 1) : '‚Äî';

  line.innerHTML = `${tagTxt}${escapeHtml(username)} <span class="muted" style="font-size:.9rem"><strong>(${points} pt)</strong></span>`;

  // riga sotto: Rank: ...
  let rankLine = document.getElementById('hero-rank-line');
  if (!rankLine) {
    rankLine = document.createElement('div');
    rankLine.id = 'hero-rank-line';
    // inserisci subito dopo l‚Äôheadline
    if (line.parentNode) line.parentNode.insertBefore(rankLine, line.nextSibling);
  }
  rankLine.innerHTML = `<strong>Rank: ${rank}</strong>`;
}

  })();

  // Oro corrente
  const gold = getNum('gold', 0);
  document.getElementById('hero-gold').innerHTML =
    `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

// Motto personale (centrato, non in grassetto)
try {
  const motto = (typeof getHeroMotto==='function') ? (getHeroMotto() || '') : '';
  const box = document.getElementById('hero-motto');
  if (box){
    if (motto) {
      box.textContent = motto;
      box.style.display = '';
    } else {
      box.textContent = '';       // nessun testo se vuoto
      box.style.display = '';     // oppure 'none' se preferisci nascondere
    }
  }
} catch(_) {}

// Reliquie di guerra: mostra/nasconde bottone + render pubblicazione
try {
  const me = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
  const btnHeader = document.getElementById('war-relics-header');
  const pubBox = document.getElementById('war-relics-published');

  if (btnHeader) {
    let hasAny = false;
    if (typeof listWarRelicsForUser === 'function' && me) {
      const list = listWarRelicsForUser(me) || [];
      hasAny = list.length > 0;
    }
    // Mostra il bottone solo se l'eroe possiede almeno una reliquia
    btnHeader.style.display = hasAny ? 'block' : 'none';
  }

  if (pubBox) {
    let html = '';
    if (typeof getPublishedWarRelicForUser === 'function' && me) {
      const pub = getPublishedWarRelicForUser(me);
      if (pub) {
        // Solo la card sottile, senza titolo/riquadro, testo leggermente pi√π piccolo
        html = `
          <div class="card" style="padding:6px 8px; border-radius:8px; background:#fff; border:1px solid #d0caa9;">
            <span style="font-size:0.92em;">${pub.textHtml}</span>
          </div>`;
      }
    }
    pubBox.innerHTML = html;
  }

} catch (_){}


  // Livello + XP progress + HP
  ensureHeroStats();
  updateHeroLevelUI();
  updateHeroHealthUI(); // ‚Üê AGGIUNTO
  updateEquippedWeaponsUI();
  if (typeof updateHeroPowerUI === 'function') {
    updateHeroPowerUI();
  }



  // Badge "Punti Abilit√†" accanto al pulsante Abilit√†
  const ap = getAbilityPoints ? getAbilityPoints() : 0;
  const apBadge = document.getElementById('ability-points-badge');
  if (apBadge) {
    if (ap > 0) {
      apBadge.textContent = `+${ap}`;
      apBadge.style.display = 'inline-block';
    } else {
      apBadge.textContent = '';
      apBadge.style.display = 'none';
    }
  }

  // ‚úÖ Creatura equipaggiata (mostra "Nessuna" se non c'√®)
  const eqCreature = window.getEquippedCreature && window.getEquippedCreature();
  const creatureEl = document.getElementById('equipped-creature');
  if (creatureEl) {
    if (eqCreature) {
      if (typeof ensureCreatureXpMap === 'function') ensureCreatureXpMap();
      const xp = (typeof getCreatureXp === 'function') ? getCreatureXp(eqCreature) : 0;
      creatureEl.textContent = `${eqCreature} (${xp} xp)`;
    } else {
      creatureEl.textContent = 'Nessuna';
    }
  }

  // ‚úÖ Armatura equipaggiata (mostra "Nessuna" se non c'√®)
  const eqArmor = window.getEquippedArmor && window.getEquippedArmor();
  const armorEl = document.getElementById('equipped-armor');
  if (armorEl) armorEl.textContent = eqArmor || 'Nessuna';
}

// ‚Äî‚Äî‚Äî Apertura schermata ‚ÄúMotto Personale‚Äù ‚Äî‚Äî‚Äî
function openMottoScreen(){
  // nascondi altre viste
  document.getElementById('menu')?.classList.add('hidden');
  document.getElementById('hero-profile')?.classList.add('hidden');
  document.getElementById('abilities')?.classList.add('hidden');
  document.getElementById('inventory')?.classList.add('hidden');

  // mostra editor
  document.getElementById('motto-screen')?.classList.remove('hidden');

  // precompila con motto corrente
  try {
    const cur = (typeof getHeroMotto==='function') ? getHeroMotto() : '';
    const inp = document.getElementById('motto-input');
    if (inp) {
      inp.value = cur || '';
      inp.focus();
      // sposta il cursore in fondo
      setTimeout(()=>{ inp.selectionStart = inp.selectionEnd = inp.value.length; }, 0);
    }
  } catch(_) {}

  // wiring bottoni
  const confirmBtn = document.getElementById('motto-confirm');
  const backBtn = document.getElementById('motto-back');

  if (confirmBtn) confirmBtn.onclick = () => {
    const inp = document.getElementById('motto-input');
    let val = (inp?.value || '').trim();
    if (val.length > 45) val = val.slice(0,45);

    // salva + storico (solo se c'√® qualcosa di non vuoto; se vuoi archiviare anche stringa vuota, togli l'if)
    if (typeof setHeroMotto === 'function') setHeroMotto(val);
    if (val && typeof addHeroMottoHistory === 'function') addHeroMottoHistory(val);

    // torna al profilo e aggiorna
    showHeroProfile();
  };

  if (backBtn) backBtn.onclick = () => {
    showHeroProfile();
  };
}

function openWarRelicsScreen(){
  // mostra schermata dedicata
  document.getElementById('menu')?.classList.add('hidden');
  document.getElementById('hero-profile')?.classList.add('hidden');
  document.getElementById('abilities')?.classList.add('hidden');
  document.getElementById('inventory')?.classList.add('hidden');
  document.getElementById('motto-screen')?.classList.add('hidden');

  document.getElementById('warrel-screen')?.classList.remove('hidden');

  renderWarRelicsList();
}

function renderWarRelicsList(){
  const body = document.getElementById('warrel-body');
  if (!body) return;
  const me = (typeof currentUser==='string' && currentUser) ? currentUser : (document.getElementById('user-display')?.textContent || '');
  const list = (typeof listWarRelicsForUser==='function') ? listWarRelicsForUser(me) : [];

  if (!list || !list.length){
    body.innerHTML = `<div class="muted">Non possiedi ancora alcuna reliquia di guerra.</div>`;
    return;
  }

  body.innerHTML = list.map(r => `
    <div class="card" style="padding:8px; border-radius:10px; background:#f6ecd1; border:1px solid #d0caa9; display:flex; justify-content:space-between; align-items:center; gap:8px;">
      <div>${r.textHtml}</div>
      <div>
        <button class="mini-button" data-publish="${r.id}">Pubblica</button>
      </div>
    </div>
  `).join('');

  // Wiring dei pulsanti "Pubblica"
  body.querySelectorAll('[data-publish]').forEach(btn=>{
    btn.onclick = ()=>{
      const rid = btn.getAttribute('data-publish');
      if (typeof publishWarRelicForUser==='function'){
        publishWarRelicForUser(me, rid);
      }
      // torna al profilo e aggiorna
      showHeroProfile();
    };
  });

  // Pulsante "Elimina pubblicazione"
  const clearBtn = document.getElementById('warrel-clear');
  if (clearBtn) clearBtn.onclick = ()=>{
    if (typeof clearPublishedWarRelicForUser==='function'){
      clearPublishedWarRelicForUser(me);
    }
    showHeroProfile();
  };

  const backBtn = document.getElementById('warrel-back');
  if (backBtn) backBtn.onclick = ()=> showHeroProfile();
}

function goBack() {
  // üî¥ ferma sempre il countdown energia se era attivo (Dungeon)
  if (typeof stopEnergyTicker === 'function') stopEnergyTicker();

  // Chiude eventuale overlay "Battaglia in corso"
  document.getElementById('dungeon-battle-overlay')?.style && (document.getElementById('dungeon-battle-overlay').style.display = 'none');

  document.getElementById('hero-profile').classList.add('hidden');
  document.getElementById('settings').classList.add('hidden');
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('abilities')?.classList.add('hidden');
  document.getElementById('weapon-storage')?.classList.add('hidden');
  document.getElementById('magic-storage')?.classList.add('hidden');
  document.getElementById('armor-storage')?.classList.add('hidden');
  document.getElementById('creature-storage')?.classList.add('hidden');
  document.getElementById('missions')?.classList.add('hidden');
  document.getElementById('challenges')?.classList.add('hidden');
  document.getElementById('messages')?.classList.add('hidden');
  document.getElementById('leaderboard')?.classList.add('hidden');
  document.getElementById('warrel-screen')?.classList.add('hidden');

  document.getElementById('menu').classList.remove('hidden');
if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
if (typeof updateGuildBadges === 'function') updateGuildBadges();

  // Chiude eventuale popup messaggio se aperto
  document.getElementById('message-popup')?.classList.add('hidden');
  document.getElementById('message-overlay')?.classList.add('hidden');

  document.getElementById('creature-select-overlay')?.classList.add('hidden');
  document.getElementById('creature-select-popup')?.classList.add('hidden');
  document.getElementById('armor-detail')?.classList.add('hidden');
  document.getElementById('armor-overlay')?.classList.add('hidden');

  // Chiude anche l‚Äôoverlay generico (per Magic, Hand, Mission detail, ecc.)
  document.getElementById('generic-overlay')?.classList.add('hidden');
}
// === Abilit√†: UI e gestione =====
let _pendingAbilities = {};   // delta temporanei non salvati (es. { Forza: +2, ... })
let _pendingSpent = 0;        // punti abilit√† usati ma non ancora salvati

function showAbilities() {
  // Nascondi altre viste
  document.getElementById('menu')?.classList.add('hidden');
  document.getElementById('hero-profile')?.classList.add('hidden');
  document.getElementById('inventory')?.classList.add('hidden');
  document.getElementById('shop')?.classList.add('hidden');
  document.getElementById('missions')?.classList.add('hidden');
  document.getElementById('messages')?.classList.add('hidden');
  document.getElementById('settings')?.classList.add('hidden');

  // Normalizza l‚Äôoggetto abilit√†
  normalizeAbilitiesObject?.();

  // Reset temporanei
  _pendingAbilities = {};
  _pendingSpent = 0;

  // Mostra schermata abilit√†
  document.getElementById('abilities')?.classList.remove('hidden');

  // üëâ Ri-mostra il pulsante (sar√† stato nascosto dopo un riassetto)
const respecCard = document.getElementById('abilities-respec-card');
if (respecCard) respecCard.classList.remove('hidden');


  renderAbilitiesUI();
}

function renderAbilitiesUI() {
  const listEl = document.getElementById('abilities-list');
  const saveBtn = document.getElementById('abilities-save');

  const abilities = getAbilities();             // da storage.js
  const available = getAbilityPoints();         // da storage.js

  // Aggiorna intestazione punti
  const ptsEl = document.getElementById('ability-points-display');
  if (ptsEl) ptsEl.innerHTML = `<strong>Punti Abilit√† disponibili:</strong> ${available - _pendingSpent}`;

  // Rendering elenco
  listEl.innerHTML = '';
  ABILITIES_LIST.forEach(name => {
  const current = abilities[name] || 0;
  const delta = _pendingAbilities[name] || 0;
  const shown = current + delta;

  const row = document.createElement('div');
  row.style.margin = '6px 0';

  // Testo: "Forza (0)"
  const text = document.createElement('span');
  text.textContent = `${name} (${shown})`;

  // Pulsante "+"
  const plus = document.createElement('button');
  plus.textContent = '+';
  plus.className = 'tiny-btn';
  // MOSTRA il "+" solo se ci sono PA liberi
  const paLiberi = (available - _pendingSpent);
  plus.style.display = paLiberi > 0 ? 'inline-block' : 'none';
  plus.disabled = paLiberi <= 0;

  plus.onclick = () => {
    if ((available - _pendingSpent) <= 0) return;
    _pendingAbilities[name] = (_pendingAbilities[name] || 0) + 1;
    _pendingSpent += 1;
    renderAbilitiesUI();
  };

  // Pulsante "-" (visibile solo se c'√® delta > 0)
  const minus = document.createElement('button');
  minus.textContent = '‚àí';
  minus.className = 'tiny-btn minus';
  minus.style.display = (delta > 0) ? 'inline-block' : 'none';

  minus.onclick = () => {
    if ((_pendingAbilities[name] || 0) <= 0) return;
    _pendingAbilities[name] -= 1;
    _pendingSpent -= 1;
    if (_pendingAbilities[name] <= 0) delete _pendingAbilities[name];
    renderAbilitiesUI();
  };

  row.appendChild(text);
  row.appendChild(plus);
  row.appendChild(minus);
  listEl.appendChild(row);
});


  // Bottone Salva
  // Bottone Salva visibile SOLO se ci sono modifiche
if (_pendingSpent > 0) {
  saveBtn.style.display = 'inline-block';
} else {
  saveBtn.style.display = 'none';
}

saveBtn.onclick = () => {
  // Applica i delta alle abilit√†
  const abilities = getAbilities();
  Object.keys(_pendingAbilities).forEach(k => {
    abilities[k] = (abilities[k] || 0) + _pendingAbilities[k];
  });
  setAbilities(abilities);

  // ‚úÖ SCALA i punti abilit√† reali del giocatore
  if ((Number(_pendingSpent) || 0) > 0) {
    spendAbilityPoints(Number(_pendingSpent)); // <<< QUESTO SISTEMA IL BUG
  }

  // ‚úÖ Aggiorna la quest "punti abilit√† utilizzati"
  if (typeof incrementMainApUsed === 'function' && (Number(_pendingSpent) || 0) > 0) {
    incrementMainApUsed(Number(_pendingSpent));
  }

  // Quest giornaliera (se esiste)
  if (typeof incrementQuest === 'function') incrementQuest('q_daily_use_6ap', _pendingSpent);

  // Aggiorna UI
  renderQuestsUI?.();
  updateQuestsBadge?.();

  // Reset contatori temporanei
  _pendingAbilities = {};
  _pendingSpent = 0;

  renderAbilitiesUI();
};

}
// ===== Riassetto Abilit√† =====
const ABILITIES_RESPEC_COST = 100000;

function ensureAbilitiesRespecModal() {
  // Overlay
  let overlay = document.getElementById('abilities-respec-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'abilities-respec-overlay';
    overlay.className = 'hidden';
    overlay.onclick = closeAbilitiesRespec;
    document.body.appendChild(overlay);
  }

  // Modal
  let modal = document.getElementById('abilities-respec-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'abilities-respec-modal';
    modal.className = 'hidden';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');

    modal.innerHTML = `
      <p class="hero-change-headline">Riforgia i tuoi talenti: azzera le abilit√† e recupera i punti.</p>
      <div id="abilities-respec-body"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="abilities-respec-confirm" class="magic-button" disabled>Conferma</button>
        <button class="magic-button" onclick="closeAbilitiesRespec()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
}
let _shieldTimer = null;

function ensureShieldModal(){
  let overlay = document.getElementById('shield-overlay');
  if (!overlay){
    overlay = document.createElement('div');
    overlay.id = 'shield-overlay';
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closeShieldPopup;
    document.body.appendChild(overlay);
  }

  let modal = document.getElementById('shield-modal');
  if (!modal){
    modal = document.createElement('div');
    modal.id = 'shield-modal';
    modal.className = 'hidden modal-common';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');

    modal.innerHTML = `
      <p class="hero-change-headline">üõ°Ô∏è Scudo</p>
      <div class="muted" style="margin-bottom:10px;">
        Lo Scudo ti protegge dalle <strong>sfide tra eroi</strong>.
        Finch√© √® attivo <strong>non puoi essere sfidato</strong> e <strong>non puoi sfidare altri eroi</strong>.
        Puoi comunque fare <strong>missioni</strong>, <strong>dungeon</strong> e <strong>torre delle prove</strong>.
      </div>

      <div id="shield-status" style="margin:10px 0;"></div>

      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:10px 0;">
        <label for="shield-units" class="muted">Usa scudi:</label>
        <input id="shield-units" type="number" min="1" step="1" value="1" style="width:80px;padding:6px;">
        <button id="shield-activate" class="magic-button">Attiva (5 ore ciascuno)</button>
      </div>

      <div class="modal-actions modal-actions--stack">
        <button id="shield-deactivate" class="magic-button">Disattiva scudo</button>
        <button class="magic-button" onclick="closeShieldPopup()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
}

function closeShieldPopup(){
  document.getElementById('shield-overlay')?.classList.add('hidden');
  document.getElementById('shield-modal')?.classList.add('hidden');
  if (_shieldTimer) { clearInterval(_shieldTimer); _shieldTimer = null; }
}

function _renderShieldPopup(){
  if (typeof ensureShieldState === 'function') ensureShieldState();

  const status = document.getElementById('shield-status');
  const unitsInput = document.getElementById('shield-units');
  const actBtn = document.getElementById('shield-activate');
  const deactBtn = document.getElementById('shield-deactivate');

  const left = (typeof getShieldUnitsLeft === 'function') ? getShieldUnitsLeft() : 0;
  const active = (typeof isShieldActive === 'function') ? isShieldActive() : false;
  const remTxt = (typeof getShieldRemainingText === 'function') ? getShieldRemainingText() : '‚Äî';

  if (unitsInput){
    unitsInput.max = String(Math.max(1, left));
    if (Number(unitsInput.value || 1) > left) unitsInput.value = String(Math.max(1, left));
    unitsInput.disabled = (left <= 0);
  }

  if (actBtn){
    actBtn.disabled = (left <= 0);
  }

  if (deactBtn){
    deactBtn.style.display = active ? '' : 'none';
  }

  if (status){
    status.innerHTML = `
      <div><strong>Scudi disponibili questo mese:</strong> ${left}/30</div>
      <div><strong>Stato:</strong> ${active ? 'ATTIVO' : 'Non attivo'}</div>
      <div><strong>Tempo rimanente:</strong> ${active ? remTxt : '‚Äî'}</div>
      ${active ? `<div class="muted" style="margin-top:6px;">Se disattivi lo scudo, il tempo rimanente andr√† perso.</div>` : ''}
    `;
  }
}
function updateShieldLinkLabel(){
  const label = document.getElementById('shield-active-label');
  if (!label) return;

  const active = (typeof isShieldActive === 'function') ? isShieldActive() : false;
  label.textContent = active ? ' (Attivo)' : '';
}
// stesso tab
window.addEventListener('shield:updated', updateShieldLinkLabel);

// cross-tab (storage.js scrive mitharia_signal = "shield:<timestamp>")
window.addEventListener('storage', (e)=>{
  if (e && e.key === 'mitharia_signal' && /^shield:/.test(String(e.newValue || ''))) {
    updateShieldLinkLabel();
  }
});

function openShieldPopup(){
  ensureShieldModal();
  document.getElementById('shield-overlay')?.classList.remove('hidden');
  document.getElementById('shield-modal')?.classList.remove('hidden');

  _renderShieldPopup();

  const actBtn = document.getElementById('shield-activate');
  const deactBtn = document.getElementById('shield-deactivate');

  if (actBtn && !actBtn._bound){
    actBtn._bound = true;
    actBtn.onclick = () => {
      const units = Math.max(1, Math.floor(Number(document.getElementById('shield-units')?.value || 1)));
      const res = (typeof activateShield === 'function') ? activateShield(units) : { ok:false };
      if (!res.ok){
        showGameMessage('Scudi insufficienti', 'Non hai abbastanza scudi disponibili questo mese.');
        _renderShieldPopup();
        return;
      }
      showGameMessage('Scudo attivato', `Hai attivato lo scudo. Durata aggiunta: <strong>${units * 5} ore</strong>.`);
      _renderShieldPopup();
    };
  }

  if (deactBtn && !deactBtn._bound){
    deactBtn._bound = true;
    deactBtn.onclick = () => {
      if (typeof deactivateShield === 'function') deactivateShield();
      showGameMessage('Scudo disattivato', 'Lo scudo √® stato disattivato. Il tempo rimanente √® stato perso.');
      _renderShieldPopup();
    };
  }

  if (_shieldTimer) clearInterval(_shieldTimer);
  _shieldTimer = setInterval(_renderShieldPopup, 1000);
}

function closeAbilitiesRespec() {
  document.getElementById('abilities-respec-overlay')?.classList.add('hidden');
  document.getElementById('abilities-respec-modal')?.classList.add('hidden');
}

function openAbilitiesRespec() {
  ensureAbilitiesRespecModal();

  const overlay    = document.getElementById('abilities-respec-overlay');
  const modal      = document.getElementById('abilities-respec-modal');
  const body       = document.getElementById('abilities-respec-body');
  const confirmBtn = document.getElementById('abilities-respec-confirm');

  if (!overlay || !modal || !body || !confirmBtn) return;

  // reset bottone
  confirmBtn.textContent = 'Conferma';
  confirmBtn.disabled = true;
  confirmBtn.removeAttribute('title');

  const gold = getNum('gold', 0);
  const abilities = getAbilities(); // da storage.js
  // Somma dei punti attualmente ASSEGNATI (solo abilit√† ufficiali)
  const assigned = ABILITIES_LIST.reduce((sum, name) => sum + (Number(abilities?.[name]) || 0), 0);

  body.innerHTML = `
    <div class="hero-change-meta">
      <span class="gold">Oro disponibile: <strong>${formatGold(gold)}</strong> monete d'oro</span>
    </div>
    <div class="hero-change-meta">
      <span class="cost">Costo: <strong>${formatGold(ABILITIES_RESPEC_COST)}</strong> monete d'oro</span>
    </div>

    <p style="margin:8px 0 0 0;">Confermando, tutte le abilit√† torneranno a <strong>0</strong> e recupererai <strong>${assigned}</strong> Punti Abilit√† da ridistribuire.</p>
    <div id="abilities-respec-status"></div>
  `;

  // Layer di conferma (popup sopra il modal), creato una volta sola
  let confirmLayer = modal.querySelector('#abilities-respec-confirm-layer');
  if (!confirmLayer) {
    confirmLayer = document.createElement('div');
    confirmLayer.id = 'abilities-respec-confirm-layer';
    confirmLayer.className = 'hidden';
    confirmLayer.innerHTML = `
      <div class="confirm-backdrop"></div>
      <div class="confirm-dialog">
        <p id="abilities-respec-confirm-text"></p>
        <div class="confirm-actions">
          <button id="abilities-respec-accept" class="magic-button">S√¨, riassetta abilit√†</button>
          <button id="abilities-respec-cancel" class="magic-button">Annulla</button>
        </div>
      </div>
    `;
    modal.appendChild(confirmLayer);
  }

  const status      = document.getElementById('abilities-respec-status');
  const confirmText = confirmLayer.querySelector('#abilities-respec-confirm-text');
  const acceptBtn   = confirmLayer.querySelector('#abilities-respec-accept');
  const cancelBtn   = confirmLayer.querySelector('#abilities-respec-cancel');
  const hideLayer   = () => {
    confirmLayer.classList.add('hidden');
    acceptBtn.disabled = false; // safety: pronto per il prossimo giro
  };

  // reset del layer di conferma ad ogni apertura
  acceptBtn.disabled = false;       // reset debounce da giri precedenti
  confirmText.innerHTML = '';       // pulisci eventuale testo vecchio
  confirmLayer.classList.add('hidden'); // assicurati che parta nascosto

  cancelBtn.onclick = hideLayer;
  confirmLayer.querySelector('.confirm-backdrop').onclick = hideLayer;

  // Stato iniziale: bottone disabilitato se:
  // - non hai oro sufficiente
  // - oppure non ci sono punti assegnati da recuperare
  if (assigned <= 0) {
    confirmBtn.disabled = true;
    confirmBtn.title = 'Non hai punti assegnati da recuperare.';
    status.innerHTML = `<span class="err">Non hai abilit√† assegnate da azzerare.</span>`;
  } else if (gold < ABILITIES_RESPEC_COST) {
    const diff = ABILITIES_RESPEC_COST - gold;
    confirmBtn.disabled = true;
    confirmBtn.title = `Ti servono altri ${formatGold(diff)} oro`;
    status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
  } else {
    confirmBtn.disabled = false;
    confirmBtn.removeAttribute('title');
    status.innerHTML = '';
  }

  // Step 1: "Conferma" -> mostra il popup di conferma
  confirmBtn.onclick = () => {
    if (confirmBtn.disabled) return;

    const nowGold = getNum('gold', 0);
    const curAssigned = ABILITIES_LIST.reduce((sum, name) => sum + (Number(getAbilities()?.[name]) || 0), 0);

    if (curAssigned <= 0) {
      status.innerHTML = `<span class="err">Non hai abilit√† assegnate da azzerare.</span>`;
      confirmBtn.disabled = true;
      confirmBtn.title = 'Nessun punto da recuperare';
      return;
    }
    if (nowGold < ABILITIES_RESPEC_COST) {
      const diff = ABILITIES_RESPEC_COST - nowGold;
      status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
      confirmBtn.disabled = true;
      confirmBtn.title = `Ti servono altri ${formatGold(diff)} oro`;
      return;
    }

    confirmText.innerHTML =
      `Sei pronto a dissolvere i tuoi talenti e riforgiarli da capo? `
      + `Il rito azzerer√† tutte le abilit√† e ti restituir√† <strong>${curAssigned}</strong> Punti Abilit√† `
      + `da ridistribuire. Costo: <strong>${formatGold(ABILITIES_RESPEC_COST)}</strong> monete d'oro.`;

    acceptBtn.disabled = false;       // assicurati sia cliccabile ogni volta
    confirmLayer.classList.remove('hidden');
  };

  // Step 2: "S√¨, riassetta abilit√†" -> applica davvero
  acceptBtn.onclick = () => {
    acceptBtn.disabled = true;

    const nowGold = getNum('gold', 0);
    const curAbilities = getAbilities();
    const curAssigned = ABILITIES_LIST.reduce((sum, name) => sum + (Number(curAbilities?.[name]) || 0), 0);

    if (curAssigned <= 0) {
      status.innerHTML = `<span class="err">Non hai abilit√† assegnate da azzerare.</span>`;
      acceptBtn.disabled = false;
      hideLayer();
      return;
    }
    if (nowGold < ABILITIES_RESPEC_COST) {
      const diff = ABILITIES_RESPEC_COST - nowGold;
      status.innerHTML = `<span class="err">Oro insufficiente ‚Äî ti mancano ${formatGold(diff)} monete d'oro.</span>`;
      acceptBtn.disabled = false;
      hideLayer();
      return;
    }

    // 1) Scala oro
    addNum('gold', -ABILITIES_RESPEC_COST);

    // 2) Restituisci i punti assegnati
    addAbilityPoints(curAssigned);

    // 3) Azzera tutte le abilit√†
    const zero = {};
    (Array.isArray(ABILITIES_LIST) ? ABILITIES_LIST : Object.keys(curAbilities))
      .forEach(n => { zero[n] = 0; });
    setAbilities(zero);

    // 4) Reset temporanei UI e refresh
    if (typeof renderAbilitiesUI === 'function') {
      if (typeof window._pendingAbilities !== 'undefined') window._pendingAbilities = {};
      if (typeof window._pendingSpent !== 'undefined') window._pendingSpent = 0;
      renderAbilitiesUI();
    }

    // 5) Aggiorna oro nel profilo (se visibile)
    const goldEl = document.getElementById('hero-gold');
    if (goldEl) {
      const newGold = getNum('gold', 0);
      goldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(newGold)} monete d'oro`;
    }

    // 6) Messaggio finale epico
    showGameMessage(
      'Talento riforgiato',
      `Le tue capacit√† si dissolvono e rifioriscono: hai recuperato <strong>${curAssigned}</strong> Punti Abilit√†, pronti per essere incisi di nuovo.`
    );

// Nascondi il pulsante "Riassetta Abilit√†" mentre stai ridistribuendo
const respecCard = document.getElementById('abilities-respec-card');
if (respecCard) respecCard.classList.add('hidden');

    closeAbilitiesRespec();
  };

  // Mostra modal
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');
}

function showSettings() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('settings').classList.remove('hidden');
}
function deleteAccount() {
  if (!currentUser) return;

  if (confirm("Sei sicuro di voler cancellare il tuo account?")) {
    // 1) elimina credenziali globali (password/email)
    if (typeof accountStore?.deleteAccount === 'function') {
      accountStore.deleteAccount(currentUser);
    }
    // 2) elimina tutti i dati namespaced dell‚Äôutente
    wipeUser();
    // 3) chiudi la sessione e ricarica
    currentUser = null;
    location.reload();
  }
}
// === CONFIG: prima quest ===
const QUESTS = [
  {
    id: 'q_daily_login',
    name: 'Accesso giornaliero',
    reset: 'daily',
    goal: 1,
    reward: { gold: 100 }
  },
  {
    id: 'q_daily_6missions',
    name: 'Effettua 6 missioni',
    reset: 'daily',
    goal: 6,
    reward: { gold: 150 }
  },
{
    id: 'q_daily_dungeon_5challenges',
    name: 'Completa 5 sfide nel dungeon',
    reset: 'daily',
    goal: 5,
    reward: { gold: 150 }
  },
{
  id: 'q_daily_5sfide',
  name: 'Completa 5 sfide',
  reset: 'daily',
  goal: 5,
  reward: { gold: 150, energyDungeon: 2 }
},
{
  id: 'q_daily_guild_donate_500gold',
  name: "Dona 500 monete d'oro alla gilda",
  reset: 'daily',
  goal: 500,
  reward: { energySfide: 4 } // +4 Energia Sfide
},
{
  id: 'q_daily_get_crystal_part',
  name: 'Ottieni un frammento di cristallo di potenziamento',
  reset: 'daily',
  goal: 1,
  reward: { potionId: 'pot_small', potionQty: 1 } // 1x Pozione Salute Piccola
},
{
  id: 'q_daily_guild_shop_buy_1',
  name: 'Fai un acquisto al negozio della gilda',
  reset: 'daily',
  goal: 1,
  reward: { arcaneDust: 1 }
},
{
  id: 'q_daily_use_6ap',
  name: 'Utilizza 6 punti abilit√†',
  reset: 'daily',
  goal: 6,
  reward: { gold: 200 }
},
{
  id: 'q_daily_classic_shop_buy_equipment',
  name: 'Acquista un equipaggiamento dalla bottega',
  reset: 'daily',
  goal: 1,
  reward: { gold: 200, potionId: 'pot_small', potionQty: 1 }
},
{
  id: 'q_daily_win_creature_only',
  name: 'Vinci una sfida equipaggiando solo la creatura',
  reset: 'daily',
  goal: 1,
  reward: { gold: 300 }
},
{
  id: 'q_daily_sell_item_shop',
  name: 'Vendi un oggetto alla bottega',
  reset: 'daily',
  goal: 1,
  reward: { energyDungeon: 2 }
},
{
  id: 'q_daily_drink_medium_health_potion',
  name: 'Bevi una Pozione Salute Media',
  reset: 'daily',
  goal: 1,
  reward: { potionId: 'pot_small', potionQty: 1 }
},
{
  id: 'q_daily_enter_guild_mine_once',
  name: 'Entra nella Miniera della Gilda',
  reset: 'daily',
  goal: 1,
  reward: {
    gold: 200,
    potionId: 'pot_small',
    potionQty: 1
  }
},
{
  id: 'q_daily_complete_8_dailies',
  name: 'Completa 8 quest giornaliere',
  reset: 'daily',
  goal: 8,
  reward: { gold: 1000 }
}
];

// === QUEST SETTIMANALI ======================================================
const QUESTS_WEEKLY = [
  {
    id: 'q_weekly_login_7days',
    name: 'Accedi ogni giorno della settimana',
    reset: 'weekly',
    goal: 7,
    reward: { gold: 1000 }
  },
  {
    id: 'q_weekly_30missions',
    name: 'Completa 30 missioni',
    reset: 'weekly',
    goal: 30,
    reward: { gold: 1000 }
  },
{
    id: 'q_weekly_dungeon_30challenges',
    name: 'Completa 30 sfide Dungeon',
    reset: 'weekly',
    goal: 30,
    reward: { gold: 1200, potionId: 'pot_medium', potionQty: 1 }
  },
{
  id: 'q_weekly_30challenges',
  name: 'Completa 30 sfide',
  reset: 'weekly',
  goal: 30,
  reward: { gold: 1200, potionId: 'pot_medium', potionQty: 1 }
},
{
  id: 'q_weekly_guild_donate_3000',
  name: 'Dona 3000 oro alla gilda',
  reset: 'weekly',
  goal: 3000, // ‚Üê conta l‚Äôammontare donato
  reward: { energySfide: 12, arcaneDust: 1 }
},
{
  id: 'q_weekly_fuse_crystal',
  name: 'Fondi un cristallo di potenziamento',
  reset: 'weekly',
  goal: 1,
  reward: { gold: 1000, crystalParts: 1 } // 1000 oro + 1 frammento
},
{
  id: 'q_weekly_level_up',
  name: 'Avanza di un livello esperienza',
  reset: 'weekly',
  goal: 1,
  reward: { gold: 1000 }
},
{
  id: 'q_weekly_open_chest',
  name: 'Apri un forziere',
  reset: 'weekly',
  goal: 1,
  reward: { gold: 2000, arcaneDust: 3 }
}
];

// === QUEST PRINCIPALI: Catena "Livello Eroe" =================================
// Mostriamo solo lo step corrente (Opzione A). Al claim dello step -> avanza al successivo.
// All‚Äôultimo step, dopo il claim, resta visibile come "Ricompensa riscossa".
const MAIN_LEVEL_CHAIN = [
  { level: 2,   reward: { gold: 1000 } },
  { level: 5,   reward: { gold: 2000, potionId: 'pot_medium', potionQty: 1 } },
  { level: 10,  reward: { gold: 2000, arcaneDust: 2 } },
  { level: 20,  reward: { gold: 5000, arcaneDust: 5 } },
  { level: 30,  reward: { keyId: 'ottone',     keyQty: 1 } }, // Chiave del Mercante
  { level: 40,  reward: { gold: 5000, arcaneDust: 10 } },
  { level: 50,  reward: { keyId: 'argento',    keyQty: 1 } }, // Chiave dell‚ÄôAvventuriero
  { level: 60,  reward: { gold: 10000 } },
  { level: 70,  reward: { arcaneDust: 20, potionId: 'pot_small',  potionQty: 5 } },
  { level: 80,  reward: { gold: 20000, potionId: 'pot_medium',    potionQty: 5 } },
  { level: 90,  reward: { keyId: 'oro',        keyQty: 1 } }, // Chiave Del Re
  { level: 100, reward: { keyId: 'runica',     keyQty: 1 } }, // Chiave Arcana
];

// Stato persistito: userStore -> mainLevelStep (indice step corrente), mainLevelFinalClaimed (bool)
function ensureMainLevelState(){
  if (typeof userStore === 'undefined') return;
  if (userStore.get('mainLevelStep') == null) userStore.set('mainLevelStep', 0);
  if (userStore.get('mainLevelFinalClaimed') == null) userStore.set('mainLevelFinalClaimed', false);
}
function getMainLevelStep(){
  ensureMainLevelState();
  const idx = Number(userStore.get('mainLevelStep') || 0);
  return Math.max(0, Math.min(idx, MAIN_LEVEL_CHAIN.length - 1));
}
function setMainLevelStep(idx){
  ensureMainLevelState();
  userStore.set('mainLevelStep', Math.max(0, Math.min(Number(idx)||0, MAIN_LEVEL_CHAIN.length-1)));
}
function isMainLevelFinalClaimed(){
  ensureMainLevelState();
  return !!userStore.get('mainLevelFinalClaimed');
}
function setMainLevelFinalClaimed(v=true){
  ensureMainLevelState();
  userStore.set('mainLevelFinalClaimed', !!v);
}

// Dati utili
function getCurrentHeroLevel(){
  return (typeof getNum==='function') ? getNum('level', 1) : 1;
}
function mainLevelCurrentTarget(){
  const i = getMainLevelStep();
  return MAIN_LEVEL_CHAIN[i];
}
function mainLevelIsCompletedButUnclaimed(){
  // Completata se il livello attuale >= livello target, e NON √® ancora "final claimed" (solo per ultimo step)
  const cur = mainLevelCurrentTarget();
  const heroLv = getCurrentHeroLevel();
  const i = getMainLevelStep();
  const isLast = (i === MAIN_LEVEL_CHAIN.length - 1);
  if (heroLv >= cur.level){
    if (isLast) return !isMainLevelFinalClaimed();  // ultimo step: diventa "claimable" finch√© non riscossi
    return true; // step intermedio: claimable
  }
  return false;
}

// Applica ricompensa di uno step
function grantMainLevelReward(rew){
  // Oro
  if (Number(rew?.gold || 0) > 0 && typeof addNum === 'function') {
    addNum('gold', Number(rew.gold));
    updateGoldBadges?.();
  }
  // Polvere Arcana
  if (Number(rew?.arcaneDust || 0) > 0 && typeof addArcaneDust === 'function') {
    addArcaneDust(Number(rew.arcaneDust));
  }
  // Pozioni
  if (rew?.potionId && typeof addPotion === 'function') {
    const q = Number(rew.potionQty || 1);
    if (q > 0) addPotion(rew.potionId, q);
  }
  // Chiavi (id: ottone/argento/oro/runica)
  if (rew?.keyId && typeof addKey === 'function') {
    const q = Number(rew.keyQty || 1);
    if (q > 0) addKey(rew.keyId, q);
  }
}

// === QUEST PRINCIPALI: Catena "Gilda" ========================================
// Step 0: entra/crea gilda  ‚Üí poi una serie di donazioni con progressi per-step
const MAIN_GUILD_CHAIN = [
  { type: 'join',  title: 'Crea o entra in una gilda', reward: { gold: 2000 } },
  { type: 'donate', goal: 10000,   title: 'Dona 10.000 oro alla gilda',   reward: { crystalParts: 1 } },
  { type: 'donate', goal: 25000,   title: 'Dona 25.000 oro alla gilda',   reward: { potionId:'pot_large', potionQty:5 } },
  { type: 'donate', goal: 50000,   title: 'Dona 50.000 oro alla gilda',   reward: { keyId: 'ottone',  keyQty: 1 } }, // Mercante
  { type: 'donate', goal: 150000,  title: 'Dona 150.000 oro alla gilda',  reward: { keyId: 'argento', keyQty: 1 } }, // Avventuriero
  { type: 'donate', goal: 300000,  title: 'Dona 300.000 oro alla gilda',  reward: { keyId: 'oro',     keyQty: 1 } }, // Del Re
  { type: 'donate', goal: 500000,  title: 'Dona 500.000 oro alla gilda',  reward: { keyId: 'runica',  keyQty: 1 } }, // Arcana
];

// Stato: indice step + flag ultimo step riscosso + contatore donazioni per step
function ensureMainGuildState(){
  if (typeof userStore === 'undefined') return;
  if (userStore.get('mainGuildStep') == null) userStore.set('mainGuildStep', 0);
  if (userStore.get('mainGuildFinalClaimed') == null) userStore.set('mainGuildFinalClaimed', false);
  if (userStore.get('mainGuildDonation') == null) userStore.set('mainGuildDonation', 0);
}
function getMainGuildStep(){
  ensureMainGuildState();
  const idx = Number(userStore.get('mainGuildStep') || 0);
  return Math.max(0, Math.min(idx, MAIN_GUILD_CHAIN.length - 1));
}
function setMainGuildStep(idx){
  ensureMainGuildState();
  userStore.set('mainGuildStep', Math.max(0, Math.min(Number(idx)||0, MAIN_GUILD_CHAIN.length - 1)));
}
function isMainGuildFinalClaimed(){
  ensureMainGuildState();
  return !!userStore.get('mainGuildFinalClaimed');
}
function setMainGuildFinalClaimed(v=true){
  ensureMainGuildState();
  userStore.set('mainGuildFinalClaimed', !!v);
}
function getMainGuildDonation(){ ensureMainGuildState(); return Number(userStore.get('mainGuildDonation')||0); }
function setMainGuildDonation(v){ ensureMainGuildState(); userStore.set('mainGuildDonation', Math.max(0, Number(v)||0)); }
function resetMainGuildDonation(){ /* cumulativo: non si azzera pi√π */ }

// Dati correnti & condizione completamento
function mainGuildCurrentTarget(){
  const i = getMainGuildStep();
  return MAIN_GUILD_CHAIN[i];
}
function mainGuildIsCompletedButUnclaimed(){
  const step = mainGuildCurrentTarget();
  const i = getMainGuildStep();
  const isLast = (i === MAIN_GUILD_CHAIN.length - 1);

  if (step.type === 'join'){
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    if (!gid) return false;
    return isLast ? !isMainGuildFinalClaimed() : true;
  }
  if (step.type === 'donate'){
    const prog = getMainGuildDonation();
    const ok = prog >= Number(step.goal||0);
    if (!ok) return false;
    return isLast ? !isMainGuildFinalClaimed() : true;
  }
  return false;
}

// Incremento donazioni per lo step corrente (per-step, non cumulativo tra step)
function incrementMainGuildDonation(delta){
  const step = mainGuildCurrentTarget();
  if (!step || step.type !== 'donate') return;
  const add = Math.max(0, Number(delta)||0);
  if (!add) return;
  setMainGuildDonation(getMainGuildDonation() + add);
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

// Marcatura automatica dello step ‚Äújoin‚Äù quando entri/crei una gilda
function markMainGuildJoinCompletedIfNeeded(){
  const step = mainGuildCurrentTarget();
  if (!step || step.type !== 'join') return;
  const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
  if (gid) {
    // ora lo step √® completabile ‚Üí il claim lo fa l‚Äôutente cliccando
    if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
  }
}

// Ricompense per la catena Gilda
function grantMainGuildReward(rew){
  // Oro
  if (Number(rew?.gold || 0) > 0 && typeof addNum === 'function') {
    addNum('gold', Number(rew.gold));
    updateGoldBadges?.();
  }
  // Frammenti cristallo
  if (Number(rew?.crystalParts || 0) > 0) {
    const prev = Number(userStore.get('crystalParts')||0);
    userStore.set('crystalParts', prev + Number(rew.crystalParts));
  }
  // Polvere arcana (non prevista qui, ma per sicurezza)
  if (Number(rew?.arcaneDust || 0) > 0 && typeof addArcaneDust === 'function') {
    addArcaneDust(Number(rew.arcaneDust));
  }
  // Pozioni
  if (rew?.potionId && typeof addPotion === 'function') {
    const q = Number(rew.potionQty || 1);
    if (q > 0) addPotion(rew.potionId, q);
  }
  // Chiavi
  if (rew?.keyId && typeof addKey === 'function') {
    const q = Number(rew.keyQty || 1);
    if (q > 0) addKey(rew.keyId, q);
  }
}

// === MAIN WINS (Sfide PvP) ===================================================
const MAIN_WINS_CHAIN = [
  { goal: 30,   title: 'Vinci 30 sfide lanciate',    reward: { gold: 3000 } },
  { goal: 100,  title: 'Vinci 100 sfide lanciate',   reward: { crystalParts: 1 } }, // 1 frammento di cristallo
  { goal: 250,  title: 'Vinci 250 sfide lanciate',   reward: { gold: 10000, potionId: 'pot_medium', potionQty: 5 } },
  { goal: 450,  title: 'Vinci 450 sfide lanciate',   reward: { crystalParts: 3 } }, // 3 frammenti
  { goal: 700,  title: 'Vinci 700 sfide lanciate',   reward: { keyId: 'ottone',  keyQty: 1 } }, // Chiave del Mercante (ID corretto)
  { goal: 1000, title: 'Vinci 1000 sfide lanciate',  reward: { gold: 10000, arcaneDust: 20 } },
  { goal: 1500, title: 'Vinci 1500 sfide lanciate',  reward: { gold: 15000, arcaneDust: 30 } }, // se vuoi altro, dimmelo
  { goal: 2500, title: 'Vinci 2500 sfide lanciate',  reward: { keyId: 'argento', keyQty: 1 } }, // Chiave dell‚ÄôAvventuriero
  { goal: 4000, title: 'Vinci 4000 sfide lanciate',  reward: { keyId: 'oro',     keyQty: 1 } }, // Chiave del Re
  { goal: 6000, title: 'Vinci 6000 sfide lanciate',  reward: { keyId: 'runica',  keyQty: 1 } }  // Chiave Arcana
];

// --- Stato e logica: Wins PvP ------------------------------------------------
function ensureMainWinsState(){
  if (typeof userStore === 'undefined') return;
  if (userStore.get('mainWinsStep') == null) userStore.set('mainWinsStep', 0);
  if (userStore.get('mainWinsFinalClaimed') == null) userStore.set('mainWinsFinalClaimed', false);
  if (userStore.get('mainWinsTotal') == null) userStore.set('mainWinsTotal', 0); // cumulativo lifetime
}
function getMainWinsStep(){
  ensureMainWinsState();
  const idx = Number(userStore.get('mainWinsStep') || 0);
  return Math.max(0, Math.min(idx, MAIN_WINS_CHAIN.length - 1));
}
function setMainWinsStep(i){
  ensureMainWinsState();
  userStore.set('mainWinsStep', Math.max(0, Math.min(Number(i)||0, MAIN_WINS_CHAIN.length - 1)));
}
function isMainWinsFinalClaimed(){
  ensureMainWinsState(); return !!userStore.get('mainWinsFinalClaimed');
}
function setMainWinsFinalClaimed(v=true){
  ensureMainWinsState(); userStore.set('mainWinsFinalClaimed', !!v);
}
function getMainWinsTotal(){ ensureMainWinsState(); return Number(userStore.get('mainWinsTotal')||0); }
function setMainWinsTotal(v){ ensureMainWinsState(); userStore.set('mainWinsTotal', Math.max(0, Number(v)||0)); }

// Dato corrente + condizione
function mainWinsCurrentTarget(){
  const i = getMainWinsStep();
  return MAIN_WINS_CHAIN[i];
}
function mainWinsIsCompletedButUnclaimed(){
  const step = mainWinsCurrentTarget();
  const i = getMainWinsStep();
  const isLast = (i === MAIN_WINS_CHAIN.length - 1);
  const total = getMainWinsTotal();
  const ok = total >= Number(step.goal||0);
  if (!ok) return false;
  return isLast ? !isMainWinsFinalClaimed() : true;
}

// Accrescere il totale (chiamare SOLO quando vinci una sfida)
function incrementMainWinsOnVictory(n=1){
  setMainWinsTotal(getMainWinsTotal() + Math.max(0, Number(n)||0));
}

// Riscossione premio + avanzamento step
function mainWinsClaimReward(){
  const i = getMainWinsStep();
  const step = MAIN_WINS_CHAIN[i];
  if (!step) return;

  // accredita ricompense
const r = step.reward || {};
if (Number(r.gold||0) > 0) addNum('gold', Number(r.gold));

if (Number(r.arcaneDust||0) > 0 && typeof addArcaneDust === 'function') {
  addArcaneDust(Number(r.arcaneDust));
}

if (r.potionId && typeof addPotion === 'function') {
  addPotion(r.potionId, Number(r.potionQty||1));
}

// Frammenti di cristallo (stessa logica della catena Gilda)
if (Number(r.crystalParts||0) > 0) {
  const prev = Number(userStore.get('crystalParts')||0);
  userStore.set('crystalParts', prev + Number(r.crystalParts));
}

// Chiavi: id validi = ottone (Mercante), argento (Avventuriero), oro (Del Re), runica (Arcana)
if (r.keyId && typeof addKey === 'function') {
  addKey(r.keyId, Number(r.keyQty||1));
}

  // avanza o chiudi
  const isLast = (i === MAIN_WINS_CHAIN.length - 1);
  if (isLast) {
    setMainWinsFinalClaimed(true);
  } else {
    setMainWinsStep(i + 1);
    // NB: il totale resta cumulativo, NON si azzera
  }

  // feedback
if (typeof showGameMessage === 'function') {
  showGameMessage('Ricompensa', 'Hai ritirato la ricompensa!');
}


  // refresh UI + badge
  if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI();
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

  // eventuale aggiornamento oro visibile
  const g = getNum('gold', 0);
  const heroGoldEl = document.getElementById('hero-gold');
  if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;
  ['weapon-shop-gold','armor-shop-gold','magic-shop-gold'].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.textContent = formatGold(g);
  });
}

// === MAIN DUNGEON (Sfide Dungeon) ===========================================
const MAIN_DUNGEON_CHAIN = [
  { goal: 50,    title: 'Vinci 50 sfide dungeon',    reward: { gold: 3000 } },
  { goal: 200,   title: 'Vinci 200 sfide dungeon',   reward: { crystalParts: 1 } },
  { goal: 450,   title: 'Vinci 450 sfide dungeon',   reward: { gold: 10000, potionId: 'pot_medium', potionQty: 5 } },
  { goal: 800,   title: 'Vinci 800 sfide dungeon',   reward: { crystalParts: 3 } },
  { goal: 1200,  title: 'Vinci 1200 sfide dungeon',  reward: { keyId: 'ottone',  keyQty: 1 } }, // Mercante
  { goal: 1700,  title: 'Vinci 1700 sfide dungeon',  reward: { gold: 10000, arcaneDust: 20 } },
  { goal: 2500,  title: 'Vinci 2500 sfide dungeon',  reward: { gold: 15000, arcaneDust: 30 } },
  { goal: 4200,  title: 'Vinci 4200 sfide dungeon',  reward: { keyId: 'argento', keyQty: 1 } }, // Avventuriero
  { goal: 6800,  title: 'Vinci 6800 sfide dungeon',  reward: { keyId: 'oro',     keyQty: 1 } }, // Del Re
  { goal: 10000, title: 'Vinci 10000 sfide dungeon', reward: { keyId: 'runica',  keyQty: 1 } }  // Arcana
];

// --- Stato e logica: Wins Dungeon ------------------------------------------
function ensureMainDungeonState(){
  if (typeof userStore === 'undefined') return;
  if (userStore.get('mainDungeonStep') == null) userStore.set('mainDungeonStep', 0);
  if (userStore.get('mainDungeonFinalClaimed') == null) userStore.set('mainDungeonFinalClaimed', false);
  if (userStore.get('mainDungeonTotal') == null) userStore.set('mainDungeonTotal', 0); // cumulativo lifetime
}
function getMainDungeonStep(){
  ensureMainDungeonState();
  const idx = Number(userStore.get('mainDungeonStep') || 0);
  return Math.max(0, Math.min(idx, MAIN_DUNGEON_CHAIN.length - 1));
}
function setMainDungeonStep(i){
  ensureMainDungeonState();
  userStore.set('mainDungeonStep', Math.max(0, Math.min(Number(i)||0, MAIN_DUNGEON_CHAIN.length - 1)));
}
function isMainDungeonFinalClaimed(){
  ensureMainDungeonState(); return !!userStore.get('mainDungeonFinalClaimed');
}
function setMainDungeonFinalClaimed(v=true){
  ensureMainDungeonState(); userStore.set('mainDungeonFinalClaimed', !!v);
}
function getMainDungeonTotal(){ ensureMainDungeonState(); return Number(userStore.get('mainDungeonTotal')||0); }
function setMainDungeonTotal(v){ ensureMainDungeonState(); userStore.set('mainDungeonTotal', Math.max(0, Number(v)||0)); }

function mainDungeonCurrentTarget(){
  const i = getMainDungeonStep();
  return MAIN_DUNGEON_CHAIN[i];
}
function mainDungeonIsCompletedButUnclaimed(){
  const step = mainDungeonCurrentTarget();
  const i = getMainDungeonStep();
  const isLast = (i === MAIN_DUNGEON_CHAIN.length - 1);
  const total = getMainDungeonTotal();
  const ok = total >= Number(step.goal||0);
  if (!ok) return false;
  return isLast ? !isMainDungeonFinalClaimed() : true;
}

// Accumulo (chiamare SOLO quando VINCI nel dungeon)
function incrementMainDungeonOnVictory(n=1){
  setMainDungeonTotal(getMainDungeonTotal() + Math.max(0, Number(n)||0));
}

// Riscossione premio + avanzamento step (messaggio standard)
function mainDungeonClaimReward(){
  const i = getMainDungeonStep();
  const step = MAIN_DUNGEON_CHAIN[i];
  if (!step) return;

  // accredita ricompense
  const r = step.reward || {};
  if (Number(r.gold||0) > 0) addNum('gold', Number(r.gold));
  if (Number(r.arcaneDust||0) > 0 && typeof addArcaneDust === 'function') {
    addArcaneDust(Number(r.arcaneDust));
  }
  if (r.potionId && typeof addPotion === 'function') addPotion(r.potionId, Number(r.potionQty||1));
  if (Number(r.crystalParts||0) > 0) {
    const prev = Number(userStore.get('crystalParts')||0);
    userStore.set('crystalParts', prev + Number(r.crystalParts));
  }
  if (r.keyId && typeof addKey === 'function') addKey(r.keyId, Number(r.keyQty||1));

  // avanza o chiudi
  const isLast = (i === MAIN_DUNGEON_CHAIN.length - 1);
  if (isLast) setMainDungeonFinalClaimed(true);
  else setMainDungeonStep(i + 1);

  // feedback unificato
  showGameMessage?.('Ricompensa', 'Hai ritirato la ricompensa!');

  // refresh UI
  if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI();
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

// === QUEST PRINCIPALI ‚Äî CRISTALLI DI POTENZIAMENTO =========================
const MAIN_CRYSTAL_CHAIN = [
  { goal:  5,  title: 'Utilizza 5 cristalli di potenziamento',   reward: { gold: 10000 } },
  { goal: 20,  title: 'Utilizza 20 cristalli di potenziamento',  reward: { gold: 10000, crystalPart: 6 } }, // 6 frammenti
  { goal: 40,  title: 'Utilizza 40 cristalli di potenziamento',  reward: { keyId: 'ottone',  keyQty: 1 } }, // Chiave del Mercante
  { goal: 80,  title: 'Utilizza 80 cristalli di potenziamento',  reward: { gold: 10000, arcaneDust: 20 } },
  { goal: 140, title: 'Utilizza 140 cristalli di potenziamento', reward: { gold: 15000, arcaneDust: 30 } },
  { goal: 220, title: 'Utilizza 220 cristalli di potenziamento', reward: { keyId: 'argento', keyQty: 1 } }, // Chiave dell‚ÄôAvventuriero
  { goal: 300, title: 'Utilizza 300 cristalli di potenziamento', reward: { keyId: 'oro',     keyQty: 1 } }, // Chiave del Re
  { goal: 400, title: 'Utilizza 400 cristalli di potenziamento', reward: { keyId: 'runica',  keyQty: 1 } }  // Chiave Arcana
];

// === Stato catena "Cristalli" =================================================
function ensureMainCrystalState(){
  if (userStore.get('mainCrystalStep') === null || userStore.get('mainCrystalStep') === undefined)
    userStore.set('mainCrystalStep', 0);
  if (userStore.get('mainCrystalFinalClaimed') === null || userStore.get('mainCrystalFinalClaimed') === undefined)
    userStore.set('mainCrystalFinalClaimed', false);
  if (userStore.get('mainCrystalUsed') === null || userStore.get('mainCrystalUsed') === undefined)
    userStore.set('mainCrystalUsed', 0);              // totale cumulativo cristalli spesi
}
function getMainCrystalStep(){ ensureMainCrystalState(); return Number(userStore.get('mainCrystalStep')||0); }
function setMainCrystalStep(i){ userStore.set('mainCrystalStep', Number(i||0)); }

function isMainCrystalFinalClaimed(){ ensureMainCrystalState(); return !!userStore.get('mainCrystalFinalClaimed'); }
function setMainCrystalFinalClaimed(v){ userStore.set('mainCrystalFinalClaimed', !!v); }

function getMainCrystalUsed(){ ensureMainCrystalState(); return Number(userStore.get('mainCrystalUsed')||0); }
function setMainCrystalUsed(n){ userStore.set('mainCrystalUsed', Math.max(0, Number(n||0))); }
function incrementMainCrystalsUsed(delta){
  const d = Math.max(0, Number(delta||0));
  if (d<=0) return;
  setMainCrystalUsed(getMainCrystalUsed() + d);
}

function mainCrystalsIsCompletedButUnclaimed(){
  const i = getMainCrystalStep();
  const st = MAIN_CRYSTAL_CHAIN[i];
  if (!st) return false;
  // se √® l‚Äôultimo step e gi√† ‚Äúfinale riscossa‚Äù, non √® pi√π reclamabile
  if (i === MAIN_CRYSTAL_CHAIN.length - 1 && isMainCrystalFinalClaimed()) return false;
  return getMainCrystalUsed() >= Number(st.goal||0);
}

// Accredito ricompensa della catena Cristalli (oro, polvere, frammenti, chiavi)
function grantMainCrystalReward(r){
  if (!r) return;

  if (Number(r.gold||0) > 0)        addNum('gold', Number(r.gold||0));
  if (Number(r.arcaneDust||0) > 0)  addNum('arcaneDust', Number(r.arcaneDust||0));
  if (Number(r.crystalPart||0) > 0) addNum('crystalParts', Number(r.crystalPart||0)); // frammenti
  if (r.keyId) {
    const q = Number(r.keyQty||1);
    if (typeof addKey === 'function') addKey(r.keyId, q);
  }

  // Messaggio unico, come richiesto per le principali
  showGameMessage?.('Ricompensa', 'Hai ritirato la ricompensa!');
  updateGoldBadges?.();
}

// === QUEST PRINCIPALI ‚Äî PUNTI ABILIT√Ä UTILIZZATI ============================
// Catena "Utilizza punti abilit√†" (mostra solo lo step corrente, claim -> avanza)
const MAIN_AP_CHAIN = [
  { goal:  700,  title: 'Utilizza 700 punti abilit√†',  reward: { gold: 10000 } },
  { goal: 2000,  title: 'Utilizza 2000 punti abilit√†',  reward: { gold: 10000, crystalParts: 6 } },
  { goal: 4000,  title: 'Utilizza 4000 punti abilit√†',  reward: { keyId: 'ottone', keyQty: 1 } }, // Chiave del Mercante
  { goal: 6500,  title: 'Utilizza 6500 punti abilit√†',  reward: { gold: 10000, arcaneDust: 20 } },
  { goal: 9500,  title: 'Utilizza 9500 punti abilit√†',  reward: { gold: 15000, arcaneDust: 30 } },
  { goal:13000,  title: 'Utilizza 13000 punti abilit√†',  reward: { keyId: 'argento', keyQty: 1 } }, // Chiave dell'Avventuriero
  { goal:17000,  title: 'Utilizza 17000 punti abilit√†',  reward: { keyId: 'oro',     keyQty: 1 } }, // Chiave del Re
  { goal:22000,  title: 'Utilizza 22000 punti abilit√†',  reward: { keyId: 'runica',  keyQty: 1 } }  // Chiave Arcana
];

// Stato persistito: userStore -> mainApStep (indice step corrente), mainApFinalClaimed (bool), mainApUsed (cumulativo)
function ensureMainApState(){
  if (typeof userStore === 'undefined') return;
  if (userStore.get('mainApStep') == null)     userStore.set('mainApStep', 0);
  if (userStore.get('mainApFinalClaimed') == null) userStore.set('mainApFinalClaimed', false);
  if (userStore.get('mainApUsed') == null)     userStore.set('mainApUsed', 0);
}
function getMainApStep(){ ensureMainApState(); const idx = Number(userStore.get('mainApStep') || 0); return Math.max(0, Math.min(idx, MAIN_AP_CHAIN.length - 1)); }
function setMainApStep(i){ ensureMainApState(); userStore.set('mainApStep', Math.max(0, Math.min(Number(i)||0, MAIN_AP_CHAIN.length - 1))); }
function isMainApFinalClaimed(){ ensureMainApState(); return !!userStore.get('mainApFinalClaimed'); }
function setMainApFinalClaimed(v=true){ ensureMainApState(); userStore.set('mainApFinalClaimed', !!v); }

function getMainApUsed(){ ensureMainApState(); return Number(userStore.get('mainApUsed') || 0); }
function setMainApUsed(v){ ensureMainApState(); userStore.set('mainApUsed', Math.max(0, Number(v)||0)); }
function incrementMainApUsed(n=1){ setMainApUsed(getMainApUsed() + Math.max(0, Number(n)||0)); /* aggiorna UI badge/quest se utile */ if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI(); if (typeof updateQuestsBadge === 'function') updateQuestsBadge(); }

// Dati correnti & condizione completamento
function mainApCurrentTarget(){ const i = getMainApStep(); return MAIN_AP_CHAIN[i]; }
function mainApIsCompletedButUnclaimed(){
  const step = mainApCurrentTarget();
  if (!step) return false;
  const i = getMainApStep();
  const isLast = (i === MAIN_AP_CHAIN.length - 1);
  const totalUsed = getMainApUsed();
  const ok = totalUsed >= Number(step.goal || 0);
  if (!ok) return false;
  return isLast ? !isMainApFinalClaimed() : true;
}

// Riscossione premio + avanzamento step (comportamento come le altre catene principali)
function mainApClaimReward(){
  const i = getMainApStep();
  const step = MAIN_AP_CHAIN[i];
  if (!step) return;

  const r = step.reward || {};
  // Oro
  if (Number(r.gold||0) > 0 && typeof addNum === 'function') { addNum('gold', Number(r.gold)); updateGoldBadges?.(); }
  // Polvere arcana
  if (Number(r.arcaneDust||0) > 0 && typeof addArcaneDust === 'function') addArcaneDust(Number(r.arcaneDust));
  // Frammenti cristallo
  if (Number(r.crystalParts||0) > 0) {
    const prev = Number(userStore.get('crystalParts') || 0);
    userStore.set('crystalParts', prev + Number(r.crystalParts));
  }
  // Pozioni
  if (r.potionId && typeof addPotion === 'function') addPotion(r.potionId, Number(r.potionQty||1));
  // Chiavi
  if (r.keyId && typeof addKey === 'function') addKey(r.keyId, Number(r.keyQty||1));

  // Avanza / chiudi
  const isLast = (i === MAIN_AP_CHAIN.length - 1);
  if (isLast) setMainApFinalClaimed(true);
  else setMainApStep(i + 1);

  // Feedback unificato
  showGameMessage?.('Ricompensa', 'Hai ritirato la ricompensa!');
  if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI();
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

// ‚Äî‚Äî‚Äî Reset settimanale (chiave = luned√¨ della settimana, ora locale) ‚Äî‚Äî‚Äî
function mondayOfCurrentWeekKey() {
  const d = new Date();
  // getDay(): 0=Dom, 1=Lun, ... 6=Sab
  const day = d.getDay();
  // delta per arrivare al luned√¨ (se Domenica=0 -> -6 giorni, se Lun=1 -> 0, ...):
  const diffToMon = (day === 0) ? -6 : (1 - day);
  const mon = new Date(d.getFullYear(), d.getMonth(), d.getDate() + diffToMon);
  const y = mon.getFullYear();
  const m = String(mon.getMonth() + 1).padStart(2, '0');
  const dd = String(mon.getDate()).padStart(2, '0');
  return `${y}-${m}-${dd}`; // YYYY-MM-DD
}

function resetWeeklyQuestsIfNeeded() {
  const thisWeekKey = mondayOfCurrentWeekKey();
  const last = userStore.get('questWeeklyKey') || null;
  if (last === thisWeekKey) return;

  const prog    = userStore.get('questProgress') || {};
  const claimed = userStore.get('questClaimed')  || {};

  QUESTS_WEEKLY.forEach(q => {
    prog[q.id] = 0;
    claimed[q.id] = false;
  });

  userStore.set('questProgress', prog);
  userStore.set('questClaimed',  claimed);
  userStore.set('questWeeklyKey', thisWeekKey);

  // üîÅ reset tracker login-settimanale
  userStore.set('weeklyLoginWeek', thisWeekKey);
  userStore.set('weeklyLoginDays', []);  // array di date YYYY-MM-DD visitate in settimana

  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}


// Stato locale user (progressi e claim)
function ensureQuestState() {
  if (!userStore.get('questProgress')) userStore.set('questProgress', {}); // {id: number}
  if (!userStore.get('questClaimed'))  userStore.set('questClaimed',  {}); // {id: boolean}
}
// ‚Äî‚Äî‚Äî Reset giornaliero delle quest ‚Äî‚Äî‚Äî
function questIsDaily(id) {
  const q = QUESTS.find(x => x.id === id);
  return !!(q && q.reset === 'daily');
}

function todayLocalKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

// Incrementa la weekly "login 7 giorni" al massimo 1 volta al giorno
function bumpWeeklyLoginIfNewDay() {
  const weekKey = mondayOfCurrentWeekKey();
  // Se per qualche motivo non allineato, riallinea il tracker alla settimana corrente
  if (userStore.get('weeklyLoginWeek') !== weekKey) {
    userStore.set('weeklyLoginWeek', weekKey);
    userStore.set('weeklyLoginDays', []);
  }

  const today = todayLocalKey();
  const days = userStore.get('weeklyLoginDays') || [];

  if (!days.includes(today)) {
    days.push(today);
    userStore.set('weeklyLoginDays', days);

    // avanza la quest di 1 (max 7 in settimana)
    if (typeof incrementQuest === 'function') {
      incrementQuest('q_weekly_login_7days', 1);
    }
  }
}

function resetDailyQuestsIfNeeded() {
  const today = todayLocalKey();                 // ‚¨ÖÔ∏è usa data locale
  const last  = userStore.get('questDailyDate') || null;
  if (last === today) return; // gi√† aggiornato oggi

  // azzera progressi e "claim" solo per le quest giornaliere
  const prog    = userStore.get('questProgress') || {};
  const claimed = userStore.get('questClaimed')  || {};

  QUESTS.forEach(q => {
    if (q.reset === 'daily') {
      prog[q.id] = 0;
      claimed[q.id] = false;
    }
  });

  userStore.set('questProgress', prog);
  userStore.set('questClaimed',  claimed);
  userStore.set('questDailyDate', today);        // ‚¨ÖÔ∏è salva chiave locale

  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
// ‚ûï Weekly: se √® un nuovo giorno, conteggia l‚Äôaccesso odierno
if (typeof bumpWeeklyLoginIfNewDay === 'function') bumpWeeklyLoginIfNewDay();
}

function getQuestProgress(id) {
  ensureQuestState();
  const map = userStore.get('questProgress') || {};
  return Number(map[id] || 0);
}

function setQuestProgress(id, val) {
  ensureQuestState();
  const map = userStore.get('questProgress') || {};
  map[id] = Math.max(0, Number(val) || 0);
  userStore.set('questProgress', map);
}

function incrementQuest(id, delta=1) {
  setQuestProgress(id, getQuestProgress(id) + (Number(delta)||0));
  updateQuestsBadge();
}

function isQuestClaimed(id) {
  ensureQuestState();
  const map = userStore.get('questClaimed') || {};
  return !!map[id];
}

function setQuestClaimed(id, val=true) {
  ensureQuestState();
  const map = userStore.get('questClaimed') || {};
  map[id] = !!val;
  userStore.set('questClaimed', map);
}

function isQuestCompleted(id) {
  const q = QUESTS.find(x => x.id === id);
  if (!q) return false;
  return getQuestProgress(id) >= q.goal;
}

// Badge sul tab "Quest" se c'√® almeno una ricompensa non riscossa
function updateQuestsBadge() {
  const tabBadgeDaily   = document.getElementById('quests-badge');
  const tabBadgeWeekly  = document.getElementById('weekly-badge');
  const tabBadgeMain    = document.getElementById('main-badge');
  const menuBadge       = document.getElementById('missions-badge');

  const daily  = (typeof QUESTS !== 'undefined' && Array.isArray(QUESTS)) ? QUESTS : [];
  const weekly = (typeof QUESTS_WEEKLY !== 'undefined' && Array.isArray(QUESTS_WEEKLY)) ? QUESTS_WEEKLY : [];

  const hasUnclaimedDaily  = daily.some (q => isQuestCompleted(q.id) && !isQuestClaimed(q.id));
  const hasUnclaimedWeekly = weekly.some(q => isQuestCompleted(q.id) && !isQuestClaimed(q.id));

  // Principali: livello + gilda + vittorie PvP + vittorie Dungeon
  let hasMainClaimable = false;
  try { if (typeof mainLevelIsCompletedButUnclaimed === 'function' && mainLevelIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}
  try { if (typeof mainGuildIsCompletedButUnclaimed === 'function' && mainGuildIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}
  try { if (typeof mainWinsIsCompletedButUnclaimed === 'function' && mainWinsIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}
  try { if (typeof mainDungeonIsCompletedButUnclaimed === 'function' && mainDungeonIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}
  try { if (typeof mainCrystalsIsCompletedButUnclaimed === 'function' && mainCrystalsIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}
  try { if (typeof mainApIsCompletedButUnclaimed === 'function' && mainApIsCompletedButUnclaimed()) hasMainClaimable = true; } catch(_) {}

  if (tabBadgeDaily)  tabBadgeDaily.classList.toggle('hidden', !hasUnclaimedDaily);
  if (tabBadgeWeekly) tabBadgeWeekly.classList.toggle('hidden', !hasUnclaimedWeekly);
  if (tabBadgeMain)   tabBadgeMain.classList.toggle('hidden', !hasMainClaimable);

  const hasAnyUnclaimed = !!(hasUnclaimedDaily || hasUnclaimedWeekly || hasMainClaimable);
  if (menuBadge) menuBadge.classList.toggle('hidden', !hasAnyUnclaimed);
}



function findQuestById(id) {
  const daily  = Array.isArray(QUESTS) ? QUESTS : [];
  const weekly = Array.isArray(QUESTS_WEEKLY) ? QUESTS_WEEKLY : [];
  return daily.find(q => q.id === id) || weekly.find(q => q.id === id) || null;
}
function isQuestCompleted(id) {
  const q = findQuestById(id);
  return q ? (getQuestProgress(id) >= q.goal) : false;
}


function renderQuestsUI() {
  // ‚¨áÔ∏è opzionale ma consigliato: se √® cambiata la data, resetta le quest giornaliere
  if (typeof resetDailyQuestsIfNeeded === 'function') resetDailyQuestsIfNeeded();

  const container = document.getElementById('missions-tab-quests');
  if (!container) return;

  // lista semplice
  const html = [
      `<h3 style="margin:0 0 8px 0; text-align:center;">Quest giornaliere</h3>`,
      `<div class="quest-list">`,
    ...QUESTS.map(q => {
      const prog = getQuestProgress(q.id);
      const done = isQuestCompleted(q.id);
      const claimed = isQuestClaimed(q.id);

      let right = `<span class="meta">${prog}/${q.goal}</span>`;
if (done && !claimed) right = `<span class="claimable">Riscuoti</span>`;
if (claimed) right = `<span class="meta">Ricompensa riscossa</span>`;

return `
  <button class="quest-item" data-quest="${q.id}">
    <div class="left">
      <div class="name">${q.name}</div>
      <div class="reward muted">
  ${(() => {
    const parts = [];
if (q?.reward?.gold) parts.push(`${formatGold(q.reward.gold)} oro`);
if (q?.reward?.energyDungeon) parts.push(`${q.reward.energyDungeon} Energia Dungeon ‚ö°`);
if (q?.reward?.energySfide)   parts.push(`${q.reward.energySfide} Energia Sfide ‚ö°`);
if (q?.reward?.arcaneDust)    parts.push(`${q.reward.arcaneDust} Polvere arcana`);
if (q?.reward?.potionId) {
  const qty = Number(q.reward.potionQty || 1);
  const pc  = (window.potionCatalog || []);
  const rec = pc.find(p => p.id === q.reward.potionId);
  const pname = rec?.name || 'Pozione';
  parts.push(`${qty}√ó ${pname}`);
}
return parts.length ? `Ricompensa: ${parts.join(', ')}` : 'Ricompensa: ‚Äî';

  })()}
</div>
    </div>
    ${right}
  </button>
`;
    }),
    `</div>`,
    // üî• Pulsante "Torna indietro"
    `<div class="back-button-container">
       <button type="button" id="quests-back-btn">Torna indietro</button>
     </div>`
  ].join('');

  container.innerHTML = html;

  // click quest ‚Üí claim reward se completata e non riscossa
  container.querySelectorAll('.quest-item').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-quest');
      const q = QUESTS.find(x => x.id === id);
      if (!q) return;

      if (isQuestCompleted(id) && !isQuestClaimed(id)) {
        // accredita oro
addNum('gold', Number(q.reward.gold || 0));

// ‚ö° se previsto, accredita Energia Dungeon
if (Number(q?.reward?.energyDungeon || 0) > 0 && typeof getEnergy === 'function' && typeof setEnergy === 'function') {
  setEnergy(getEnergy() + Number(q.reward.energyDungeon));
}
// üß™ se previsto, accredita Pozione
if (q?.reward?.potionId && typeof addPotion === 'function') {
  const qty = Number(q.reward.potionQty || 1);
  addPotion(q.reward.potionId, qty);
}
// ‚ú® Polvere arcana
if (Number(q?.reward?.arcaneDust || 0) > 0 && typeof addArcaneDust === 'function') {
  addArcaneDust(Number(q.reward.arcaneDust));
  if (typeof updateDustBadges === 'function') updateDustBadges();
}

// ‚ö° se previsto, accredita Energia Sfide
if (
  Number(q?.reward?.energySfide || 0) > 0 &&
  typeof getSfideEnergy === 'function' &&
  typeof setSfideEnergy === 'function'
) {
  setSfideEnergy(getSfideEnergy() + Number(q.reward.energySfide));
}

setQuestClaimed(id, true);

// ‚ûï Meta-quest: "Completa 8 quest giornaliere"
// Conta solo quando riscatti altre quest giornaliere (evita auto-conteggio)
if (typeof questIsDaily === 'function' && questIsDaily(id) && id !== 'q_daily_complete_8_dailies') {
  if (typeof incrementQuest === 'function') incrementQuest('q_daily_complete_8_dailies', 1);
}

// feedback
if (typeof showGameMessage === 'function') {
  const parts = [];
  if (Number(q?.reward?.gold || 0) > 0) parts.push(`<strong>${formatGold(q.reward.gold)}</strong> monete d'oro`);
  if (Number(q?.reward?.energyDungeon || 0) > 0) parts.push(`${q.reward.energyDungeon} Energia Dungeon ‚ö°`);
  if (Number(q?.reward?.energySfide   || 0) > 0) parts.push(`${q.reward.energySfide} Energia Sfide ‚ö°`);
  if (Number(q?.reward?.arcaneDust || 0) > 0) parts.push(`${q.reward.arcaneDust} Polvere arcana`);
  if (q?.reward?.potionId) {
    const qty = Number(q.reward.potionQty || 1);
    const rec = (window.potionCatalog || []).find(p => p.id === q.reward.potionId);
    const pname = rec?.name || 'Pozione';
    parts.push(`${qty}√ó ${pname}`);
  }
  showGameMessage('Ricompensa', `Hai ritirato ${parts.join(' e ')}!`);
}

        // refresh UI + badge
        renderQuestsUI();
        if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

        // aggiorna oro su profilo/shop se visibili
        const g = getNum('gold', 0);
        const heroGoldEl = document.getElementById('hero-gold');
        if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;
        ['weapon-shop-gold', 'armor-shop-gold', 'magic-shop-gold'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.textContent = formatGold(g);
        });
      }
    });
  });

  // üîô Torna indietro ‚Äî ferma ticker energia e torna al menu
  const backBtn = document.getElementById('quests-back-btn');
  if (backBtn) {
    backBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();

      // ‚úÖ ferma sempre il countdown energia (se attivo dal Dungeon)
      if (typeof stopEnergyTicker === 'function') stopEnergyTicker();

      if (typeof backToMenuFromMissions === 'function') {
        backToMenuFromMissions();
      } else {
        // fallback di sicurezza
        document.getElementById('missions')?.classList.add('hidden');
        document.getElementById('menu')?.classList.remove('hidden');
      }
    });
  }
}

function renderWeeklyQuestsUI() {
  const container = document.getElementById('missions-tab-weekly');
  if (!container) return;

  const html = [
    `<h3 style="margin:0 0 8px 0; text-align:center;">Quest settimanali</h3>`,
    `<div class="quest-list">`,
    QUESTS_WEEKLY.map(q => {
      const prog = getQuestProgress(q.id);
      const done = prog >= q.goal;
      const claimed = isQuestClaimed(q.id);

      let right = `<span class="meta">${prog}/${q.goal}</span>`;
      if (done && !claimed) right = `<span class="claimable">Riscuoti</span>`;
      if (claimed)          right = `<span class="meta">Ricompensa riscossa</span>`;

      const rewardStr = (() => {
        const parts = [];
        if (q?.reward?.gold)           parts.push(`${formatGold(q.reward.gold)} monete d'oro`);
        if (q?.reward?.energyDungeon)  parts.push(`${q.reward.energyDungeon} Energia Dungeon ‚ö°`);
        if (q?.reward?.energySfide)    parts.push(`${q.reward.energySfide} Energia Sfide ‚ö°`);
        if (q?.reward?.arcaneDust)     parts.push(`${q.reward.arcaneDust} Polvere arcana`);
	if (q?.reward?.crystalParts)
    parts.push(`${q.reward.crystalParts} frammento${Number(q.reward.crystalParts) > 1 ? 'i' : ''} di cristallo`);
        if (q?.reward?.potionId) {
          const qty = Number(q.reward.potionQty || 1);
          const rec = (window.potionCatalog || []).find(p => p.id === q.reward.potionId);
          const pname = rec?.name || 'Pozione';
          parts.push(`${qty}√ó ${pname}`);
        }
        return parts.join(' ¬∑ ');
      })();

      return `
        <button class="quest-item" data-quest="${q.id}">
          <div class="left">
            <div class="name">${q.name}</div>
            <div class="reward muted">${rewardStr}</div>
          </div>
          <div class="right">${right}</div>
        </button>
      `;
    }).join(''),
    `</div>`,
    `<div class="back-button-container">
       <button type="button" id="weekly-quests-back-btn">Torna indietro</button>
     </div>`
  ];

  container.innerHTML = html.join('\n');

  // click su item (riscatto)
  Array.from(container.querySelectorAll('.quest-item')).forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-quest');
      const q = QUESTS_WEEKLY.find(x => x.id === id);
      if (!q) return;

      const prog = getQuestProgress(id);
      const done = prog >= q.goal;
      const claimed = isQuestClaimed(id);
      if (!done || claimed) return;

      try {
        // üí∞ Oro
        if (Number(q?.reward?.gold || 0) > 0 && typeof addNum === 'function') {
          addNum('gold', Number(q.reward.gold) || 0);
        }

        // ‚ö° Energia Dungeon (usa API canoniche, NON addNum/chiavi arbitrarie)
        if (Number(q?.reward?.energyDungeon || 0) > 0 &&
            typeof getEnergy === 'function' && typeof setEnergy === 'function') {
          setEnergy(getEnergy() + Number(q.reward.energyDungeon));
        }

        // ‚ö° Energia Sfide (usa API canoniche, NON addNum/chiavi arbitrarie)
        if (Number(q?.reward?.energySfide || 0) > 0 &&
            typeof getSfideEnergy === 'function' && typeof setSfideEnergy === 'function') {
          setSfideEnergy(getSfideEnergy() + Number(q.reward.energySfide));
        }

        // ‚ú® Polvere arcana
        if (Number(q?.reward?.arcaneDust || 0) > 0 && typeof addArcaneDust === 'function') {
          addArcaneDust(Number(q.reward.arcaneDust));
          if (typeof updateDustBadges === 'function') updateDustBadges();
        }

// üß© Frammenti di Cristallo
if (Number(q?.reward?.crystalParts || 0) > 0) {
  addNum('crystalParts', Number(q.reward.crystalParts) || 0);
}

        // üß™ Pozioni (usa lo stesso helper delle giornaliere)
        if (q?.reward?.potionId && typeof addPotion === 'function') {
          const qty = Number(q.reward.potionQty || 1);
          addPotion(q.reward.potionId, qty);
        }

        // Segna come riscossa
        setQuestClaimed(id, true);

        // Feedback ‚ÄúRicompensa‚Äù (coerente con le giornaliere)
        if (typeof showGameMessage === 'function') {
          const parts = [];
          if (Number(q?.reward?.gold || 0) > 0)          parts.push(`<strong>${formatGold(q.reward.gold)}</strong> monete d'oro`);
          if (Number(q?.reward?.energyDungeon || 0) > 0) parts.push(`${q.reward.energyDungeon} Energia Dungeon ‚ö°`);
          if (Number(q?.reward?.energySfide || 0) > 0)   parts.push(`${q.reward.energySfide} Energia Sfide ‚ö°`);
          if (Number(q?.reward?.arcaneDust || 0) > 0)    parts.push(`${q.reward.arcaneDust} Polvere arcana`);
	  if (Number(q?.reward?.crystalParts || 0) > 0)
  parts.push(`${q.reward.crystalParts} frammento${Number(q.reward.crystalParts) > 1 ? 'i' : ''} di cristallo`);
          if (q?.reward?.potionId) {
            const qty = Number(q.reward.potionQty || 1);
            const rec = (window.potionCatalog || []).find(p => p.id === q.reward.potionId);
            const pname = rec?.name || 'Pozione';
            parts.push(`${qty}√ó ${pname}`);
          }
          showGameMessage('Ricompensa', `Hai ritirato ${parts.join(' e ')}!`);
        }

        // refresh UI + badge
renderWeeklyQuestsUI();   // <-- questa √® quella giusta
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

        // Aggiorna oro su profilo/shop se visibili
        const g = getNum('gold', 0);
        const heroGoldEl = document.getElementById('hero-gold');
        if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(g)} monete d'oro`;
        ['weapon-shop-gold', 'armor-shop-gold', 'magic-shop-gold'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.textContent = formatGold(g);
        });
      } catch(_) {}
    });
  });

  // üîô Torna indietro ‚Äî ferma ticker energia e torna al menu
  const backBtn = document.getElementById('weekly-quests-back-btn');
  if (backBtn) {
    backBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof stopEnergyTicker === 'function') stopEnergyTicker(); // Dungeon
      if (typeof backToMenuFromMissions === 'function') {
        backToMenuFromMissions();
      } else {
        // fallback
        document.getElementById('missions')?.classList.add('hidden');
        document.getElementById('menu')?.classList.remove('hidden');
      }
    });
  }
}

function renderMainQuestsUI(){
  const box = document.getElementById('missions-tab-main');
  if (!box) return;

  // ========== Catena: Livello ==========
  ensureMainLevelState();
  const idxL = getMainLevelStep();
  const curL = MAIN_LEVEL_CHAIN[idxL];
  const heroLv = getCurrentHeroLevel();
  const isLastL = (idxL === MAIN_LEVEL_CHAIN.length - 1);
  const finalClaimedL = isMainLevelFinalClaimed();
  const claimableL = mainLevelIsCompletedButUnclaimed();

  const partsL = [];
  if (curL.reward?.gold)       partsL.push(`${formatGold(curL.reward.gold)} oro`);
  if (curL.reward?.arcaneDust) partsL.push(`${curL.reward.arcaneDust} Polvere Arcana`);
  if (curL.reward?.potionId){
    const qty = Number(curL.reward.potionQty||1);
    const lab = (curL.reward.potionId==='pot_small') ? 'Pozione salute piccola'
              : (curL.reward.potionId==='pot_medium') ? 'Pozione salute media'
              : (curL.reward.potionId==='pot_large') ? 'Pozione salute grande'
              : 'Pozione';
    partsL.push(`${qty} ${lab}`);
  }
  if (curL.reward?.keyId){
    const labKey = (curL.reward.keyId==='ottone')  ? 'Chiave del Mercante'
                : (curL.reward.keyId==='argento') ? 'Chiave dell‚ÄôAvventuriero'
                : (curL.reward.keyId==='oro')     ? 'Chiave Del Re'
                : (curL.reward.keyId==='runica')  ? 'Chiave Arcana' : 'Chiave';
    const qty = Number(curL.reward.keyQty||1);
    partsL.push(`${qty} ${labKey}`);
  }
  const rewardLineL = partsL.length ? partsL.join(' + ') : '‚Äî';
  let rightL;
  if (isLastL && finalClaimedL) rightL = `<span class="meta">Ricompensa riscossa</span>`;
  else if (claimableL)          rightL = `<span class="claimable">Riscuoti</span>`;
  else                          rightL = `<span class="meta">Lv ${heroLv}/${curL.level}</span>`;

  // ========== Catena: Gilda ==========
  ensureMainGuildState();
  const idxG = getMainGuildStep();
  const curG = MAIN_GUILD_CHAIN[idxG];
  const isLastG = (idxG === MAIN_GUILD_CHAIN.length - 1);
  const finalClaimedG = isMainGuildFinalClaimed();
  const claimableG = mainGuildIsCompletedButUnclaimed();

  const partsG = [];
  if (curG.reward?.gold)          partsG.push(`${formatGold(curG.reward.gold)} oro`);
  if (curG.reward?.crystalParts)  partsG.push(`${curG.reward.crystalParts} frammento${curG.reward.crystalParts>1?'i':''} di cristallo`);
  if (curG.reward?.arcaneDust)    partsG.push(`${curG.reward.arcaneDust} Polvere Arcana`);
  if (curG.reward?.potionId){
    const qty = Number(curG.reward.potionQty||1);
    const lab = (curG.reward.potionId==='pot_small') ? 'Pozione salute piccola'
              : (curG.reward.potionId==='pot_medium') ? 'Pozione salute media'
              : (curG.reward.potionId==='pot_large') ? 'Pozione salute grande'
              : 'Pozione';
    partsG.push(`${qty} ${lab}`);
  }
  if (curG.reward?.keyId){
    const labKey = (curG.reward.keyId==='ottone')  ? 'Chiave del Mercante'
                : (curG.reward.keyId==='argento') ? 'Chiave dell‚ÄôAvventuriero'
                : (curG.reward.keyId==='oro')     ? 'Chiave Del Re'
                : (curG.reward.keyId==='runica')  ? 'Chiave Arcana' : 'Chiave';
    const qty = Number(curG.reward.keyQty||1);
    partsG.push(`${qty} ${labKey}`);
  }
  const rewardLineG = partsG.length ? partsG.join(' + ') : '‚Äî';

  let rightG;
  if (isLastG && finalClaimedG) rightG = `<span class="meta">Ricompensa riscossa</span>`;
  else if (claimableG)          rightG = `<span class="claimable">Riscuoti</span>`;
  else {
    if (curG.type === 'join'){
      const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
      rightG = gid ? `<span class="meta">Pronto</span>` : `<span class="meta">Non in gilda</span>`;
    } else {
      const now = getMainGuildDonation();
      const goal = Number(curG.goal||0);
      rightG = `<span class="meta">${formatGold(now)}/${formatGold(goal)}</span>`;
    }
  }

  // ========== Catena: Vittorie (PvP) ==========
  if (typeof ensureMainWinsState === 'function') ensureMainWinsState();
  const idxW   = (typeof getMainWinsStep === 'function') ? getMainWinsStep() : 0;
  const curW   = (typeof mainWinsCurrentTarget === 'function') ? mainWinsCurrentTarget() : null;
  const totalW = (typeof getMainWinsTotal === 'function') ? getMainWinsTotal() : 0;
  const goalW  = Number(curW?.goal || 0);
  const isLastW = (typeof getMainWinsStep === 'function' && Array.isArray(MAIN_WINS_CHAIN)) ? (idxW === MAIN_WINS_CHAIN.length - 1) : false;
  const finalClaimedW = (typeof isMainWinsFinalClaimed === 'function') ? isMainWinsFinalClaimed() : false;
  const claimableW    = (typeof mainWinsIsCompletedButUnclaimed === 'function') ? mainWinsIsCompletedButUnclaimed() : false;

  const partsW = [];
if (curW?.reward?.gold)       partsW.push(`${formatGold(curW.reward.gold)} oro`);
if (curW?.reward?.arcaneDust) partsW.push(`${curW.reward.arcaneDust} Polvere Arcana`);
if (curW?.reward?.potionId){
  const qty = Number(curW.reward.potionQty||1);
  const lab = (curW.reward.potionId==='pot_small') ? 'Pozione salute piccola'
            : (curW.reward.potionId==='pot_medium') ? 'Pozione salute media'
            : (curW.reward.potionId==='pot_large') ? 'Pozione salute grande'
            : 'Pozione';
  partsW.push(`${qty} ${lab}`);
}
// Frammenti: usa crystalParts (plurale)
if (curW?.reward?.crystalParts) {
  const n = Number(curW.reward.crystalParts||0);
  partsW.push(`${n} Frammento${n>1?'i':''} di cristallo`);
}
// Chiavi: label leggibile
if (curW?.reward?.keyId){
  const id = curW.reward.keyId;
  const qty = Number(curW.reward.keyQty||1);
  const labKey = (typeof keyName === 'function')
    ? keyName(id) // se hai gi√† una funzione etichetta chiavi
    : (id==='ottone' ? 'Chiave del Mercante'
      : id==='argento' ? 'Chiave dell‚ÄôAvventuriero'
      : id==='oro' ? 'Chiave Del Re'
      : id==='runica' ? 'Chiave Arcana'
      : 'Chiave');
  partsW.push(`${qty} ${labKey}`);
}
const rewardLineW = partsW.length ? partsW.join(' + ') : '‚Äî';
  let rightW = '';
  if (isLastW && finalClaimedW) rightW = `<span class="meta">Ricompensa riscossa</span>`;
  else if (claimableW)          rightW = `<span class="claimable">Riscuoti</span>`;
  else                          rightW = `<span class="meta">${Math.min(totalW, goalW)}/${goalW}</span>`;

  // ========== Catena: Vittorie Dungeon ==========
  if (typeof ensureMainDungeonState === 'function') ensureMainDungeonState();
  const idxD   = (typeof getMainDungeonStep === 'function') ? getMainDungeonStep() : 0;
  const curD   = (typeof mainDungeonCurrentTarget === 'function') ? mainDungeonCurrentTarget() : null;
  const totalD = (typeof getMainDungeonTotal === 'function') ? getMainDungeonTotal() : 0;
  const goalD  = Number(curD?.goal || 0);
  const isLastD = (typeof getMainDungeonStep === 'function' && Array.isArray(MAIN_DUNGEON_CHAIN)) ? (idxD === MAIN_DUNGEON_CHAIN.length - 1) : false;
  const finalClaimedD = (typeof isMainDungeonFinalClaimed === 'function') ? isMainDungeonFinalClaimed() : false;
  const claimableD    = (typeof mainDungeonIsCompletedButUnclaimed === 'function') ? mainDungeonIsCompletedButUnclaimed() : false;

  const partsD = [];
  if (curD?.reward?.gold)       partsD.push(`${formatGold(curD.reward.gold)} oro`);
  if (curD?.reward?.arcaneDust) partsD.push(`${curD.reward.arcaneDust} Polvere Arcana`);
  if (curD?.reward?.potionId){
    const qty = Number(curD.reward.potionQty||1);
    const lab = (curD.reward.potionId==='pot_small') ? 'Pozione salute piccola'
              : (curD.reward.potionId==='pot_medium') ? 'Pozione salute media'
              : (curD.reward.potionId==='pot_large') ? 'Pozione salute grande'
              : 'Pozione';
    partsD.push(`${qty} ${lab}`);
  }
  if (curD?.reward?.crystalParts) {
    const n = Number(curD.reward.crystalParts||0);
    partsD.push(`${n} Frammento${n>1?'i':''} di cristallo`);
  }
  if (curD?.reward?.keyId){
    const id = curD.reward.keyId;
    const qty = Number(curD.reward.keyQty||1);
    const labKey = (typeof keyName === 'function')
      ? keyName(id)
      : (id==='ottone' ? 'Chiave del Mercante'
        : id==='argento' ? 'Chiave dell‚ÄôAvventuriero'
        : id==='oro' ? 'Chiave Del Re'
        : id==='runica' ? 'Chiave Arcana'
        : 'Chiave');
    partsD.push(`${qty} ${labKey}`);
  }
  const rewardLineD = partsD.length ? partsD.join(' + ') : '‚Äî';
  let rightD = '';
  if (isLastD && finalClaimedD) rightD = `<span class="meta">Ricompensa riscossa</span>`;
  else if (claimableD)          rightD = `<span class="claimable">Riscuoti</span>`;
  else                          rightD = `<span class="meta">${Math.min(totalD, goalD)}/${goalD}</span>`;

// --- Catena CRISTALLI --------------------------------------------------------
ensureMainCrystalState();
const idxC = getMainCrystalStep();
const curC = MAIN_CRYSTAL_CHAIN[idxC];
const isLastC = (idxC === MAIN_CRYSTAL_CHAIN.length - 1);
const finalClaimedC = isMainCrystalFinalClaimed();
const claimableC = mainCrystalsIsCompletedButUnclaimed();

const partsC = [];
if (curC?.reward?.gold)         partsC.push(`${formatGold(curC.reward.gold)} oro`);
if (curC?.reward?.arcaneDust)   partsC.push(`${curC.reward.arcaneDust} Polvere Arcana`);
if (curC?.reward?.crystalPart)  partsC.push(`${curC.reward.crystalPart} frammento${curC.reward.crystalPart>1?'i':''} di cristallo`);
if (curC?.reward?.keyId){
  const labKey = (curC.reward.keyId==='ottone')  ? 'Chiave del Mercante'
              : (curC.reward.keyId==='argento') ? 'Chiave dell‚ÄôAvventuriero'
              : (curC.reward.keyId==='oro')     ? 'Chiave del Re'
              : (curC.reward.keyId==='runica')  ? 'Chiave Arcana' : 'Chiave';
  const qty = Number(curC.reward.keyQty||1);
  partsC.push(`${qty} ${labKey}`);
}
const rewardLineC = partsC.length ? partsC.join(' + ') : '‚Äî';

let rightC;
if (isLastC && finalClaimedC) rightC = `<span class="meta">Ricompensa riscossa</span>`;
else if (claimableC)          rightC = `<span class="claimable">Riscuoti</span>`;
else {
  const now = getMainCrystalUsed();
  const goal = Number(curC?.goal||0);
  rightC = `<span class="meta">${now}/${goal}</span>`;
}
// QUEST ABILIT√Ä - inizializza stato
ensureMainApState();
const idxAP = getMainApStep();
const curAP = MAIN_AP_CHAIN[idxAP];

  // ===== Render UI =====
  box.innerHTML = `
    <div class="traits-block">
      <div class="title">Quest principali</div>

      <div class="quest-list">
        <button class="quest-item" id="main-level-quest">
          <div class="left">
            <div class="name">Raggiungi livello ${curL.level}</div>
            <div class="reward muted">${rewardLineL}</div>
          </div>
          <div class="right">${rightL}</div>
        </button>

        <button class="quest-item" id="main-guild-quest">
          <div class="left">
            <div class="name">${curG.title || (curG.type==='join' ? 'Crea o entra in una gilda' : 'Dona oro alla gilda')}</div>
            <div class="reward muted">${rewardLineG}</div>
          </div>
          <div class="right">${rightG}</div>
        </button>

        <button class="quest-item" id="main-wins-quest">
          <div class="left">
            <div class="name">${curW ? (curW.title || ('Vinci ' + goalW + ' sfide')) : 'Vinci sfide'}</div>
            <div class="reward muted">${rewardLineW}</div>
          </div>
          <div class="right">${rightW}</div>
        </button>

        <button class="quest-item" id="main-dungeon-quest">
          <div class="left">
            <div class="name">${curD ? (curD.title || ('Vinci ' + goalD + ' sfide dungeon')) : 'Vinci sfide dungeon'}</div>
            <div class="reward muted">${rewardLineD}</div>
          </div>
          <div class="right">${rightD}</div>
        </button>

<button class="quest-item" id="main-crystal-quest">
  <div class="left">
    <div class="name">${curC?.title || 'Utilizza cristalli di potenziamento'}</div>
    <div class="reward muted">${rewardLineC}</div>
  </div>
  <div class="right">${rightC}</div>
</button>

<button class="quest-item" id="main-ap-quest">
  <div class="left">
    <div class="name">${curAP?.title || ('Utilizza punti abilit√†')}</div>
    <div class="reward muted">${(function(){
      const p = curAP?.reward || {};
      const parts = [];
      if (p.gold) parts.push(`${formatGold(p.gold)} oro`);
      if (p.crystalParts) parts.push(`${p.crystalParts} frammento${p.crystalParts>1?'i':''} di cristallo`);
      if (p.arcaneDust) parts.push(`${p.arcaneDust} Polvere Arcana`);
      if (p.potionId) {
        const qty = Number(p.potionQty||1);
        const rec = (window.potionCatalog||[]).find(x=>x.id===p.potionId);
        const lab = rec?.name || 'Pozione';
        parts.push(`${qty}√ó ${lab}`);
      }
      if (p.keyId) {
        const labKey = (p.keyId==='ottone') ? 'Chiave del Mercante' :
                       (p.keyId==='argento') ? 'Chiave dell‚ÄôAvventuriero' :
                       (p.keyId==='oro') ? 'Chiave del Re' :
                       (p.keyId==='runica') ? 'Chiave Arcana' : 'Chiave';
        const qty = Number(p.keyQty||1);
        parts.push(`${qty} ${labKey}`);
      }
      return parts.length ? parts.join(' + ') : '‚Äî';
    })()}</div>
  </div>
  <div class="right">${(function(){
    const isLast = (idxAP === MAIN_AP_CHAIN.length - 1);
    const finalClaimed = isMainApFinalClaimed();
    if (isLast && finalClaimed) return `<span class="meta">Ricompensa riscossa</span>`;
    if (mainApIsCompletedButUnclaimed()) return `<span class="claimable">Riscuoti</span>`;
    const now = getMainApUsed(); const goal = Number(curAP?.goal||0);
    return `<span class="meta">${now}/${goal}</span>`;
  })()}</div>
</button>

      </div>

      <div class="back-button-container">
        <button type="button" id="main-quests-back-btn">Torna indietro</button>
      </div>
    </div>
  `;

  // Back
  const back = document.getElementById('main-quests-back-btn');
  if (back && !back._bound){
    back._bound = true;
    back.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      if (typeof stopEnergyTicker === 'function') stopEnergyTicker();
      if (typeof backToMenuFromMissions === 'function') backToMenuFromMissions();
      else { document.getElementById('missions')?.classList.add('hidden'); document.getElementById('menu')?.classList.remove('hidden'); }
    });
  }

  // Click sull'intera riga ‚Äî catena Livello
  const rowL = document.getElementById('main-level-quest');
  if (rowL && !rowL._bound) {
    rowL._bound = true;
    rowL.addEventListener('click', () => {
      if (!mainLevelIsCompletedButUnclaimed()) return;
      const i  = getMainLevelStep();
      const st = MAIN_LEVEL_CHAIN[i];
      grantMainLevelReward(st.reward);
      if (i === MAIN_LEVEL_CHAIN.length - 1) setMainLevelFinalClaimed(true);
      else setMainLevelStep(i + 1);
      renderMainQuestsUI();
      if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
      showGameMessage?.('Ricompensa', 'Hai ritirato la ricompensa!');
    });
  }

  // Click sull'intera riga ‚Äî catena Gilda
  const rowG = document.getElementById('main-guild-quest');
  if (rowG && !rowG._bound) {
    rowG._bound = true;
    rowG.addEventListener('click', () => {
      if (!mainGuildIsCompletedButUnclaimed()) return;
      const i  = getMainGuildStep();
      const st = MAIN_GUILD_CHAIN[i];
      grantMainGuildReward(st.reward);

      // Avanza / chiudi catena (cumulativa: non si azzera il contatore donazioni)
      if (i === MAIN_GUILD_CHAIN.length - 1) setMainGuildFinalClaimed(true);
      else setMainGuildStep(i + 1);

      renderMainQuestsUI();
      if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
      showGameMessage?.('Ricompensa', 'Hai ritirato la ricompensa!');
    });
  }

  // Click sull'intera riga ‚Äî catena Vittorie (PvP)
  const rowW = document.getElementById('main-wins-quest');
  if (rowW && !rowW._bound) {
    rowW._bound = true;
    rowW.addEventListener('click', () => {
      if (typeof mainWinsIsCompletedButUnclaimed === 'function' && !mainWinsIsCompletedButUnclaimed()) return;
      if (typeof mainWinsClaimReward === 'function') mainWinsClaimReward();
    });
  }
  // Click sull'intera riga ‚Äî catena Vittorie Dungeon
  const rowD = document.getElementById('main-dungeon-quest');
  if (rowD && !rowD._bound) {
    rowD._bound = true;
    rowD.addEventListener('click', () => {
      if (typeof mainDungeonIsCompletedButUnclaimed === 'function' && !mainDungeonIsCompletedButUnclaimed()) return;
      if (typeof mainDungeonClaimReward === 'function') mainDungeonClaimReward();
    });
  }
// Click sull'intera riga ‚Äî catena CRISTALLI
const rowC = document.getElementById('main-crystal-quest');
if (rowC && !rowC._bound) {
  rowC._bound = true;
  rowC.addEventListener('click', () => {
    if (!mainCrystalsIsCompletedButUnclaimed()) return;

    const i  = getMainCrystalStep();
    const st = MAIN_CRYSTAL_CHAIN[i];

    grantMainCrystalReward(st.reward);

    // Avanza / chiudi (cumulativo: NON si resetta il conteggio usati)
    if (i === MAIN_CRYSTAL_CHAIN.length - 1) {
      setMainCrystalFinalClaimed(true);
    } else {
      setMainCrystalStep(i + 1);
    }

    renderMainQuestsUI?.();
    updateQuestsBadge?.();
  });
}
// CLICK QUEST PUNTI ABILIT√Ä
const rowAP = document.getElementById('main-ap-quest');
if (rowAP && !rowAP._bound) {
  rowAP._bound = true;
  rowAP.addEventListener('click', () => {
    if (!mainApIsCompletedButUnclaimed()) return;
    mainApClaimReward();
  });
}

}


function ensureMagicModal() {
  let overlay = document.getElementById('magic-overlay');
  let modal   = document.getElementById('magic-detail');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'magic-overlay';
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closeMagicDetail;
    document.body.appendChild(overlay);
  }
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'magic-detail';
    modal.className = 'hidden modal-common';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');
    modal.innerHTML = `
      <h3 id="magic-detail-title">Magia</h3>
      <div id="magic-detail-body" class="scroll-area"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="magic-detail-buy" class="magic-button">Acquista</button>
        <button class="magic-button" onclick="closeMagicDetail()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
}

function closeMagicDetail() {
  document.getElementById('magic-overlay')?.classList.add('hidden');
  document.getElementById('magic-detail')?.classList.add('hidden');
  unlockBodyScroll();
}


function openMagicPopup() {
  const popup = document.getElementById('magic-popup');
  if (!popup) return;

  // Mostra popup e posiziona
  popup.classList.remove('hidden');
  positionModalUnderHeroType(popup, 12);

  // Overlay chiudibile
  const ov = document.getElementById('generic-overlay');
  ov?.classList.remove('hidden');
  if (ov) ov.onclick = closeMagicPopup;

  // SEMPRE: nascondo gli 8 bottoni fissi originali
  popup.querySelectorAll('.magic-option').forEach(o => o.style.display = 'none');

  // contenitore dinamico (crealo se manca)
  let list = popup.querySelector('.magic-options-dynamic');
  if (!list) {
    list = document.createElement('div');
    list.className = 'magic-options-dynamic';
    const brRef = popup.querySelector('br');
    if (brRef) popup.insertBefore(list, brRef); else popup.appendChild(list);
  }

  // pager (unico, subito sotto la lista)
  let pager = popup.querySelector('.magic-pager');
  if (!pager) {
    pager = document.createElement('div');
    pager.className = 'magic-pager';
    pager.style.display = 'flex';
    pager.style.flexDirection = 'column';
    pager.style.alignItems = 'flex-start';
    pager.style.gap = '8px';
    pager.style.marginTop = '10px';
    list.after(pager);
  }

  // carica inventario magie
  const owned = userStore.get('magics') || [];

  // se non possiedi magie: messaggio + pager vuoto e stop
  if (!owned.length) {
    list.innerHTML = '';
    pager.innerHTML = '';

    const emptyMsg = document.createElement('div');
    emptyMsg.className = 'magic-none-msg muted';
    emptyMsg.style.marginTop = '8px';
    emptyMsg.textContent = 'Non possiedi magie. Acquistale in Bottega.';
    list.appendChild(emptyMsg);
    return;
  }

  // helper
  const stripRarity = s => String(s || '').trim().replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');
  const rarityOrder = { 'Comune': 0, 'Rara': 1, 'Epica': 2, 'Leggendaria': 3, 'Mitica': 4 };
  const getRarity = n => {
    const m = String(n).match(/\[(Rara|Epica|Leggendaria|Mitica)\]$/i);
    return m ? (m[1][0].toUpperCase() + m[1].slice(1).toLowerCase()) : 'Comune';
  };

  // raggruppa per magia base
  const byBase = {};
  owned.forEach(n => {
    const base = stripRarity(n);
    (byBase[base] = byBase[base] || []).push(n);
  });

  // lista piatta ordinata per base -> rarit√†
  const flat = [];
  Object.keys(byBase).sort().forEach(base => {
    byBase[base]
      .sort((a, b) => rarityOrder[getRarity(a)] - rarityOrder[getRarity(b)])
      .forEach(fullName => flat.push({ base, fullName }));
  });

  const PER_PAGE = 10;
  let page = 1;

  function render() {
    list.innerHTML = '';
    pager.innerHTML = '';

    const start = (page - 1) * PER_PAGE;
    const slice = flat.slice(start, start + PER_PAGE);

    slice.forEach(({ base, fullName }) => {
      const btn = document.createElement('div');
      btn.className = `magic-option magic-${base}`;
      btn.textContent = fullName;   // mostra anche [Rara]/[Epica]/...
      // DELEGA a selectMagic (che fa il controllo possesso)
      btn.onclick = () => selectMagic(fullName);
      list.appendChild(btn);
    });

    const hasNext = (start + PER_PAGE) < flat.length;
    const hasPrev = page > 1;

    if (hasNext) {
      const nextBtn = document.createElement('button');
      nextBtn.textContent = 'Pagina successiva';
      nextBtn.onclick = () => { page++; render(); };
      pager.appendChild(nextBtn);
    }
    if (hasPrev) {
      const prevBtn = document.createElement('button');
      prevBtn.textContent = 'Pagina precedente';
      prevBtn.onclick = () => { page--; render(); };
      pager.appendChild(prevBtn);
    }
  }

  render();
}


function closeMagicPopup() {
  document.getElementById('magic-popup')?.classList.add('hidden');
  document.getElementById('generic-overlay')?.classList.add('hidden'); // chiude il backdrop
}
let handBeingEdited = null;

function openHandPopup(hand) {
  handBeingEdited = hand;

  // Inventario armi come oggetto { nome: qty }
  const allWeapons = userStore.get('weapons') || {};

  // Armi gi√† equipaggiate
  const right = userStore.get('rightHand');
  const left  = userStore.get('leftHand');

  // Conta quante copie sono gi√† utilizzate tra le due mani
  const used = {};
  if (right) used[right] = (used[right] || 0) + 1;
  if (left)  used[left]  = (used[left]  || 0) + 1;

  // Calcola quante copie rimangono disponibili per ogni arma
  const available = Object.keys(allWeapons)
    .map(name => {
      const total = allWeapons[name] || 0;
      const remaining = total - (used[name] || 0);
      return { name, count: remaining };
    })
    .filter(x => x.count > 0)
    .sort((a,b) => a.name.localeCompare(b.name));

  const container = document.getElementById('hand-weapon-options');

  // Titolo popup
  document.getElementById('hand-popup-title').textContent =
    `Seleziona Arma per la Mano ${hand === 'right' ? 'Destra' : 'Sinistra'}`;

  // Mostra overlay di sfondo (blocca i click dietro)
  const ov = document.getElementById('generic-overlay');
  if (ov) {
    ov.classList.remove('hidden');
    // chiudi cliccando fuori
    ov.onclick = closeHandPopup;
  }

  // Mostra il popup
  document.getElementById('hand-popup').classList.remove('hidden');
  positionModalUnderHeroType(document.getElementById('hand-popup'), 12);

  // --- Paginazione ---
  const PER_PAGE = 10;
  let page = 1;

  function render(){
    container.innerHTML = available.length === 0
      ? '<p>Non ci sono armi disponibili.</p>'
      : '';

    const start = (page - 1) * PER_PAGE;
    const slice = available.slice(start, start + PER_PAGE);

    // Bottoni arma
    slice.forEach(({ name, count }) => {
      const btn = document.createElement('button');
      btn.className = 'magic-button';
      const label = formatWeaponName(name) + (count > 1 ? ` (${count})` : '');
      btn.textContent = label;
      btn.onclick = () => selectWeaponForHand(name);
      container.appendChild(btn);
    });

    // Pager (aggiungi solo se serve)
    const hasNext = (start + PER_PAGE) < available.length;
    const hasPrev = page > 1;

    if (hasNext || hasPrev) {
      const pager = document.createElement('div');
      pager.style.display = 'flex';
pager.style.flexDirection = 'column';
pager.style.alignItems = 'flex-start';
pager.style.gap = '8px';
pager.style.marginTop = '10px';


      if (hasNext) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = 'Pagina successiva';
        nextBtn.onclick = () => { page++; render(); };
        pager.appendChild(nextBtn);
      }
      if (hasPrev) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = 'Pagina precedente';
        prevBtn.onclick = () => { page--; render(); };
        pager.appendChild(prevBtn);
      }

      container.appendChild(pager);
    }
  }

  render();
}

function selectWeaponForHand(weapon) { 
  if (!handBeingEdited) return;

  // salva
  if (handBeingEdited === 'right') {
    userStore.set('rightHand', weapon);
  } else {
    userStore.set('leftHand', weapon);
  }

  // aggiorna UI immediatamente con il nome formattato (mostra l'effetto)
  const label = formatWeaponName(weapon);
  const slotDisplay = document.getElementById(handBeingEdited + '-hand-display');
  if (slotDisplay) slotDisplay.textContent = label;

  // aggiorna anche il riepilogo nel profilo eroe (se presenti)
  if (handBeingEdited === 'right') {
    const r2 = document.getElementById('hero-weapon-right');
    if (r2) r2.textContent = label;
  } else {
    const l2 = document.getElementById('hero-weapon-left');
    if (l2) l2.textContent = label;
  }

  // riallinea arma/equip UI
  if (typeof updateEquippedWeaponsUI === 'function') {
    updateEquippedWeaponsUI();
  }

  // üî• ricalcola subito la potenza eroe
  if (typeof updateHeroPowerUI === 'function') {
    updateHeroPowerUI();
  }

  // opzionale: aggiorna anche la Sala degli Eroi
  try {
    if (typeof upsertCurrentHeroIntoDirectory === 'function') {
      upsertCurrentHeroIntoDirectory();
    }
  } catch (_) {}

  closeHandPopup();
}



function removeWeapon() {
  if (!handBeingEdited) return;

  if (handBeingEdited === 'right') {
    userStore.remove('rightHand');
  } else {
    userStore.remove('leftHand');
  }

  const slotDisplay = document.getElementById(handBeingEdited + '-hand-display');
  if (slotDisplay) slotDisplay.textContent = 'Nessuna';

  if (handBeingEdited === 'right') {
    const r2 = document.getElementById('hero-weapon-right');
    if (r2) r2.textContent = 'Nessuna';
  } else {
    const l2 = document.getElementById('hero-weapon-left');
    if (l2) l2.textContent = 'Nessuna';
  }

  if (typeof updateEquippedWeaponsUI === 'function') updateEquippedWeaponsUI();
  if (typeof updateHeroPowerUI === 'function') updateHeroPowerUI();
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    upsertCurrentHeroIntoDirectory();
  }

  closeHandPopup();
}

function closeHandPopup() {
  document.getElementById('hand-popup')?.classList.add('hidden');
  document.getElementById('generic-overlay')?.classList.add('hidden');
  handBeingEdited = null;
}

function selectMagic(name) {
  const owned = (userStore.get('magics') || []).includes(name);
  if (!owned) {
    if (typeof showGameMessage === 'function') {
      showGameMessage('Non possiedi questa magia', 'Acquistala in bottega prima di equipaggiarla.');
    }
    closeMagicPopup();
    return;
  }
  userStore.set('magic', name);
  updateMagicDisplay(name);

  if (typeof updateHeroPowerUI === 'function') updateHeroPowerUI();
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    upsertCurrentHeroIntoDirectory();
  }

  closeMagicPopup();
}

function removeMagic() {
  userStore.remove('magic');
  updateMagicDisplay('Nessuna');

  if (typeof updateHeroPowerUI === 'function') updateHeroPowerUI();
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    upsertCurrentHeroIntoDirectory();
  }

  closeMagicPopup();
}

function updateMagicDisplay(name) {
  const display = document.getElementById('selected-magic');
  if (!display) return;
  display.textContent = name;
  // stile neutro come gli altri equipaggiamenti
  display.className = 'equip-display';
}

// === Sala degli Eroi ===
const HERO_HALL_PAGE_SIZE = 20;
window.heroHallState = window.heroHallState || { page: 1, query: '' };

function showHeroHall(){
  // Nascondi la schermata principale (menu) e mostra la Sala degli Eroi
  const homeEl = document.getElementById('menu') 
              || document.getElementById('main') 
              || document.getElementById('home') 
              || document.getElementById('hub');
  if (homeEl) homeEl.classList.add('hidden');

  document.getElementById('hero-hall').classList.remove('hidden');

  // bind ricerca
  const input = document.getElementById('hero-hall-search');
  if (input && !input._heroHallBound) {
    input._heroHallBound = true;
    input.addEventListener('input', () => {
      heroHallState.query = (input.value || '').trim().toLowerCase();
      heroHallState.page = 1;
      renderHeroHall();
    });
  }

  // bind pager
  const prev = document.getElementById('hero-hall-prev');
  const next = document.getElementById('hero-hall-next');
  if (prev && !prev._heroHallBound) {
    prev._heroHallBound = true;
    prev.addEventListener('click', () => {
      if (heroHallState.page > 1) {
        heroHallState.page--;
        renderHeroHall();
      }
    });
  }
  if (next && !next._heroHallBound) {
    next._heroHallBound = true;
    next.addEventListener('click', () => {
      const list = getHeroDirectory();
      const filtered = filterHeroes(list, heroHallState.query);
      const totalPages = Math.max(1, Math.ceil(filtered.length / HERO_HALL_PAGE_SIZE));
      if (heroHallState.page < totalPages) {
        heroHallState.page++;
        renderHeroHall();
      }
    });
  }

  // reset ricerca e pagina e render
  heroHallState.page = 1;
  heroHallState.query = '';
  if (input) input.value = '';
// üîπ migrazione 1-tantum (se serve)
if (typeof migrateHeroDirectoriesOnce === 'function') migrateHeroDirectoriesOnce();
  renderHeroHall();
}

function backFromHeroHall(){
  // Torna al menu principale
  document.getElementById('hero-hall').classList.add('hidden');
  const homeEl = document.getElementById('menu') 
              || document.getElementById('main') 
              || document.getElementById('home') 
              || document.getElementById('hub');
  if (homeEl) homeEl.classList.remove('hidden');
}

function filterHeroes(list, query) {
  if (!query) return list;
  return list.filter(h =>
    (h.name || '').toLowerCase().includes(query)
  );
}

function renderHeroHall(){
  const body = document.getElementById('hero-hall-body');
  const pageInfo = document.getElementById('hero-hall-pageinfo');
  const prev = document.getElementById('hero-hall-prev');
  const next = document.getElementById('hero-hall-next');
  if (!body) return;

    // Directory completa
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];

  // ORDINE GLOBALE: punti decrescente = classifica assoluta
  const dirSorted = dir
    .slice()
    .sort((a, b) => Number(b.points || 0) - Number(a.points || 0));

  // Mappa veloce id -> rank (1-based) per mostrare il numero corretto
  const rankOf = Object.create(null);
  dirSorted.forEach((h, i) => { if (h && h.id) rankOf[h.id] = i + 1; });

  // Filtro testo applicato SULLA LISTA ORDINATA (cos√¨ mantieni l'ordine di rank)
  const filtered = filterHeroes(dirSorted, heroHallState.query);

  // Paginazione
  const total = filtered.length;
  const totalPages = Math.max(1, Math.ceil(total / HERO_HALL_PAGE_SIZE));
  const cur = Math.min(Math.max(1, heroHallState.page), totalPages);
  heroHallState.page = cur;

  const start = (cur - 1) * HERO_HALL_PAGE_SIZE;
  const pageItems = filtered.slice(start, start + HERO_HALL_PAGE_SIZE);

  // Riempi tabella
  if (pageItems.length === 0) {
    body.innerHTML = `
      <tr>
        <td colspan="5" class="muted">Nessun eroe registrato.</td>
      </tr>
    `;
  } else {
    body.innerHTML = pageItems.map(h => {
      const g4tag  = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { tag: '' };
const tag    = g4tag.tag ? `[${escapeHtml(g4tag.tag)}]` : '';
      // --- icona relazione gilda (alleato/guerra) ---
let tagWithIcon = tag;
try {
  const myGid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
  const opp = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { id: null };
  const oppId = opp && opp.id;
  if (myGid && oppId && typeof areAllied === 'function' && typeof atWar === 'function') {
    if (areAllied(myGid, oppId)) {
      tagWithIcon += ' <span class="ally-icon" title="Alleanza">üïäÔ∏è</span>';
    } else if (atWar(myGid, oppId)) {
      tagWithIcon += ' <span class="war-icon" title="Guerra">‚öîÔ∏è</span>';
    }
  }
} catch(_) {}

      const name   = escapeHtml(h.name || '');
      const level  = Number(h.level || 0);
      const points = Number(h.points || 0);
      const rank   = Number(rankOf[h.id] || 0);

      return `
  <tr>
    <td class="muted">${rank})</td>
    <td>${tagWithIcon}</td>
    <td>
      <button class="link-button" onclick="openHeroProfile('${h.id}')" style="display:block; width:100%; text-align:left;">
        ${name}${(Number(h.shieldEndAt || 0) > Date.now()
  ? ' <span title="Scudo attivo" style="text-decoration:none; display:inline-block;">üõ°Ô∏è</span>'
  : '')}

      </button>
    </td>
    <td>${level}</td>
    <td>${points}</td>
  </tr>
`;
    }).join('');
  }


  // gestione visibilit√†/abilitazione pulsanti
  if (totalPages <= 1) {
    if (prev) prev.style.display = 'none';
    if (next) next.style.display = 'none';
  } else if (cur === 1) {
    if (prev) prev.style.display = 'none';
    if (next) {
      next.style.display = '';
      next.disabled = false;
    }
  } else if (cur === totalPages) {
    if (prev) {
      prev.style.display = '';
      prev.disabled = false;
    }
    if (next) next.style.display = 'none';
  } else {
    if (prev) {
      prev.style.display = '';
      prev.disabled = false;
    }
    if (next) {
      next.style.display = '';
      next.disabled = false;
    }
  }
}
// === CLASSIFICA (Leaderboard) =================================================
const LB_PAGE_SIZE = 20;
window.leaderboardState = window.leaderboardState || { tab: 'world', page: 1, query: '' };
let _leaderboardLayoutReady = false;

// Calcola a quale pagina (da 1) si trova il mio eroe nel World Ranking
function getMyLeaderboardPage() {
  try {
    const me = (typeof currentUser === 'string') ? currentUser : null;
    if (!me) return 1;

    const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
    // Ordina come il World Ranking: punti decrescenti
    const sorted = dir.slice().sort((a, b) => Number(b?.points || 0) - Number(a?.points || 0));
    const idx = sorted.findIndex(h => h && h.name === me);
    if (idx < 0) return 1;

    // 0..19 => pag 1, 20..39 => pag 2, ecc. (rispetta LB_PAGE_SIZE)
    return Math.floor(idx / LB_PAGE_SIZE) + 1;
  } catch (_) {
    return 1;
  }
}

function showLeaderboard(){
  // Nascondi il menu e mostra la pagina classifica
  const menu = document.getElementById('menu');
  if (menu) menu.classList.add('hidden');
  const page = document.getElementById('leaderboard');
  if (page) page.classList.remove('hidden');

  // Costruzione layout a tab (una sola volta)
  upgradeLeaderboardLayout();

  // (consigliato) allinea/aggiorna il mio eroe in directory prima del render
  if (typeof upsertCurrentHeroIntoDirectory === 'function') {
    try { upsertCurrentHeroIntoDirectory(); } catch (_) {}
  }

  // reset stato ricerca/pagina e tab predefinito
leaderboardState.query = '';
leaderboardState.page = getMyLeaderboardPage();  // ‚¨ÖÔ∏è vai direttamente alla mia pagina
setLeaderboardTab('world');

  // pulisci l'input se esiste
  const inp = document.getElementById('lb-search');
  if (inp) inp.value = '';
}

// Costruisce Tabbar + contenitori
function upgradeLeaderboardLayout(){
  if (_leaderboardLayoutReady) return;
  _leaderboardLayoutReady = true;

  const root = document.getElementById('leaderboard-root');
  if (!root) return;

  // Tabbar
  const tabbar = document.createElement('div');
  tabbar.className = 'tabbar';
  tabbar.style.display = 'flex';
  tabbar.style.gap = '8px';
  tabbar.style.flexWrap = 'nowrap';
  tabbar.innerHTML = `
    <button id="lb-tab-world" class="tab-button active">World Ranking</button>
    <button id="lb-tab-wins" class="tab-button">Classifica Sfide Vinte</button>
    <button id="lb-tab-guilds" class="tab-button">Classifica Gilde</button>
  `;
  root.appendChild(tabbar);

  // Contenuto: WORLD
  const world = document.createElement('div');
  world.id = 'lb-pane-world';
  world.innerHTML = `
    <div class="traits-block sfide-compact">
      <div class="title">World Ranking</div>

      <div style="margin:8px 0;">
        <input id="lb-search" type="text" placeholder="Cerca per nome." style="width:100%; padding:8px; box-sizing:border-box;">
      </div>

      <div class="table-wrap">
        <table class="hero-table">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Tag</th>
              <th style="text-align:left;">Nome</th>
              <th>Livello</th>
              <th>Punti</th>
              <th style="width:1%;">&nbsp;</th>
            </tr>
          </thead>
          <tbody id="lb-world-body"></tbody>
        </table>
      </div>

      <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
        <button id="lb-prev" class="magic-button magic-button--compact">Pagina precedente</button>
        <span id="lb-pageinfo" class="muted"></span>
        <button id="lb-next" class="magic-button magic-button--compact">Pagina successiva</button>
      </div>
    </div>
  `;
  root.appendChild(world);

  // Contenuto: WINS (UI completa)
const wins = document.createElement('div');
wins.id = 'lb-pane-wins';
wins.className = 'hidden';
wins.innerHTML = `
  <div class="traits-block sfide-compact">
    <div class="title">Classifica Sfide Vinte</div>

    <div style="margin:8px 0;">
      <input id="wins-search" type="text" placeholder="Cerca per nome." style="width:100%; padding:8px; box-sizing:border-box;">
    </div>

    <div class="table-wrap">
      <table class="hero-table">
        <thead>
          <tr>
            <th>Rank</th>
            <th>Tag</th>
            <th style="text-align:left;">Nome</th>
            <th>Livello</th>
            <th>Vittorie</th>
          </tr>
        </thead>
        <tbody id="lb-wins-body"></tbody>
      </table>
    </div>

    <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
      <button id="wins-prev" class="magic-button magic-button--compact">Pagina precedente</button>
      <button id="wins-next" class="magic-button magic-button--compact">Pagina successiva</button>
    </div>
  </div>
`;

root.appendChild(wins);


  // Contenuto: GUILDS (UI completa)
  const guilds = document.createElement('div');
  guilds.id = 'lb-pane-guilds';
  guilds.className = 'hidden';
  guilds.innerHTML = `
    <div class="traits-block">
      <div class="title">Classifica Gilde</div>

      <div style="margin:8px 0;">
        <input id="guilds-search" type="text" placeholder="Cerca per nome" style="width:100%; padding:8px; box-sizing:border-box;">
      </div>

      <div class="table-wrap">
        <table class="hero-table">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Tag</th>
              <th>Nome</th>
              <th>Membri</th>
              <th>Punti</th>
            </tr>
          </thead>
          <tbody id="lb-guilds-body"></tbody>
        </table>
      </div>

      <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
        <button id="guilds-prev" class="magic-button magic-button--compact">Pagina precedente</button>
        <button id="guilds-next" class="magic-button magic-button--compact">Pagina successiva</button>
      </div>
    </div>
  `;
  root.appendChild(guilds);

  // Wiring tab
  document.getElementById('lb-tab-world') .addEventListener('click', () => setLeaderboardTab('world'));
  document.getElementById('lb-tab-wins')  .addEventListener('click', () => setLeaderboardTab('wins'));
  document.getElementById('lb-tab-guilds').addEventListener('click', () => setLeaderboardTab('guilds'));

  // Ricerca + paginazione WORLD
  const input = document.getElementById('lb-search');
  if (input) {
    input.addEventListener('input', () => {
      leaderboardState.query = (input.value || '').trim().toLowerCase();
      leaderboardState.page = 1;
      renderWorldRanking();
    });
  }
  const prev = document.getElementById('lb-prev');
  const next = document.getElementById('lb-next');
  if (prev) prev.addEventListener('click', () => {
    if (leaderboardState.page > 1) {
      leaderboardState.page--;
      renderWorldRanking();
    }
  });
  if (next) next.addEventListener('click', () => {
    const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
    const filtered = filterHeroes(dir, leaderboardState.query);
    const totalPages = Math.max(1, Math.ceil(filtered.length / LB_PAGE_SIZE));
    if (leaderboardState.page < totalPages) {
      leaderboardState.page++;
      renderWorldRanking();
    }
  });

  // Aggiornamento live su modifiche allo storage (cross-tab/altro utente)
  window.addEventListener('storage', (e) => {
    if (document.getElementById('leaderboard')?.classList.contains('hidden')) return;
    if (leaderboardState.tab !== 'world') return;
    if (e && e.key && !/heroDirectory|user:|guild/i.test(e.key)) return; // limito i refresh
    renderWorldRanking();
  });
// Ricerca + paginazione WINS
const wInput = document.getElementById('wins-search');
if (wInput) {
  wInput.addEventListener('input', () => {
    leaderboardState.winsQuery = (wInput.value || '').trim().toLowerCase();
    leaderboardState.winsPage = 1;
    renderWinsRanking();
  });
}
const wPrev = document.getElementById('wins-prev');
const wNext = document.getElementById('wins-next');
if (wPrev) wPrev.addEventListener('click', () => {
  if ((leaderboardState.winsPage || 1) > 1) {
    leaderboardState.winsPage--;
    renderWinsRanking();
  }
});
if (wNext) wNext.addEventListener('click', () => {
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const filtered = filterHeroes(dir, leaderboardState.winsQuery);
  // calcolo paginate su lista ordinata per vittorie
  const sorted = dir.slice().sort((a,b)=>{
    const aw = Number(a?.wins||0), bw = Number(b?.wins||0);
    if (bw !== aw) return bw - aw;             // 1) vittorie
    const ap = Number(a?.points||0), bp = Number(b?.points||0);
    if (bp !== ap) return bp - ap;             // 2) punti (tie-break)
    return (a?.name||'').localeCompare(b?.name||''); // 3) nome
  });
  const filtSorted = (typeof filterHeroes === 'function') ? filterHeroes(sorted, leaderboardState.winsQuery) : sorted;
  const totalPages = Math.max(1, Math.ceil(filtSorted.length / LB_PAGE_SIZE));
  if ((leaderboardState.winsPage || 1) < totalPages) {
    leaderboardState.winsPage = (leaderboardState.winsPage || 1) + 1;
    renderWinsRanking();
  }
});

// Refresh live su storage anche per WINS
window.addEventListener('storage', (e) => {
  if (document.getElementById('leaderboard')?.classList.contains('hidden')) return;
  if (leaderboardState.tab !== 'wins') return;
  if (e && e.key && !/heroDirectory|user:|guild/i.test(e.key)) return;
  renderWinsRanking();
});
  // Ricerca + paginazione GUILDS
  const gInput = document.getElementById('guilds-search');
  if (gInput) {
    gInput.addEventListener('input', () => {
      leaderboardState.guildsQuery = (gInput.value || '').trim().toLowerCase();
      leaderboardState.guildsPage = 1;
      renderGuildsRanking();
    });
  }
  const gPrev = document.getElementById('guilds-prev');
  const gNext = document.getElementById('guilds-next');
  if (gPrev) gPrev.addEventListener('click', () => {
    if ((leaderboardState.guildsPage || 1) > 1) {
      leaderboardState.guildsPage--;
      renderGuildsRanking();
    }
  });
  if (gNext) gNext.addEventListener('click', () => {
    // calcolo quante pagine ci sono sul set filtrato corrente
    const all = (typeof getGuilds === 'function') ? (getGuilds() || {}) : {};
    const ids = Object.keys(all);
    const rows = ids.map(id => ({ id, name: (all[id]?.name||''), tag: (all[id]?.tag||'') }));
    const q = String(leaderboardState.guildsQuery || '').trim().toLowerCase();
    const filtered = q
      ? rows.filter(r => r.name.toLowerCase().includes(q) || r.tag.toLowerCase().includes(q))
      : rows;
    const totalPages = Math.max(1, Math.ceil(filtered.length / LB_PAGE_SIZE));
    if ((leaderboardState.guildsPage || 1) < totalPages) {
      leaderboardState.guildsPage++;
      renderGuildsRanking();
    }
  });
  // Refresh live su storage anche per GUILDS
  window.addEventListener('storage', (e) => {
    if (document.getElementById('leaderboard')?.classList.contains('hidden')) return;
    if (leaderboardState.tab !== 'guilds') return;
    if (e && e.key && !/heroDirectory|user:|guild/i.test(e.key)) return;
    renderGuildsRanking();
  });

}

// Attiva tab e mostra/hide pannelli
function setLeaderboardTab(tab){
  leaderboardState.tab = tab;

  // Toggle pulsanti
  document.querySelectorAll('#leaderboard-root .tab-button').forEach(b => b.classList.remove('active'));
  const btnId = tab === 'world' ? 'lb-tab-world' : (tab === 'wins' ? 'lb-tab-wins' : 'lb-tab-guilds');
  document.getElementById(btnId)?.classList.add('active');

  // Toggle pannelli
  document.getElementById('lb-pane-world') ?.classList.toggle('hidden', tab !== 'world');
  document.getElementById('lb-pane-wins')  ?.classList.toggle('hidden', tab !== 'wins');
  document.getElementById('lb-pane-guilds')?.classList.toggle('hidden', tab !== 'guilds');

  // Se entri nella tab World e non c'√® una ricerca, vai alla mia pagina
  if (tab === 'world' && !leaderboardState.query) {
    leaderboardState.page = getMyLeaderboardPage();
  }

  // NEW: Se entri nella tab Vinte e non c'√® una ricerca, vai alla mia pagina Vinte
  if (tab === 'wins' && !leaderboardState.winsQuery) {
    leaderboardState.winsPage = getMyWinsPage();
  }

    if (tab === 'world') renderWorldRanking();
  if (tab === 'wins')  renderWinsRanking();
  if (tab === 'guilds') {
    if (!leaderboardState.guildsQuery) leaderboardState.guildsPage = 1;
    renderGuildsRanking();               // <‚Äî AGGIUNTO
  }

}


// Render del World Ranking (stesso schema della Sala degli Eroi, solo titolo diverso)
function renderWorldRanking(){
  const body = document.getElementById('lb-world-body');
  if (!body) return;

  const pageInfo = document.getElementById('lb-pageinfo');

  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];

// ORDINE GLOBALE (punti decrescenti) + mappa id -> rank assoluto
const sorted = dir.slice().sort((a,b) => Number(b?.points||0) - Number(a?.points||0));
const rankOf = Object.create(null);
sorted.forEach((h,i)=>{ if (h && h.id) rankOf[h.id] = i + 1; });

// Filtro testo applicato SULLA LISTA ORDINATA
const filtered = (typeof filterHeroes === 'function') ? filterHeroes(sorted, leaderboardState.query) : sorted;

const totalPages = Math.max(1, Math.ceil(filtered.length / LB_PAGE_SIZE));
const page = Math.max(1, Math.min(leaderboardState.page, totalPages));
leaderboardState.page = page;

const start = (page - 1) * LB_PAGE_SIZE;
const slice = filtered.slice(start, start + LB_PAGE_SIZE);

body.innerHTML = slice.map((h) => {
  const rank = Number(rankOf[h.id] || 0);
    const tag  = h?.tag ? `[${h.tag}]` : '';
    const name = (typeof escapeHtml === 'function') ? escapeHtml(h?.name || '') : (h?.name || '');
    const lvl = Number(h?.level || 0) || 0;
    const pts = Number(h?.points || 0) || 0;

    const nameCell = h?.id
  ? `<button class="link-button" onclick="openHeroProfile('${h.id}')" style="display:block; width:100%; text-align:left;">${name}</button>`
  : name;

    return `
      <tr>
        <td>${rank}</td>
        <td>${tag}</td>
        <td style="text-align:left;">${nameCell}</td>
        <td>${lvl}</td>
        <td>${pts}</td>
        <td></td>
      </tr>
    `;
  }).join('') || `<tr><td colspan="6" class="muted">Nessun eroe.</td></tr>`;

  // Regole visibilit√†/enable dei bottoni pagina
  const prev = document.getElementById('lb-prev');
  const next = document.getElementById('lb-next');
  if (prev) {
    prev.disabled = (page <= 1);
    prev.style.display = (totalPages > 1 && page > 1) ? '' : (totalPages > 1 ? 'none' : 'none');
  }
  if (next) {
    next.disabled = (page >= totalPages);
    next.style.display = (totalPages > 1 && page < totalPages) ? '' : (totalPages > 1 ? 'none' : 'none');
  }
}
// A quale pagina (da 1) si trova il mio eroe nella classifica "Vinte"
function getMyWinsPage() {
  try {
    const me = (typeof currentUser === 'string') ? currentUser : null;
    if (!me) return 1;
    const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
    const sorted = dir.slice().sort((a,b)=>{
      const aw = Number(a?.wins||0), bw = Number(b?.wins||0);
      if (bw !== aw) return bw - aw;             // vittorie
      const ap = Number(a?.points||0), bp = Number(b?.points||0);
      if (bp !== ap) return bp - ap;             // tie-break: punti
      return (a?.name||'').localeCompare(b?.name||''); // nome
    });
    const idx = sorted.findIndex(h => h && h.name === me);
    if (idx < 0) return 1;
    return Math.floor(idx / LB_PAGE_SIZE) + 1; // 0..19->1, 20..39->2, ...
  } catch (_) { return 1; }
}

function renderWinsRanking() {
  const body = document.getElementById('lb-wins-body');
  if (!body) return;

  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];

  // Ordina per VITTORIE, poi PUNTI, poi NOME
  const sorted = dir.slice().sort((a,b)=>{
    const aw = Number(a?.wins||0), bw = Number(b?.wins||0);
    if (bw !== aw) return bw - aw;
    const ap = Number(a?.points||0), bp = Number(b?.points||0);
    if (bp !== ap) return bp - ap;
    return (a?.name||'').localeCompare(b?.name||'');
  });

  // filtro testo
  const q = leaderboardState.winsQuery || '';
  const filtered = (typeof filterHeroes === 'function') ? filterHeroes(sorted, q) : sorted;

  // pagina
  const page = leaderboardState.winsPage || 1;
  const totalPages = Math.max(1, Math.ceil(filtered.length / LB_PAGE_SIZE));
  const start = (page - 1) * LB_PAGE_SIZE;
  const pageItems = filtered.slice(start, start + LB_PAGE_SIZE);

  // mappa id -> rank assoluto (nella classifica Vinte)
  const rankOf = Object.create(null);
  sorted.forEach((h,i) => { if (h && h.id) rankOf[h.id] = i + 1; });

  // gilda dell'utente corrente per nascondere "Sfida" ai compagni
  const myGuild = (typeof findGuildOfUser === 'function') ? findGuildOfUser((typeof currentUser==='string')?currentUser:'') : { id:null };

  body.innerHTML = pageItems.map(h => {
    if (!h) return '';
    const rank   = rankOf[h.id] || '‚Äî';
    const tagTxt = h.tag ? `[${escapeHtml(h.tag)}]` : '';
    const name   = escapeHtml(h.name || '');
    const lvl    = Number(h.level || 0);
    const wins   = Number(h.wins || 0);

    // Non posso sfidare me stesso/compagni di gilda
    const isMe      = (typeof currentUser==='string' && h.name === currentUser);
    const oppGuild  = (typeof findGuildOfUser === 'function') ? findGuildOfUser(h.name || '') : { id:null };
    const sameGuild = !!(myGuild.id && oppGuild.id && myGuild.id === oppGuild.id);

    const nameCell = h.id
      ? `<button class="link-button" onclick="openHeroProfile('${h.id}')" style="display:block; width:100%; text-align:left;">${name}</button>`
      : name;


    const actionCell = (!isMe && !sameGuild)
      ? `<button class="mini-button" data-id="${escapeHtml(h.id||'')}" data-name="${name}" onclick="startHeroChallenge(this.getAttribute('data-id'))">Sfida</button>`
      : '';

    return `
  <tr>
    <td>${rank}</td>
    <td>${tagTxt}</td>
    <td style="text-align:left;">${nameCell}</td>
    <td>${lvl}</td>
    <td>${Number(h?.wins || 0)}</td>
  </tr>
`;
  }).join('') || `<tr><td colspan="5" class="muted">Nessun eroe.</td></tr>`;

  // pager
  const prev = document.getElementById('wins-prev');
  const next = document.getElementById('wins-next');
if (prev && next) {
  if (totalPages <= 1) {
    // una sola pagina: niente bottoni
    prev.style.display = 'none';
    next.style.display = 'none';
  } else if (page === 1) {
    // prima pagina: solo "successiva"
    prev.style.display = 'none';
    next.style.display = '';
  } else if (page === totalPages) {
    // ultima pagina: solo "precedente"
    prev.style.display = '';
    next.style.display = 'none';
  } else {
    // pagine intermedie: entrambi
    prev.style.display = '';
    next.style.display = '';
  }

  // opzionale: togliamo gli "disabled" se presenti
  prev.disabled = false;
  next.disabled = false;
}
}

// === GUILDS: classifica per punti complessivi dei membri =====================
window.leaderboardState.guildsPage  = window.leaderboardState.guildsPage  || 1;
window.leaderboardState.guildsQuery = window.leaderboardState.guildsQuery || '';

function computeGuildPoints(gid){
  // somma i punti degli eroi membri della gilda gid
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const members = (typeof getGuildMembers === 'function') ? (getGuildMembers(gid) || []) : [];
  const memberNames = new Set(members.map(m => m && m.user).filter(Boolean));
  let tot = 0;
  for (const h of dir){
    if (h && memberNames.has(h.name)) tot += Number(h.points || 0);
  }
  return tot;
}

function renderGuildsRanking(){
  const body = document.getElementById('lb-guilds-body');
  if (!body) return;

  const all = (typeof getGuilds === 'function') ? (getGuilds() || {}) : {};
  const ids = Object.keys(all);

  // Costruisco lista {id, tag, name, banner, members, limit, points}
  const rows = ids.map(id => {
    const g = all[id] || {};
    const members = (typeof countGuildMembers === 'function') ? countGuildMembers(id) : ((typeof getGuildMembers==='function')?(getGuildMembers(id)||[]).length:0);
    const limit = g.limit || (typeof GUILD_MEMBER_LIMIT !== 'undefined' ? GUILD_MEMBER_LIMIT : 60);
    const points = computeGuildPoints(id);
    return {
      id,
      name: String(g.name || ''),
      tag:  String(g.tag  || ''),
      banner: g.banner || {},
      members,
      limit,
      points
    };
  });

  // Ordina per PUNTI ‚Üì, poi NOME ‚Üë
  rows.sort((a,b) => {
    if (b.points !== a.points) return b.points - a.points;
    return a.name.localeCompare(b.name);
  });

  // Filtro testo (nome/tag)
  const q = String(leaderboardState.guildsQuery || '').trim().toLowerCase();
  const filtered = q
    ? rows.filter(r => r.name.toLowerCase().includes(q) || r.tag.toLowerCase().includes(q))
    : rows;

  // Paginazione 20 per pagina
  const totalPages = Math.max(1, Math.ceil(filtered.length / LB_PAGE_SIZE));
  const page = Math.max(1, Math.min(leaderboardState.guildsPage || 1, totalPages));
  leaderboardState.guildsPage = page;

  const start = (page - 1) * LB_PAGE_SIZE;
  const pageRows = filtered.slice(start, start + LB_PAGE_SIZE);

  // Mappa id -> rank assoluto (nella classifica filtrata/ordinata)
  const rankOf = Object.create(null);
  filtered.forEach((r,i) => { rankOf[r.id] = i + 1; });

  // Render righe
  body.innerHTML = pageRows.map(r => {
    const rank = rankOf[r.id] || '‚Äî';
    const tag  = r.tag ? `[${escapeHtml(r.tag)}]` : '';
    const name = escapeHtml(r.name || '');

    return `
      <tr>
        <td>${rank}</td>
        <td>${tag}</td>
        <td>${name}</td>
        <td>${r.members}/${r.limit}</td>
        <td>${r.points}</td>
      </tr>
    `;
  }).join('') || `<tr><td colspan="5" class="muted">Nessuna gilda.</td></tr>`;

  // Bottoni pagina: prima=solo successiva, ultima=solo precedente, in mezzo=entrambi, una sola pagina=nessuno
  const prev = document.getElementById('guilds-prev');
  const next = document.getElementById('guilds-next');
  if (prev && next){
    if (totalPages <= 1) { prev.style.display = 'none'; next.style.display = 'none'; }
    else if (page === 1) { prev.style.display = 'none'; next.style.display = ''; }
    else if (page === totalPages) { prev.style.display = ''; next.style.display = 'none'; }
    else { prev.style.display = ''; next.style.display = ''; }
    prev.disabled = false; next.disabled = false;
  }
}

function openHeroProfile(heroId) {
  const dir = (typeof getHeroDirectory === 'function') ? getHeroDirectory() : [];
  const hero = dir.find(h => h.id === heroId);
  if (!hero) return;

  // Rileva se sto venendo dalla finestra "Membri di Gilda"
  const gmView   = document.getElementById('guild-members-view');
  const gScreen  = document.getElementById('guild-screen');
  const cameFromMembers = !!(gmView && !gmView.classList.contains('hidden'));

  // Salva la destinazione del back per questo profilo
const leaderboard = document.getElementById('leaderboard');
const cameFromLeaderboard = !!(leaderboard && !leaderboard.classList.contains('hidden'));

window._heroProfileBackTo = cameFromMembers
  ? 'guild-members'
  : (cameFromLeaderboard ? 'leaderboard' : null);

// Nascondi la finestra Membri / pagina Gilda / World Ranking (se visibili)
if (gmView)  gmView.classList.add('hidden');
if (gScreen) gScreen.classList.add('hidden');
if (cameFromLeaderboard && leaderboard) leaderboard.classList.add('hidden');


  // Riempie info profilo
  const info = document.getElementById('hero-profile-info');
  if (info) {
  // Calcolo rank globale (punti decrescenti)
const _dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
const _sorted = _dir.slice().sort((a,b)=> Number(b?.points||0) - Number(a?.points||0));
const _idx = _sorted.findIndex(h => h && h.id === heroId);
const _rankText = (_idx >= 0) ? String(_idx + 1) : '‚Äî';

// --- Reliquia di guerra pubblicata del profilo che sto guardando ---
let relicHtml = '';
try {
  const viewedUser = String(hero.name || '').trim();
  if (viewedUser && typeof getPublishedWarRelicForUser === 'function') {
    const pub = getPublishedWarRelicForUser(viewedUser);
    if (pub) {
      relicHtml = `
        <div id="viewed-war-relic" style="margin-top:6px;">
          <div class="card" style="padding:6px 8px; border-radius:8px; background:#fff; border:1px solid #d0caa9;">
            <span style="font-size:0.92em;">${pub.textHtml}</span>
          </div>
        </div>`;
    }
  }
} catch(_){}

  info.innerHTML = `
  <div class="hero-headline"
       style="font-weight:700;font-size:1.15rem;line-height:1.2;margin-bottom:6px;">
    ${hero.tag ? '[' + escapeHtml(hero.tag) + '] ' : ''}${escapeHtml(hero.name)}
    <span class="muted" style="font-weight:400;font-size:.9rem">(${hero.points || 0} pt)</span>
  </div>
  <div style="margin:2px 0 6px"><strong>Rank:</strong> ${_rankText}</div>
  <div><strong>Tipo di eroe:</strong> ${escapeHtml(hero.classe || '')}</div>
  <div><strong>Livello:</strong> ${Number(hero.level || 0)}</div>
    
<!-- ‚¨ÖÔ∏é AGGIORNATO: inseriamo il separatore uguale al profilo personale -->
<!-- separatore: SEMPRE visibile -->
<div id="other-hero-sep" class="motto-sep" aria-hidden="true"></div>

<!-- motto: solo se presente -->
${
  hero.motto
    ? `
      <div style="text-align:center;margin-top:6px;"><strong>Motto personale</strong></div>
      <div id="other-hero-motto" style="text-align:center;margin-top:2px;">${escapeHtml(hero.motto)}</div>
    `
    : ''
}

  ${relicHtml}
`;
}

  // Abilita "Invia messaggio" e indirizza al nome eroe
const msgBtn = document.getElementById('hero-send-message');
if (msgBtn) {
  msgBtn.disabled = false;
  msgBtn.removeAttribute('aria-disabled');
  msgBtn.classList.remove('disabled', 'is-disabled');

  const recipient = String(hero.name || '').trim(); // username
  msgBtn.onclick = () => {
    // Se siamo arrivati al profilo dalla finestra Membri, allora il compose dovr√† tornare ai Membri
    if (window._heroProfileBackTo === 'guild-members') {
  window._composeBackTo = 'guild-members';
} else if (window._heroProfileBackTo === 'leaderboard') {
  window._composeBackTo = 'leaderboard';
} else {
  window._composeBackTo = 'hero-hall';
}
    openComposeTo(recipient);
  };
}
// ‚Äî‚Äî‚Äî Pulsante "Sfida": mostra/abilita solo se NON √® il mio profilo e NON √® della mia stessa gilda ‚Äî‚Äî‚Äî
const challengeBtn = document.getElementById('hero-challenge');
if (challengeBtn) {
  // Default: nascosto e disabilitato
  challengeBtn.style.display = 'none';
  challengeBtn.disabled = true;
  challengeBtn.onclick = null;

  const me = (typeof currentUser === 'string') ? currentUser : null;
  const isSelf = (name && me && name === me);

  let sameGuild = false;
  try {
    const myG  = me   ? findGuildOfUser(me)   : { id: null };
    const oppG = name ? findGuildOfUser(name) : { id: null };
    sameGuild = !!(myG && oppG && myG.id && oppG.id && myG.id === oppG.id);
  } catch (e) {}

  if (!isSelf && !sameGuild && hero && hero.id) {
    challengeBtn.style.display = '';   // mostra
    challengeBtn.disabled = false;     // abilita
    const oppShieldOn = (Number(hero.shieldEndAt || 0) > Date.now());
const myShieldOn  = (typeof isShieldActive === 'function') ? isShieldActive() : false;

challengeBtn.onclick = () => {
  if (myShieldOn) {
    showGameMessage(
      'Scudo attivo',
      'Hai uno scudo attivo: non puoi lanciare sfide tra eroi finch√© √® attivo.'
    );
    return;
  }
  if (oppShieldOn) {
    showGameMessage(
      'Scudo attivo',
      "L'eroe ha uno scudo attivo e non pu√≤ essere sfidato."
    );
    return;
  }
  startHeroChallenge(hero.id);
};

  }
}

  // Nascondi la Hall e mostra il profilo
  const hall = document.getElementById('hero-hall');
  if (hall) hall.classList.add('hidden');
  const profileView = document.getElementById('hero-profile-view');
  if (profileView) profileView.classList.remove('hidden');

updateShieldLinkLabel();

  // --- Wiring del pulsante "‚Üê Indietro" in alto (mini-button mini-button--dark) ---
  // Cerco prima un bottone "ufficiale" se esiste, altrimenti uno generico con classi mini-button
  const backTopBtn =
    document.getElementById('hero-back-top') ||
    (profileView && profileView.querySelector('.mini-button.mini-button--dark'));

  if (backTopBtn) {
  backTopBtn.onclick = () => {
    if (window._heroProfileBackTo === 'guild-members') {
      window._heroProfileBackTo = null;
      document.getElementById('hero-profile-view')?.classList.add('hidden');
      document.getElementById('guild-members-view')?.classList.remove('hidden');
      return;
    }
    if (window._heroProfileBackTo === 'leaderboard') {
      window._heroProfileBackTo = null;
      document.getElementById('hero-profile-view')?.classList.add('hidden');
      document.getElementById('leaderboard')?.classList.remove('hidden');
      return;
    }
    // fallback: Sala degli Eroi
    if (hall) hall.classList.remove('hidden');
    profileView?.classList.add('hidden');
  };
}


  // --- (Opzionale) anche il bottone "Torna indietro" in basso, se presente, pu√≤ seguire la stessa logica ---
  const backBottomBtn =
    document.getElementById('hero-profile-back') || // se hai un id per il back in basso
    (profileView && profileView.querySelector('.hero-action.back')); // eventuale classe

  if (backBottomBtn) {
  backBottomBtn.onclick = () => {
    if (window._heroProfileBackTo === 'guild-members') {
      window._heroProfileBackTo = null;
      document.getElementById('hero-profile-view')?.classList.add('hidden');
      document.getElementById('guild-members-view')?.classList.remove('hidden');
      return;
    }
    if (window._heroProfileBackTo === 'leaderboard') {
      window._heroProfileBackTo = null;
      document.getElementById('hero-profile-view')?.classList.add('hidden');
      document.getElementById('leaderboard')?.classList.remove('hidden');
      return;
    }
    if (hall) hall.classList.remove('hidden');
    profileView?.classList.add('hidden');
  };
}

}

function backFromHeroProfile(){
  document.getElementById('hero-profile-view').classList.add('hidden');
  document.getElementById('hero-hall').classList.remove('hidden');
}

function goToMenu(){
  document.getElementById('hero-profile-view').classList.add('hidden');
  const menu = document.getElementById('menu');
  if (menu) menu.classList.remove('hidden');
}


// Inserisce/aggiorna il mio eroe nell‚Äôarchivio persistente (heroDirectory)
function upsertCurrentHeroIntoDirectory() {
  try {
    if (typeof getHeroDirectory !== 'function' || typeof setHeroDirectory !== 'function') return;
    const username = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
    if (!username) return;

    // dati base
    const heroType = userStore.get('hero') || 'Umano';
    const level    = Number(getNum('level', 1)) || 1;

    // üî• calcola la Potenza eroe attuale (arrotondata)
    let power = 0;
    try {
      if (typeof computeHeroPower === 'function') {
        power = Math.round(Number(computeHeroPower() || 0));
      }
    } catch (_) {
      power = 0;
    }

    // Directory attuale + eventuale entry esistente
    const list = (getHeroDirectory() || []);
    const myId = 'user:' + username;
    const existing = list.find(h => h && h.id === myId);

    // punti: preferisci quelli in directory (se >0), altrimenti quelli nello userStore
    const dirPts  = Number(existing?.points || 0) || 0;
    const usrPts  = Number(userStore.get('heroPoints') || 0) || 0;
    const points  = (dirPts || usrPts || 0);

    // sincronizza anche lo userStore (cos√¨ resta coerente)
    try {
      userStore.set('heroPoints', points);
      userStore.set('points', points); // retrocompatibilit√†
    } catch {}

    // HP: prendiamo lo stato attuale dell'eroe, se le funzioni esistono,
    // altrimenti cadiamo su quanto c'√® gi√† in directory o su 100 di default.
    let hpMax = 0;
    let hp    = 0;

    try {
      if (typeof getHeroHpMax === 'function') {
        hpMax = Number(getHeroHpMax() || 0) || 0;
      }
      if (typeof getHeroHp === 'function') {
        hp = Number(getHeroHp() || 0) || 0;
      }
    } catch (_) {}

    if (!hpMax) {
      hpMax = Number(existing?.hpMax || existing?.hp || 100) || 100;
    }
    if (!hp && hp !== 0) {
      hp = Number(existing?.hp || hpMax) || hpMax;
    }

    // clamp e arrotondamento
    hpMax = Math.max(1, Math.round(hpMax));
    hp    = Math.max(0, Math.min(hpMax, +hp.toFixed(1)));

    // tag gilda (se c‚Äô√®)
    let tag = '';
    try {
      const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
      if (gid) {
        const all = (typeof getGuilds === 'function') ? getGuilds() : {};
        const g = all[gid];
        if (g && g.tag) tag = g.tag;
      }
    } catch (_) {}

    // üëá adesso la directory salva anche "power", "hpMax" e "hp"
    const entry = {
      id: myId,
      tag,
      name: username,
      classe: heroType,
      level,
      points,
      power,
      hpMax,
      hp,
      shieldEndAt: (typeof getShieldEndAt === 'function') ? getShieldEndAt() : 0
    };

    const idx = list.findIndex(h => h && h.id === myId);
    if (idx >= 0) {
      // preserva il resto dei campi (motto, ecc.) e aggiorna quelli nuovi
      list[idx] = { ...existing, ...entry };
    } else {
      list.unshift(entry); // in alto
    }
    setHeroDirectory(list);
  } catch (_) { /* no-op */ }
}

// piccolo helper per evitare injection nel nome/classe
function escapeHtml(s){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function showShop() {
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('chest-room')?.classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function showArmors() {
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('armor-storage').classList.remove('hidden');
  _invPage.armors = 1;
populateStorage('armor-list', 'armors', 1);

}

function showCreatures() {
  document.getElementById('inventory').classList.add('hidden');
  document.getElementById('creature-storage').classList.remove('hidden');
  // Usa il renderer comune dei depositi (genera bottoni cliccabili)
  _invPage.creatures = 1;
populateStorage('creature-list', 'creatures', 1);

}

function showChestsRoom(){
  ensureKeyStores?.();
  ensureChestStores?.();          // assicura gli store dei forzieri

  document.getElementById('shop').classList.add('hidden');
  document.getElementById('chest-room').classList.remove('hidden');

  renderKeyBelt?.();              // aggiorna subito le chiavi

  // Preseleziona ‚ÄúArmi‚Äù e renderizza i 4 forzieri
  selectChestCategory('armi');
}

function renderKeyBelt() {
  if (typeof getKeySummary !== 'function') return;
  const sum = getKeySummary(); // { ottone:{keys:..}, argento:{..}, ... }
  const map = {
    ottone: 'key-count-ottone',
    argento: 'key-count-argento',
    oro: 'key-count-oro',
    runica: 'key-count-runica'
  };
  Object.keys(map).forEach(id => {
    const el = document.getElementById(map[id]);
    if (el) el.textContent = sum?.[id]?.keys ?? 0;
  });
}

function creaturePlaceholder(name){
  const letter = (name || '?').trim().charAt(0).toUpperCase() || '?';
  // colore derivato dal nome
  let hash = 0;
  for (let i=0; i<name.length; i++) hash = (hash*31 + name.charCodeAt(i)) >>> 0;
  const h1 = hash % 360;
  const h2 = (h1 + 40) % 360;
  const c1 = `hsl(${h1} 65% 45%)`;
  const c2 = `hsl(${h2} 70% 60%)`;
  const svg =
    `<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160'>
       <defs>
         <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
           <stop offset='0%' stop-color='${c1}'/>
           <stop offset='100%' stop-color='${c2}'/>
         </linearGradient>
       </defs>
       <rect width='100%' height='100%' rx='16' ry='16' fill='url(#g)'/>
       <text x='50%' y='54%' font-size='92' text-anchor='middle'
             font-family='Arial, sans-serif' fill='rgba(255,255,255,.95)'
             dominant-baseline='middle'>${letter}</text>
     </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

// ====== Bottega Arcana ‚Äì Config ======
const ARCANE_KEY_SHOP = [
  { id:'ottone',  css:'key--rame',     name:'Chiave del Mercante',     cost:40,
    desc:'Questa chiave apre i forzieri del Mercante. Piccoli tesori, grandi sorprese.' },
  { id:'argento', css:'key--argento',  name:'Chiave dell‚ÄôAvventuriero', cost:60,
    desc:'Questa chiave apre i forzieri dell‚ÄôAvventuriero. Ricompense di valore crescente.' },
  { id:'oro',     css:'key--oro',      name:'Chiave del Re',            cost:80,
    desc:'Questa chiave apre i forzieri del Re. Premi rari e potenti.' },
  { id:'runica',  css:'key--runica',   name:'Chiave Arcana',            cost:100,
    desc:'Questa chiave apre i forzieri Arcani. Potere antico e misterioso.' }
];

// ====== Sezione principale ======
function showArcaneShop(){
  // nascondi schermate e mostra bottega arcana
  const shop = document.getElementById('shop');
  if (shop) shop.classList.add('hidden');
  const screen = document.getElementById('arcane-shop');
  if (screen) screen.classList.remove('hidden');

  // aggiorna polvere
  const dustEl = document.getElementById('arcane-dust-amount');
  if (dustEl && typeof getArcaneDust === 'function') dustEl.textContent = getArcaneDust();

  renderArcaneShop();
}

function goBackFromArcaneShop(){
  document.getElementById('arcane-shop')?.classList.add('hidden');
  document.getElementById('shop')?.classList.remove('hidden');
}

function renderArcaneShop(){
  const box = document.getElementById('arcane-items-list');
  if (!box) return;
  box.innerHTML = '';

  ARCANE_KEY_SHOP.forEach(k => {
    const card = document.createElement('div');
    card.className = 'key-shop-card';
    card.innerHTML = `
      <img class="key-ico ${k.css}" src="imgkey-blank.png" alt="${k.name}">
      <div class="key-label" style="margin:6px 0 4px">${k.name}</div>
      <div class="muted" style="font-size:12px;">Costo: <strong>${k.cost}</strong> Polvere Arcana</div>
      <button class="magic-button key-name-btn" onclick="openArcaneKeyDetail('${k.id}')">${k.name}</button>
    `;
    box.appendChild(card);
  });
}

// ====== Popup dettaglio/Acquisto ======
function ensureArcaneShopModal(){
  let overlay = document.getElementById('arcane-overlay');
  let modal   = document.getElementById('arcane-detail');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'arcane-overlay';
    overlay.className = 'hidden overlay-common';
    overlay.onclick = closeArcaneDetail;
    document.body.appendChild(overlay);
  }
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'arcane-detail';
    modal.className = 'hidden modal-common';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');
    modal.innerHTML = `
      <h3 id="arcane-detail-title">Bottega Arcana</h3>
      <div id="arcane-detail-body" class="scroll-area"></div>
      <div class="modal-actions modal-actions--stack">
        <button id="arcane-detail-buy" class="magic-button">Acquista</button>
        <button class="magic-button" onclick="closeArcaneDetail()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
}

function openArcaneKeyDetail(id){
  ensureArcaneShopModal();

  const cfg = ARCANE_KEY_SHOP.find(x => x.id === id);
  if (!cfg) return;

  const overlay = document.getElementById('arcane-overlay');
  const modal   = document.getElementById('arcane-detail');
  const title   = document.getElementById('arcane-detail-title');
  const body    = document.getElementById('arcane-detail-body');
  const buyBtn  = document.getElementById('arcane-detail-buy');

  if (!overlay || !modal || !title || !body || !buyBtn) return;

  title.textContent = cfg.name;
  body.innerHTML = `
    <img class="key-ico ${cfg.css}" src="imgkey-blank.png" alt="${cfg.name}">
    <p style="margin-top:8px">${cfg.desc}</p>
    <p style="margin-top:6px"><strong>Costo:</strong> ${cfg.cost} unit√† di Polvere Arcana</p>
  `;

  buyBtn.onclick = function(){ buyArcaneKey(cfg.id, cfg.cost, cfg.name); };

  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');
}

function closeArcaneDetail(){
  const o = document.getElementById('arcane-overlay');
  const m = document.getElementById('arcane-detail');
  if (o) o.classList.add('hidden');
  if (m) m.classList.add('hidden');
}

function buyArcaneKey(id, cost, displayName){
  // controlla polvere
  if (typeof getArcaneDust !== 'function' || typeof addArcaneDust !== 'function' || typeof addKey !== 'function'){
    showGameMessage('Errore', 'Funzioni non disponibili.');
    return;
  }
  var dust = getArcaneDust();
  if (dust < cost){
    showGameMessage('Polvere insufficiente', `Ti servono <strong>${cost}</strong> unit√† di Polvere Arcana.`);
    return;
  }

  // spesa + chiave
  addArcaneDust(-cost);
  addKey(id, 1);

  // UI: aggiorna bottega arcana
  var d1 = document.getElementById('arcane-dust-amount');
  if (d1) d1.textContent = getArcaneDust();

  // UI: aggiorna la Sala dei Forzieri se visibile (chiavi + polvere)
  if (typeof renderKeyBelt === 'function') renderKeyBelt();
  var d2 = document.getElementById('dust-counter');
  if (d2) d2.textContent = getArcaneDust();

  closeArcaneDetail();
  showGameMessage('Complimenti!', `Hai acquistato 1 <strong>${displayName}</strong>.`);
}


function showArmorShop() {
  // Mostra la schermata bottega armature
  document.getElementById('shop').classList.add('hidden');
  document.getElementById('armor-shop').classList.remove('hidden');

  // Aggiorna oro corrente
  const gold = getNum('gold', 0);
  document.getElementById('armor-shop-gold').textContent = formatGold(gold);

  // Lista pulsanti armature
  const list = document.getElementById('armor-buttons-list');
  list.innerHTML = '';

  (window.armorCatalog || []).forEach(arm => {
    const btn = document.createElement('button');
    btn.className = 'magic-button';
    const owned = window.isArmorOwned && window.isArmorOwned(arm.name);

    btn.textContent = owned ? `${arm.name} (gi√† posseduta)` : arm.name;

    // ‚úÖ non disabilitare: vogliamo aprire il popup anche se gi√† posseduta
    btn.disabled = false;

    // (opzionale) stile visivo per gi√† posseduta
    if (owned) btn.classList.add('owned-item');

    // üîë apre il popup dettagli
    btn.onclick = () => showArmorDetails(arm);

    list.appendChild(btn);
  });
}


function goBackFromArmorShop() {
  document.getElementById('armor-shop').classList.add('hidden');
  document.getElementById('shop').classList.remove('hidden');
}

function showArmorDetails(armor, fromInventory = false) {
  // se esiste, assicura il modal
  if (typeof ensureArmorModal === 'function') ensureArmorModal();

  const overlay = document.getElementById('armor-overlay');
  const modal   = document.getElementById('armor-detail');
  const titleEl = document.getElementById('armor-detail-title');
  const bodyEl  = document.getElementById('armor-detail-body');
  const buyBtn  = document.getElementById('armor-detail-buy');

  if (!overlay || !modal || !titleEl || !bodyEl || !buyBtn) {
    console.error('Popup armature: elementi mancanti.');
    return;
  }

  // prezzo sicuro
  const price = Number(armor.price ?? armor.cost ?? 0);
  const safePrice = isNaN(price) ? 0 : price;

  // possesso
  const ownedList = userStore.get('armors') || [];
  const owned = ownedList.includes(armor.name);

  // contenuti base
  titleEl.textContent = armor.name;
  const desc = armor.desc ?? armor.description ?? '';

  // --- Caratteristiche base ---
  const tr = armor.traits || {};
  const T = {
    Difesa: Number(tr.Difesa) || 0,
    Resistenza: Number(tr.Resistenza) || 0,
    Agilit√†: Number(tr.Agilit√†) || 0,
    Peso: Number(tr.Peso) || 0
  };

  // --- BONUS da Cristalli (solo Difesa/Resistenza) ---
  const upMap = userStore.get('armorUp') || {};
  const up = upMap[armor.name] || { Difesa: 0, Resistenza: 0 };
  const bDif = Number(up.Difesa) || 0;
  const bRes = Number(up.Resistenza) || 0;

const rawRarity = (armor.rarity ?? '').toString().trim().toLowerCase();
const rarity = rawRarity || 'comune';  // fallback di sicurezza
const rarityLabel = rarity.charAt(0).toUpperCase() + rarity.slice(1);
const rarityClass = `rarity rarity--${rarity}`;

  const traitsHtml = `
  <div class="traits-block">
    <div class="title">Caratteristiche</div>
    <div class="traits-grid">
      <div>Rarit√†: <strong class="${rarityClass}">${rarityLabel}</strong></div>
      <div>${formatStatWithBonus('Difesa', T.Difesa, bDif)}</div>
      <div>${formatStatWithBonus('Resistenza', T.Resistenza, bRes)}</div>
      <div>Agilit√†: <strong>${T.Agilit√†}</strong></div>
      <div>Peso: <strong>${T.Peso}</strong></div>
    </div>
  </div>
`;

  const priceRow = fromInventory ? '' : `<p><strong>Prezzo:</strong> ${formatGold(safePrice)} monete d'oro</p>`;

  const imgSrc = getArmorImageSrc(armor.name);
const baseForAlt = armor.name;

// corpo popup (con immagine in alto)
bodyEl.innerHTML = `
  <img class="weapon-thumb"
       src="${imgSrc}"
       alt="${baseForAlt}"
       onerror="this.onerror=null; this.src='armors/${encodeURIComponent(baseForAlt)}.jpg';">
  <p>${desc}</p>
  ${traitsHtml}
  ${priceRow}
`;


  if (fromInventory) {
    buyBtn.style.display = 'none';
    buyBtn.onclick = null;

    // Pulsante Equipaggia
    const equipBtn = document.createElement('button');
    equipBtn.className = 'magic-button';
    equipBtn.textContent = 'Equipaggia';
    if (!owned) equipBtn.disabled = true;

    equipBtn.onclick = () => {
      if (typeof window.setEquippedArmor === 'function') {
        window.setEquippedArmor(armor.name);
      } else {
        // fallback
        userStore.set('equippedArmor', armor.name);
        const ae = document.getElementById('equipped-armor');
        if (ae) ae.textContent = armor.name;
      }
      if (typeof showGameMessage === 'function') {
        showGameMessage('Equipaggiata', `Hai equipaggiato <strong>${armor.name}</strong>.`);
      }
      if (typeof closeArmorDetail === 'function') closeArmorDetail();
    };

    bodyEl.appendChild(document.createElement('hr'));
    bodyEl.appendChild(equipBtn);
// --- Converti in Polvere (solo rarit√† non comune) ---
const gainDust = (typeof DUST_BY_RARITY !== 'undefined') ? (DUST_BY_RARITY[rarity] || 0) : 0;
if (gainDust > 0) {
  const dustBtn = document.createElement('button');
  dustBtn.className = 'magic-button';
  dustBtn.textContent = `Converti in Polvere (+${gainDust})`;
  dustBtn.onclick = () => {
    confirmConvertToDust(gainDust, () => {
      const list = userStore.get('armors') || [];
      const i = list.indexOf(armor.name);
      if (i >= 0) { list.splice(i, 1); userStore.set('armors', list); }

      // se equipaggiata, pulisci e UI
      const eq = userStore.get('equippedArmor');
      if (eq === armor.name) {
        userStore.remove('equippedArmor');
        const el = document.getElementById('equipped-armor');
        if (el) el.textContent = 'Nessuna';
      }

      if (typeof addArcaneDust === 'function') addArcaneDust(gainDust);
      updateDustBadges();

      if (window._invPage && _invPage.armors) populateStorage('armor-list','armors', _invPage.armors);

      closeArmorDetail?.();
      showGameMessage('Conversione riuscita', `Hai ottenuto <strong>${gainDust}</strong> unit√† di Polvere Arcana.`);
    });
  };
  bodyEl.appendChild(dustBtn);
}
    // Vendi (SOLO comune)
    if (rarity === 'comune' && owned) {
      const sellPrice = Math.ceil((safePrice * 2) / 3);
      if (sellPrice > 0) {
        const sellBtn = document.createElement('button');
        sellBtn.className = 'magic-button';
        sellBtn.textContent = `Vendi (+${formatGold(sellPrice)} oro)`;
        sellBtn.onclick = function () {
          confirmSellItem(sellPrice, function () {
            const list = userStore.get('armors') || [];
            const idx = list.indexOf(armor.name);
            if (idx >= 0) { list.splice(idx, 1); userStore.set('armors', list); }

            const eq = userStore.get('equippedArmor');
            if (eq === armor.name) {
              userStore.remove('equippedArmor');
              const ae = document.getElementById('equipped-armor'); if (ae) ae.textContent = 'Nessuna';
            }

            if (typeof addNum === 'function') addNum('gold', sellPrice);
            if (typeof updateGoldBadges === 'function') updateGoldBadges();

if (typeof incrementQuest === 'function') incrementQuest('q_daily_sell_item_shop', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();


            if (window._invPage && _invPage.armors) populateStorage('armor-list', 'armors', _invPage.armors);

            if (typeof closeArmorDetail === 'function') closeArmorDetail();
            if (typeof showGameMessage === 'function') showGameMessage('Vendita riuscita', `Hai ottenuto <strong>${formatGold(sellPrice)}</strong> monete d'oro.`);
          });
        };
        bodyEl.appendChild(document.createElement('div')).style.height = '8px';
        bodyEl.appendChild(sellBtn);
      }
    }
  } else {
    // Shop
    buyBtn.style.display = 'inline-block';
    if (owned) {
      buyBtn.disabled = true;
      buyBtn.textContent = 'Gi√† posseduta';
      buyBtn.onclick = null;
    } else {
      buyBtn.disabled = false;
      buyBtn.textContent = 'Acquista';
      buyBtn.onclick = () => {
        buyArmor(armor.name, safePrice);
        if (typeof closeArmorDetail === 'function') closeArmorDetail();

        // Aggiorna oro mostrato nella bottega e nel profilo (se presenti)
        const gold = getNum('gold', 0);
        const shopGoldEl = document.getElementById('armor-shop-gold');
        if (shopGoldEl) shopGoldEl.textContent = formatGold(gold);
        const heroGoldEl = document.getElementById('hero-gold');
        if (heroGoldEl) heroGoldEl.innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;
      };
    }
  }

    lockBodyScroll();
  overlay.classList.remove('hidden');
  modal.classList.remove('hidden');

applyRarityDecor(modal, titleEl, rarity);
positionModalBelowSectionTitle(modal, fromInventory ? '#armor-storage' : '#armor-shop', 16);

}

function closeArmorDetail() {
  document.getElementById('armor-overlay')?.classList.add('hidden');
  document.getElementById('armor-detail')?.classList.add('hidden');
  unlockBodyScroll();
}

function buyArmor(name, cost) {
  if (window.isArmorOwned && window.isArmorOwned(name)) {
    closeArmorDetail();
    showArmorShop();
    return;
  }

  let gold = getNum('gold', 0);
  if (gold < cost) {
    showGameMessage("Oro insufficiente", "Non hai abbastanza oro per acquistare questa armatura.");
    return;
  }

  gold -= cost;
  setNum('gold', gold);

  const armors = userStore.get('armors') || [];
  if (!armors.includes(name)) {
    armors.push(name);
    userStore.set('armors', armors);
  }

  document.getElementById('armor-shop-gold').textContent = formatGold(gold);
  document.getElementById('hero-gold').innerHTML = `<strong>Oro:</strong> ${formatGold(gold)} monete d'oro`;

  closeArmorDetail();
  showArmorShop();
  showGameMessage("Complimenti!", "L'acquisto √® andato a buon fine!");
if (typeof incrementQuest === 'function') incrementQuest('q_daily_classic_shop_buy_equipment', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
}

function openArmorSelect() {
  const list = document.getElementById('armor-choice-list');
  const owned = (window.getArmors && window.getArmors()) || [];

  const PER_PAGE = 10;
  let page = 1;

  function render() {
    list.innerHTML = '';

    if (!owned.length) {
      list.innerHTML = '<p>Nessuna armatura posseduta.</p>';
      return;
    }

    const start = (page - 1) * PER_PAGE;
    const slice = owned.slice(start, start + PER_PAGE);

    // bottoni armature
    slice.forEach(n => {
      const btn = document.createElement('button');
      btn.className = 'magic-button';
      btn.style.marginBottom = '8px';
      btn.textContent = n;
      btn.onclick = () => selectArmorToEquip(n);
      list.appendChild(btn);
    });

    // pager
    const hasNext = (start + PER_PAGE) < owned.length;
    const hasPrev = page > 1;

    if (hasNext || hasPrev) {
      const pager = document.createElement('div');
      pager.style.display = 'flex';
pager.style.flexDirection = 'column';
pager.style.alignItems = 'flex-start';
pager.style.gap = '8px';
pager.style.marginTop = '10px';


      if (hasNext) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = 'Pagina successiva';
        nextBtn.onclick = () => { page++; render(); };
        pager.appendChild(nextBtn);
      }
      if (hasPrev) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = 'Pagina precedente';
        prevBtn.onclick = () => { page--; render(); };
        pager.appendChild(prevBtn);
      }

      list.appendChild(pager);
    }
  }

  render();

  document.getElementById('armor-select-overlay').classList.remove('hidden');
  document.getElementById('armor-select-popup').classList.remove('hidden');
  positionModalUnderHeroType(document.getElementById('armor-select-popup'), 12);

}
function closeArmorSelect() {
  document.getElementById('armor-select-overlay').classList.add('hidden');
  document.getElementById('armor-select-popup').classList.add('hidden');
}
function selectArmorToEquip(name) {
  // salva armatura equipaggiata
  if (window.setEquippedArmor) {
    window.setEquippedArmor(name);
  }

  // aggiorna etichetta nel profilo
  const el = document.getElementById('equipped-armor');
  if (el) el.textContent = name || 'Nessuna';

  // üî• ricalcola subito la potenza eroe
  if (typeof updateHeroPowerUI === 'function') {
    updateHeroPowerUI();
  }

  // opzionale: aggiorna Sala degli Eroi
  try {
    if (typeof upsertCurrentHeroIntoDirectory === 'function') {
      upsertCurrentHeroIntoDirectory();
    }
  } catch (_) {}

  closeArmorSelect();
}

function unequipArmor() {
  // rimuovi armatura equipaggiata
  if (window.clearEquippedArmor) {
    window.clearEquippedArmor();
  }

  // aggiorna etichetta nel profilo
  const el = document.getElementById('equipped-armor');
  if (el) el.textContent = 'Nessuna';

  // üî• ricalcola subito la potenza eroe
  if (typeof updateHeroPowerUI === 'function') {
    updateHeroPowerUI();
  }

  // opzionale: aggiorna Sala degli Eroi
  try {
    if (typeof upsertCurrentHeroIntoDirectory === 'function') {
      upsertCurrentHeroIntoDirectory();
    }
  } catch (_) {}

  closeArmorSelect();
}

// -- Bind espliciti per gli handler inline dall'inventario ---
window.openFromInventory   = openFromInventory;
window.showWeaponDetails   = showWeaponDetails;
window.showMagicDetails    = showMagicDetails;
window.showArmorDetails    = showArmorDetails;
window.showCreatureDetails = showCreatureDetails;


// === CRISTALLI (Pagina) =====================================================

// Mostra la pagina (come le altre schermate principali)
function showCrystalsScreen() {
  // chiudi eventuali popup aperti dei cristalli (safe no-op se non aperti)
  closeCrystals?.();

  // nascondi il menu e mostra la pagina
  document.getElementById('menu')?.classList.add('hidden');
  document.getElementById('crystals-screen')?.classList.remove('hidden');

  renderCrystalsScreen();
}

// === Navigazione pagina Fusione Cristalli ===
function showFuseCrystalsScreen(){
  // se arrivo dal popup, chiudilo
  try { closeCrystals(); } catch(_){}
  // nascondi la pagina cristalli e mostra la pagina fusione
  document.getElementById('crystals-screen')?.classList.add('hidden');
  document.getElementById('crystal-fuse-screen')?.classList.remove('hidden');
  renderFuseCrystalsScreen();
}

function backFromFuseCrystalsScreen(){
  document.getElementById('crystal-fuse-screen')?.classList.add('hidden');
  document.getElementById('crystals-screen')?.classList.remove('hidden');
  // ridisegna la pagina cristalli per aggiornare i conteggi
  try { renderCrystalsScreen(); } catch(_){}
}

// Disegna la pagina con selettore quantit√† e costo
function renderFuseCrystalsScreen(){
  const body = document.getElementById('crystal-fuse-body');
  if (!body) return;

  const parts   = getNum('crystalParts', 0);
  const canMake = Math.floor(parts / 3);
  const gold    = getNum('gold', 0);

  if (canMake <= 0){
    body.innerHTML = `
      <div class="traits-block">
        <div class="title">Fusione non disponibile</div>
        <div class="muted">Non hai abbastanza frammenti per fondere un cristallo.</div>
      </div>
    `;
    return;
  }

  // Se puoi farne solo 1, permetti comunque la conferma diretta (manteniamo comportamento richiesto)
  const minQty = 1;
  const maxQty = canMake;

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Seleziona quantit√†</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div><strong>Frammenti:</strong> ${parts}/3</div>
        <div>
          <label>Quanti cristalli fondere</label><br>
          <input id="fuse-qty" type="number" min="${minQty}" max="${maxQty}" step="1" value="${Math.min(1, maxQty)}" style="width:160px">
          <div class="muted">Disponibili: ${maxQty}</div>
        </div>
        <div id="fuse-cost-line"><strong>Costo:</strong> ${formatGold(CRYSTAL_FUSE_COST)} oro</div>
        <div class="muted">Il costo √® di ${formatGold(CRYSTAL_FUSE_COST)} oro per ${maxQty>1?'cristallo':'cristallo'} fuso.</div>
      </div>
    </div>

    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button class="magic-button" id="do-fuse-btn">Fondi</button>
    </div>
  `;

  const qtyEl  = document.getElementById('fuse-qty');
  const costEl = document.getElementById('fuse-cost-line');
  const doBtn  = document.getElementById('do-fuse-btn');

  function refreshCost(){
    const q = Math.max(minQty, Math.min(maxQty, Number(qtyEl.value || 1)));
    const cost = q * CRYSTAL_FUSE_COST;
    if (costEl) costEl.innerHTML = `<strong>Costo:</strong> ${formatGold(cost)} oro`;
    // disabilita se oro insufficiente
    const enough = gold >= cost;
    doBtn.disabled = !enough;
    doBtn.title = enough ? '' : 'Oro insufficiente';
  }
  qtyEl.addEventListener('input', refreshCost);
  refreshCost();

  doBtn.addEventListener('click', () => {
    const q = Math.max(minQty, Math.min(maxQty, Number(qtyEl.value || 1)));
    const totalCost = q * CRYSTAL_FUSE_COST;
    const myGold = getNum('gold', 0);
    if (myGold < totalCost){
      showGameMessage('Oro insufficiente', `Ti mancano <strong>${formatGold(totalCost - myGold)}</strong> monete d'oro.`);
      return;
    }

    // Conferma (riusiamo il dialogo ‚Äúattuale‚Äù usato altrove)
    showConfirmDialog({
      title: 'Conferma fusione',
      text: `Vuoi fondere <strong>${q}</strong> ${q>1?'cristalli':'cristallo'} al costo totale di <strong>${formatGold(totalCost)}</strong> monete d'oro?`,
      okText: 'S√¨, fondi',
      cancelText: 'No',
      onConfirm: () => applyCrystalFusion(q)
    });
  });
}

// Applica fusione: scala parti, oro, aggiunge cristalli, aggiorna UI e messaggi
function applyCrystalFusion(qty){
  const parts      = getNum('crystalParts', 0);
  const canMake    = Math.floor(parts / 3);
  const q          = Math.max(1, Math.min(Number(qty)||1, canMake));
  const totalCost  = q * CRYSTAL_FUSE_COST;

  if (q <= 0){
    showGameMessage('Fusione', 'Non hai abbastanza frammenti di Cristallo di Potenziamento.');
    return;
  }

  // oro sufficiente?
  const gold = getNum('gold', 0);
  if (gold < totalCost){
    showGameMessage('Oro insufficiente', `Ti mancano <strong>${formatGold(totalCost - gold)}</strong> monete d'oro.`);
    return;
  }

  // Applica
  addNum('gold', -totalCost);
  addNum('crystalParts', -(q * 3));
  addNum('crystals', q);
  updateGoldBadges?.();

  showGameMessage('Fusione riuscita', `Complimenti, hai ottenuto <strong>${q}</strong> ${q>1?'cristalli':'cristallo'} di potenziamento!`);

  // Refresh UI
  try { renderCrystalsPopup(); } catch(_){}
  try { renderCrystalsScreen(); } catch(_){}
  try { renderFuseCrystalsScreen(); } catch(_){}

  // se vuoi, qui puoi incrementare una eventuale quest di fusione:
  // incrementQuest?.('q_weekly_fuse_crystal', q);
}

function goToMainMenu() {
  // Nascondi eventuali schermate cristalli aperte
  document.getElementById('crystal-spend-screen')?.classList.add('hidden');
  document.getElementById('crystals-screen')?.classList.add('hidden');
  document.getElementById('crystal-reset-screen')?.classList.add('hidden');
  document.getElementById('crystal-reset-overlay')?.classList.add('hidden');
  document.getElementById('crystal-reset-modal')?.classList.add('hidden');

  // Chiudi eventuali popup cristalli (no-op se non esistono)
  try { closeCrystals(); } catch (e) {}

  // Se la schermata Gilda √® aperta, chiudila
  document.getElementById('guild-screen')?.classList.add('hidden');

  // Mostra il men√π principale
  document.getElementById('menu')?.classList.remove('hidden');

  // üî¥ Gilda: genera/aggiorna l‚Äôofferta segreta e i pallini subito al ritorno al menu
  if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
  if (typeof updateGuildBadges === 'function') updateGuildBadges();

  // (opzionale ma consigliato) riallinea anche il badge messaggi
  if (typeof updateMessageBadge === 'function') updateMessageBadge();
}
window.goToMainMenu = goToMainMenu;


// === GILDA (Schermate & UI) ==================================================

// Fallback per conferme se non hai una modale custom
function askConfirm({ title, text, okText='Conferma', cancelText='Annulla', onConfirm }){
  if (typeof showConfirmDialog === 'function') {
    showConfirmDialog({ title, text, okText, cancelText, onConfirm });
  } else {
    const t = text.replace(/<[^>]+>/g,'');
    if (confirm(t)) onConfirm && onConfirm();
  }
}

// Mostra pagina Gilda (se gi√† in gilda ‚Üí "La mia Gilda")
function showGuildScreen(){
  if (typeof ensureGuildStores === 'function') ensureGuildStores();
  if (typeof ensureGuildDiplomacyStore === 'function') ensureGuildDiplomacyStore();
  if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
  if (typeof updateGuildBadges === 'function') updateGuildBadges();

  const menu = document.getElementById('menu');
  if (menu) menu.classList.add('hidden');
  const page = document.getElementById('guild-screen');
  if (page) page.classList.remove('hidden');

  let gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;

  // Se ho un gid salvato ma non sono (pi√π) tra i membri ‚Üí pulisci e mostra l'hub
  if (gid) {
    const me = (typeof currentUser === 'string' && currentUser) ? currentUser : null;
    const members = (typeof getGuildMembers === 'function') ? getGuildMembers(gid) : [];
    const amIMember = !!(me && members.find(m => m.user === me));
    if (!amIMember) {
      if (typeof setUserGuildId === 'function') setUserGuildId(null);
      gid = null;
    }
  }

  if (gid) renderMyGuild();
  else renderGuildHub();
}

// Torna al menu principale
function backFromGuildScreen() {
  const gs = document.getElementById('guild-screen');
  if (gs) gs.classList.add('hidden');

  const menu = document.getElementById('menu');
  if (menu) menu.classList.remove('hidden');

  // Aggiorna subito l'offerta segreta e i badge della Gilda
  if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
  if (typeof updateGuildBadges === 'function') updateGuildBadges();

  // Badge dei messaggi (lasciato com'era)
  if (typeof updateMessageBadge === 'function') updateMessageBadge();
}

// ===== Pannello "Oggetto segreto" (Gilda) =====
// helper: trova nel catalogo l'item completo (descrizione/caratteristiche) a partire da nome+categoria
function findCatalogDefByName(categorySingular, name){
  const map = { weapon:'weapons', armor:'armors', magic:'magics', creature:'creatures' };
  const catKey = map[categorySingular];
  if (!catKey || typeof getAllDefs !== 'function') return null;
  const list = getAllDefs(catKey) || [];
  return list.find(it => it && it.name === name) || null;
}

// crea il contenitore una sola volta, dentro la schermata Gilda

// ===== Finestra "Oggetto segreto" (stile edifici, non popup) =====
function openGuildSecretWindow(){
  try { setGuildSpecialSeen?.(); } catch(e) {}
  try { updateGuildBadges?.(); } catch(e) {}

  const root = document.getElementById('guild-screen-body');
  if (!root) return;

  const s = (typeof getGuildSpecial === 'function') ? getGuildSpecial() : null;
  if (!s || !s.item) {
    root.innerHTML = `
      <div class="traits-block">
        <div class="title">Oggetto segreto</div>
        <p>Nessuna offerta segreta attiva.</p>
        <div class="back-button-container">
          <button class="mini-button mini-button--dark" id="gsw-back">‚Üê Indietro</button>
        </div>
      </div>`;
    document.getElementById('gsw-back')?.addEventListener('click', ()=> renderGuildShopWindowOrBack());
    return;
  }

  const spec = s.item;
  const catLabelMap = { weapon:'Armi', armor:'Armature', magic:'Magie', creature:'Creature' };
  const catLabel = catLabelMap[spec.category] || 'Oggetti';

  const def  = findCatalogDefByName(spec.category, spec.name) || {};
  const description = def.description || def.desc || '';
  const traitsObj   = (def.traits && typeof def.traits === 'object') ? def.traits : null;

  let traitsHtml = '';
  if (traitsObj) {
    const rows = Object.entries(traitsObj)
      .map(([k,v]) => `<div><strong>${k}:</strong> ${v}</div>`)
      .join('');
    traitsHtml = `
      <div class="traits-block" style="margin-top:8px; text-align:left;">
        <div class="title" style="font-weight:700; margin-bottom:4px;">Caratteristiche</div>
        <div class="traits-grid" style="display:block;">${rows}</div>
      </div>`;
  }

  const imgSrc = getGuildSecretImageSrc(spec);
  const baseForAlt = spec.name;

  // --- Fallback immagini (fix: creature nel negozio segreto) ---
  const safeName = encodeURIComponent(String(baseForAlt || '').trim());

  // classe: se vuoi puoi aggiungere in CSS un bordo diverso per creature, ma non √® obbligatorio
  const imgClass = (spec.category === 'creature')
    ? 'weapon-thumb creature-thumb--frame'
    : 'weapon-thumb';

  // onerror: per creature prova pi√π varianti (case/estensione), per gli altri prova jpg
  let imgOnError = 'this.onerror=null;';
  if (spec.category === 'creature') {
    // catena:
    // 1) prova Creatures/<name>.png (gi√† nel src principale se la tua helper lo produce)
    // 2) se fallisce -> creatures/<name>.png (case diverso)
    // 3) se fallisce -> Creatures/<name>.jpg
    imgOnError = `
      this.onerror=function(){
        this.onerror=function(){ this.onerror=null; this.src='Creatures/${safeName}.jpg'; };
        this.src='creatures/${safeName}.png';
      };
      this.src='Creatures/${safeName}.png';
    `.trim();
  } else if (spec.category === 'weapon') {
    imgOnError = `this.onerror=null; this.src='weapons/${safeName}.jpg';`;
  } else if (spec.category === 'armor') {
    imgOnError = `this.onerror=null; this.src='armors/${safeName}.jpg';`;
  } else if (spec.category === 'magic') {
    imgOnError = `this.onerror=null; this.src='magics/${safeName}.jpg';`;
  }

  root.innerHTML = `
    <div class="traits-block">
      <div class="title">Oggetto segreto</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="gsw-back">‚Üê Indietro</button>
      </div>

      <!-- Titolo oggetto centrato -->
      <h3 style="margin:0 0 6px 0; text-align:center;">${spec.name}</h3>

      <!-- Categoria centrata, nera e in grassetto -->
      <div style="text-align:center; font-size:0.95rem; margin:0 0 8px 0; font-weight:700; color:#000;">
        Categoria: ${catLabel}
      </div>

      ${imgSrc ? `
        <img class="${imgClass}"
             src="${imgSrc}"
             alt="${baseForAlt}"
             onerror="${imgOnError}">
      ` : ''}

      ${description ? `<p style="margin:6px 0; text-align:left;">${description}</p>` : ''}

      ${traitsHtml}

      <div style="margin-top:8px; text-align:left;">
        <strong>Prezzo:</strong> ${typeof formatGold==='function' ? formatGold(Number(spec.price||0)) : (spec.price||0)} monete d'oro
      </div>

      <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;">
        <button class="magic-button" id="gsw-buy" ${s.bought ? 'disabled':''}>
          ${s.bought ? 'Gi√† acquistato' : 'Acquista'}
        </button>
        <button class="magic-button" id="gsw-cancel">Annulla</button>
      </div>
    </div>
  `;

  document.getElementById('gsw-back')?.addEventListener('click', ()=> renderGuildShopWindowOrBack());
  document.getElementById('gsw-cancel')?.addEventListener('click', ()=> renderGuildShopWindowOrBack());

  const buyBtn = document.getElementById('gsw-buy');
  if (buyBtn && !s.bought) {
    buyBtn.onclick = () => {
      try { buyGuildSpecialItem(); } catch(e) {}
      openGuildSecretWindow();
      try { updateGuildBadges?.(); } catch(e) {}
      try { updateGoldBadges?.(); } catch(e) {}
    };
  }
}




// Torna al negozio Gilda se aperto, altrimenti alla schermata Gilda
function renderGuildShopWindowOrBack(){
  // se la finestra negozio √® quella standard, ricaricala; altrimenti torna alla gilda
  if (typeof openGuildShopWindow === 'function') {
    try { openGuildShopWindow(); return; } catch(e){}
  }
  if (typeof renderMyGuild === 'function') renderMyGuild();
}


// HUB: descrizione + Crea / Lista
function renderGuildHub(){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Cos‚Äô√® una Gilda</div>
      <div style="text-align:left">
        <p>Una <strong>Gilda</strong> √® una compagnia di eroi uniti dallo stesso vessillo. √à il luogo dove nascono amicizie, si condividono strategie e si costruisce un‚Äôidentit√† comune. Un nome, un simbolo, una storia da scrivere insieme.</p>
        <p>Puoi <strong>crearne una</strong> oppure cercarne una nella <strong>Lista Gilde</strong> e unirti a quella che ti rappresenta di pi√π.</p>
      </div>
    </div>

    <div class="traits-block">
      <div class="guild-actions-grid">
        <button class="magic-button" id="guild-create-btn">Crea Gilda</button>
        <button class="magic-button" id="guild-list-btn">Lista Gilde</button>
      </div>
    </div>
  `;

  const b1 = document.getElementById('guild-create-btn');
  if (b1) b1.addEventListener('click', renderGuildCreate);
  const b2 = document.getElementById('guild-list-btn');
  if (b2) b2.addEventListener('click', ()=>renderGuildList({page:1,q:''}));
}

// === Creazione Gilda ==========================================================
const GUILD_CREATE_COST = 10000;
const GUILD_MEMBER_LIMIT = 60;

function renderGuildCreate(){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const goldNow = getNum('gold', 0);

  // default banner config (ora con forma)
const cfg = { base:'#7b3b2a', emblem:'#f5d565', symbol:'cerchio', shape:'rettangolo' };

  body.innerHTML = `
    <p style="margin-bottom:8px;">
      <button class="mini-button mini-button--dark" id="g-back1">‚Üê Indietro</button>
      &nbsp;&nbsp;<strong>Oro disponibile:</strong> ${formatGold(goldNow)} monete d'oro
      <br><span class="muted"><strong>Costo creazione:</strong> ${formatGold(GUILD_CREATE_COST)} monete d'oro</span>
    </p>

    <div class="traits-block">
      <div class="title">Crea Gilda</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <label>Nome <input id="g-new-name" class="guild-input" placeholder="Nome della gilda">
        <label>Tag <input id="g-new-tag" class="guild-input" maxlength="4" placeholder="TAG">
        <label>Descrizione (opzionale) <textarea id="g-desc" rows="3" style="width:100%"></textarea></label>
        <label>Privacy
          <select id="g-privacy" style="width:180px">
            <option value="open">Aperta</option>
            <option value="invite">Su invito</option>
          </select>
        </label>
      </div>
    </div>

    <div class="traits-block">
  <div class="title">Stendardo</div>
  <div class="traits-grid" style="grid-template-columns:1fr;">
    <!-- Anteprima centrata -->
    <div style="display:flex; justify-content:center;">
      <div class="guild-banner" id="g-banner-preview"></div>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px;">
      <label>Colore base <input type="color" id="g-base" value="${cfg.base}"></label>
      <label>Colore simbolo <input type="color" id="g-emblem" value="${cfg.emblem}"></label>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px;">
      <label>Forma
        <select id="g-shape" style="width:200px">
          <option value="rettangolo">Rettangolo</option>
          <option value="stendardo">Stendardo</option>
          <option value="coda">Coda di rondine</option>
          <option value="scudo">Scudo</option>
          <option value="scudetto">Scudetto</option>
          <option value="cerchio">Cerchio</option>
          <option value="ovale">Ovale</option>
          <option value="esagono">Esagono</option>
          <option value="ottagono">Ottagono</option>
          <option value="losanga">Losanga</option>
          <option value="goccia">Goccia</option>
        </select>
      </label>

      <label>Simbolo
        <select id="g-symbol" style="width:200px">
          <option value="cerchio">Cerchio</option>
          <option value="stella">Stella</option>
          <option value="diamante">Diamante</option>
          <option value="spade">Spade incrociate</option>
          <option value="teschio">Teschio</option>
          <option value="triangolo">Triangolo</option>
          <option value="scudo">Scudo</option>
          <option value="aquila">Aquila</option>
          <option value="sole">Sole</option>
          <option value="luna">Luna</option>
          <option value="torre">Torre</option>
          <option value="corona">Corona</option>
        </select>
      </label>
    </div>
  </div>
</div>


    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="g-create-do" class="magic-button">Conferma creazione</button>
    </div>
  `;

  const back = document.getElementById('g-back1');
  if (back) back.onclick = renderGuildHub;

 // live preview
const preview = document.getElementById('g-banner-preview');
function repaint(){
  cfg.base   = document.getElementById('g-base').value;
  cfg.emblem = document.getElementById('g-emblem').value;
  cfg.symbol = document.getElementById('g-symbol').value;
  cfg.shape  = document.getElementById('g-shape').value;
  if (preview) preview.innerHTML = bannerSVG(cfg);
}
repaint();
document.getElementById('g-base').oninput   =
document.getElementById('g-emblem').oninput =
document.getElementById('g-symbol').onchange =
document.getElementById('g-shape').onchange = repaint;


  // crea
  const goBtn = document.getElementById('g-create-do');
  if (goBtn) goBtn.onclick = ()=>{
    const name = String(document.getElementById('g-new-name').value||'').trim();
    const tag  = String(document.getElementById('g-new-tag').value||'').trim().toUpperCase();
    const desc = String(document.getElementById('g-desc').value||'').trim();
    const privacy = document.getElementById('g-privacy').value === 'invite' ? 'invite' : 'open';

    // validazioni (restano attive anche se non le mostriamo in etichetta)
    if (name.length < 3 || name.length > 20){ alert('Il nome deve avere 3‚Äì20 caratteri.'); return; }
    if (tag.length < 2 || tag.length > 4){ alert('Il tag deve avere 2‚Äì4 lettere.'); return; }
    if (typeof findGuildByName === 'function' && findGuildByName(name)){ alert('Esiste gi√† una gilda con questo nome.'); return; }
    if (typeof findGuildByTag === 'function' && findGuildByTag(tag)){ alert('Esiste gi√† una gilda con questo TAG.'); return; }

    // oro
    const gold = getNum('gold',0);
    if (gold < GUILD_CREATE_COST){ alert('Oro insufficiente.'); return; }

    // utente loggato
    const owner = (typeof currentUser === 'string' && currentUser) ? currentUser : null;
    if (!owner){ alert('Devi essere loggato.'); return; }

    // crea record globale
    if (typeof createGuildRecord !== 'function'){ alert('Storage gilde non inizializzato.'); return; }
    const res = createGuildRecord({ name, tag, desc, privacy, banner:cfg, owner });
    if (!res || !res.ok){ alert((res && res.error) || 'Errore creazione gilda.'); return; }

    // scala oro, set membership
    addNum('gold', -GUILD_CREATE_COST);
    if (typeof updateGoldBadges === 'function') updateGoldBadges();
    if (typeof setUserGuildId === 'function') setUserGuildId(res.id);
    if (typeof setUserGuildId === 'function') setUserGuildId(res.id);

    if (typeof showGameMessage === 'function') {
      showGameMessage('Gilda creata', `Hai fondato la gilda <strong>${name} [${tag}]</strong>.`);
    }
    renderMyGuild();
  };
}

function renderGuildEdit(gid){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  if (!g){ renderMyGuild(); return; }

  // Solo il Capogilda pu√≤ modificare
  const me = (typeof currentUser==='string' && currentUser) ? currentUser : null;
  if (!me || g.owner !== me){
    if (typeof showGameMessage === 'function') showGameMessage('Operazione non consentita','Solo il Capogilda pu√≤ modificare la gilda.');
    renderMyGuild();
    return;
  }

  // Config stendardo precompilata (fallback sicuri)
  const cfg = Object.assign(
    { base:'#7b3b2a', emblem:'#f5d565', symbol:'cerchio', shape:'rettangolo' },
    g.banner || {}
  );

  body.innerHTML = `
    <p style="margin-bottom:8px;">
      <button class="mini-button mini-button--dark" id="g-back-edit">‚Üê Indietro</button>
    </p>

    <div class="traits-block">
      <div class="title">Modifica Gilda</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <label>Nome <input id="g-new-name" class="guild-input" placeholder="Nome della gilda"></label>
        <label>Tag <input id="g-new-tag" class="guild-input" maxlength="4" placeholder="TAG"></label>
        <label>Descrizione (opzionale) <textarea id="g-desc" rows="3" style="width:100%"></textarea></label>
        <label>Privacy
          <select id="g-privacy" style="width:180px">
            <option value="open">Aperta</option>
            <option value="invite">Su invito</option>
          </select>
        </label>
      </div>
    </div>

    <div class="traits-block">
      <div class="title">Stendardo</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div style="display:flex; justify-content:center;">
          <div class="guild-banner" id="g-banner-preview"></div>
        </div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px;">
          <label>Colore base <input type="color" id="g-base"></label>
          <label>Colore simbolo <input type="color" id="g-emblem"></label>
        </div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px;">
          <label>Forma
            <select id="g-shape" style="width:200px">
              <option value="rettangolo">Rettangolo</option>
              <option value="stendardo">Stendardo</option>
              <option value="coda">Coda di rondine</option>
              <option value="triangolo">Triangolo</option>
              <option value="cerchio">Cerchio</option>
              <option value="ovale">Ovale</option>
              <option value="losanga">Losanga</option>
              <option value="goccia">Goccia</option>
            </select>
          </label>

          <label>Simbolo
            <select id="g-symbol" style="width:200px">
              <option value="cerchio">Cerchio</option>
              <option value="stella">Stella</option>
              <option value="diamante">Diamante</option>
              <option value="spade">Spade incrociate</option>
              <option value="teschio">Teschio</option>
              <option value="triangolo">Triangolo</option>
              <option value="scudo">Scudo</option>
              <option value="aquila">Aquila</option>
              <option value="sole">Sole</option>
              <option value="luna">Luna</option>
              <option value="torre">Torre</option>
              <option value="corona">Corona</option>
            </select>
          </label>
        </div>
      </div>
    </div>

    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="g-edit-save" class="magic-button">Salva modifiche</button>
    </div>
  `;

  // Back
  document.getElementById('g-back-edit')?.addEventListener('click', renderMyGuild);

  // Precompila campi
  const nameEl = document.getElementById('g-new-name');
  const tagEl  = document.getElementById('g-new-tag');
  const descEl = document.getElementById('g-desc');
  const privEl = document.getElementById('g-privacy');

  if (nameEl) nameEl.value = g.name || '';
  if (tagEl)  tagEl.value  = g.tag  || '';
  if (descEl) descEl.value = g.desc || '';
  if (privEl) privEl.value = (g.privacy === 'invite') ? 'invite' : 'open';

  // Preview + binding come in "Crea Gilda"
  const preview = document.getElementById('g-banner-preview');
  const repaint = ()=>{
    cfg.base   = document.getElementById('g-base').value;
    cfg.emblem = document.getElementById('g-emblem').value;
    cfg.symbol = document.getElementById('g-symbol').value;
    cfg.shape  = document.getElementById('g-shape').value;
    if (preview) preview.innerHTML = bannerSVG(cfg); // stessa funzione usata nella creazione
  };

  document.getElementById('g-base').value   = cfg.base;
  document.getElementById('g-emblem').value = cfg.emblem;
  document.getElementById('g-symbol').value = cfg.symbol;
  document.getElementById('g-shape').value  = cfg.shape;
  ['g-base','g-emblem','g-symbol','g-shape'].forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    const ev = (id==='g-symbol' || id==='g-shape') ? 'change' : 'input';
    el.addEventListener(ev, repaint);
  });
  repaint();

  // Salva modifiche
  const saveBtn = document.getElementById('g-edit-save');
  if (saveBtn) saveBtn.onclick = ()=>{
    const newName = String(nameEl.value||'').trim();
    const newTag  = String(tagEl.value||'').trim().toUpperCase();
    const newDesc = String(descEl.value||'').trim();
    const newPriv = (privEl.value === 'invite') ? 'invite' : 'open';

    // Validazioni (come create, ma consentendo stesso nome/tag della gilda corrente)
    if (newName.length < 3 || newName.length > 20){ alert('Il nome deve avere 3‚Äì20 caratteri.'); return; }
    if (newTag.length  < 2 || newTag.length  > 4 ){ alert('Il tag deve avere 2‚Äì4 lettere.'); return; }

    const byName = (typeof findGuildByName==='function') ? findGuildByName(newName) : null;
    if (byName && byName.id !== gid){ alert('Esiste gi√† una gilda con questo nome.'); return; }

    const byTag = (typeof findGuildByTag==='function') ? findGuildByTag(newTag) : null;
    if (byTag && byTag.id !== gid){ alert('Esiste gi√† una gilda con questo TAG.'); return; }

    // Aggiorna record
    const all = (typeof getGuilds==='function') ? getGuilds() : {};
    const curr = all[gid] || {};
    all[gid] = Object.assign({}, curr, {
      name: newName,
      tag: newTag,
      desc: newDesc,
      privacy: newPriv,
      banner: cfg
    });
    if (typeof setGuilds==='function') setGuilds(all); // get/set sono gi√† esposte dallo storage
    if (typeof showGameMessage==='function') showGameMessage('Gilda aggiornata', `Hai aggiornato <strong>${newName} [${newTag}]</strong>.`);
    renderMyGuild();
  };
}

function renderGuildBuildings(gid){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  if (!g){ renderMyGuild(); return; }

  const me = (typeof currentUser==='string' && currentUser) ? currentUser : null;
  const isLeader = (me && g.owner === me);

    // Definizione elenco edifici (ora 3)
const defs = [
  {
    key: 'hall_of_legends',
    name: 'Sala delle Leggende',
    descShort: 'Aumenta l‚ÄôEXP eroe ottenuta.',
    icon: 'üó°Ô∏è'
  },
  {
    key: 'beast_sanctum',
    name: 'Santuario delle Bestie',
    descShort: 'Aumenta l‚ÄôEXP  creatura ottenuta.',
    icon: 'üêæ'
  },
  {
    key: 'guild_treasury',
    name: 'Tesoreria della Gilda',
    descShort: 'Aumenta l‚Äôoro guadagnato dalle attivit√†.',
    icon: 'üí∞'
  },
  {
  key: 'library_of_knowledge',
  name: 'Biblioteca del Sapere',
  descShort: 'Riduce il tempo di ricarica delle missioni.',
  icon: 'üìú'
},
{
  key: 'blessing_altar',
  name: 'Altare delle Benedizioni',
  descShort: 'Aumenta la fortuna: frammenti di cristallo dalle missioni.',
  icon: 'üèõÔ∏è'
}
];

  const itemsHTML = defs.map(d=>{
  const lvl = (typeof getGuildBuildingLevel==='function') ? getGuildBuildingLevel(gid, d.key) : 0;

  // Testo stato sempre tra parentesi:
  // - (Non costruito) se lvl = 0
  // - (Livello X)     se lvl > 0
  const statusText = (lvl > 0) ? `(Livello ${lvl})` : `(Non costruito)`;

  return `
    <button class="magic-button" data-bld="${d.key}" style="justify-content:space-between;">
      <span>${d.icon?`${d.icon} `:''}${d.name}</span>
      <span class="muted">${statusText}</span>
    </button>
  `;
}).join('');

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Edifici</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="g-bld-back">‚Üê Indietro</button>
      </div>
      <div class="traits-grid" style="grid-template-columns:1fr; gap:10px;">
        ${itemsHTML || `<div class="muted">Nessun edificio disponibile.</div>`}
      </div>
    </div>
  `;

  document.getElementById('g-bld-back')?.addEventListener('click', renderMyGuild);

  body.querySelectorAll('[data-bld]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const key = btn.getAttribute('data-bld');
      renderGuildBuildingDetail(gid, key);
    });
  });
}
function renderGuildBuildingDetail(gid, key){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  if (!g){ renderMyGuild(); return; }

  const me = (typeof currentUser==='string' && currentUser) ? currentUser : null;
  const isLeader = (me && g.owner === me);

  // === definizione edifici supportati ===
  const DEF = {
    hall_of_legends: {
      name: 'Sala delle Leggende',
      type: 'hero_pct',   // bonus % su XP eroe
      perLevel: 4,
      costs: {1:100000,2:200000,3:300000,4:400000,5:500000},
      description: [
        'Un vasto salone in cui i trionfi vengono narrati e tramandati.',
        'Qui gli eroi studiano le gesta dei grandi e imparano dai loro passi.',
        'Ogni nuova ala del salone ispira il coraggio e affina la disciplina.',
        'Pi√π la Sala cresce, pi√π l‚Äôesperienza guadagnata nelle imprese aumenta.'
      ]
    },
    beast_sanctum: {
      name: 'Santuario delle Bestie',
      type: 'creature_flat', // bonus flat su XP creatura
      perLevel: 1,
      costs: {1:100000,2:200000,3:300000,4:400000,5:500000},
      description: [
        'Un luogo sacro dove le creature stringono patti antichi con i Custodi.',
        'Tra pietre runiche e incensi, lo spirito si affina e la crescita accelera.',
        'Ogni ampliamento del Santuario attira guide spirituali pi√π potenti.',
        'Le creature al tuo fianco maturano pi√π esperienza dalle attivit√†.'
      ]
    },
    guild_treasury: {
      name: 'Tesoreria della Gilda',
      type: 'gold_pct',       // bonus % su oro guadagnato
      perLevel: 5,            // +5% per livello
      costs: {1:100000,2:200000,3:300000,4:400000,5:500000},
      description: [
        'Un caveau protetto dove il tesoriere custodisce le ricchezze della gilda.',
        'Bilanci accurati e rotte mercantili fanno fruttare ogni impresa.',
        'Ogni ampliamento ottimizza riscossioni, baratti e tributi.',
        'Cos√¨ l‚Äôoro ottenuto dalle attivit√† cresce sensibilmente per tutti.'
      ]
    },
    library_of_knowledge: {
  name: 'Biblioteca del Sapere',
  type: 'mission_cd',     // riduzione cooldown missioni (minuti)
  perLevel: 30,           // -30 minuti per livello
  costs: {1:100000,2:200000,3:300000,4:400000,5:500000},
  description: [
    'Un grande scriptorium dove si studiano rotte, tempi e strategie.',
    'Bibliotecari e cartografi ottimizzano i percorsi degli incarichi.',
    'Nuove ali della biblioteca riducono le attese tra una missione e l‚Äôaltra.',
    'Membri informati completano pi√π incarichi in meno tempo.'
  ]
},
blessing_altar: {
  name: 'Altare delle Benedizioni',
  type: 'crystal_frag',    // bonus fortuna frammenti missione
  perLevel: 3,             // +3% per livello (applicato con p = base + (1-base)*bonus)
  costs: {1:100000,2:200000,3:300000,4:400000,5:500000},
  description: [
    'Un altare solenne in cui i membri invocano la benevolenza degli Spiriti.',
    'Le preghiere guidano il fato, rendendo pi√π propizi gli esiti delle imprese.',
    'Ogni consacrazione dell‚Äôaltare accresce la fortuna della gilda.',
    'I frammenti di cristallo di potenziamento sembrano farsi trovare pi√π spesso‚Ä¶'
  ]
}

  }[key];

  if (!DEF){ renderGuildBuildings(gid); return; }

  const lvl = (typeof getGuildBuildingLevel==='function') ? getGuildBuildingLevel(gid, key) : 0;
  const maxLvl = 5;
  const nextLvl = Math.min(maxLvl, lvl+1);
  const canUpgrade = isLeader && lvl < maxLvl;

  // beneficio corrente / prossimo
  let currBenefitText = '';
let nextBenefitText = '';
if (DEF.type === 'hero_pct'){
  currBenefitText = `+${lvl*DEF.perLevel}% EXP eroe dalle attivit√†`;
  nextBenefitText = `+${nextLvl*DEF.perLevel}% EXP eroe dalle attivit√†`;
} else if (DEF.type === 'creature_flat') {
  currBenefitText = `+${lvl*DEF.perLevel} XP creatura dalle attivit√†`;
  nextBenefitText = `+${nextLvl*DEF.perLevel} XP creatura dalle attivit√†`;
} else if (DEF.type === 'gold_pct') {
  currBenefitText = `+${lvl*DEF.perLevel}% oro guadagnato`;
  nextBenefitText = `+${nextLvl*DEF.perLevel}% oro guadagnato`;
} else if (DEF.type === 'mission_cd') {
  currBenefitText = `-${lvl*DEF.perLevel} min al cooldown missioni`;
  nextBenefitText = `-${nextLvl*DEF.perLevel} min al cooldown missioni`;
} else if (DEF.type === 'crystal_frag') {
  currBenefitText = `+${lvl*DEF.perLevel}% fortuna frammenti di cristallo`;
  nextBenefitText = `+${nextLvl*DEF.perLevel}% fortuna frammenti di cristallo`;
}

  const costNext = DEF.costs[nextLvl] || 0;
  const gGold = (typeof getGuildGold==='function') ? getGuildGold(gid) : (Number(g.gold)||0);

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">${DEF.name}</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="g-bld-back2">‚Üê Indietro</button>
      </div>

      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div><strong>Livello:</strong> ${lvl} / ${maxLvl}</div>
        <div style="white-space:pre-line; margin-top:6px; text-align:left;">${DEF.description.join('\n')}</div>

        <div style="margin-top:8px; display:inline-flex; align-items:center; gap:6px; white-space:nowrap; text-align:left; justify-content:flex-start;">
          <button id="g-bld-benefits"
                  type="button"
                  style="background:none;border:none;padding:0;cursor:pointer;text-decoration:underline;font-weight:700;color:#000;">
            Benefici
          </button>
          <span>: ${currBenefitText}</span>
        </div>

        ${canUpgrade ? `
          <div class="traits-sep"></div>
          <div><strong>Costo per livello ${nextLvl}:</strong> ${formatGold(costNext)} oro gilda</div>
          <div class="muted">Saldo gilda: ${formatGold(gGold)}</div>
          <div style="margin-top:6px;">
            <button class="magic-button" id="g-bld-up">Potenzia a livello ${nextLvl}</button>
          </div>
        ` : `
          <div class="traits-sep"></div>
          <div class="muted">${lvl>=maxLvl ? 'Edificio al livello massimo.' : 'Solo il Capogilda pu√≤ potenziare gli edifici.'}</div>
        `}
      </div>
    </div>
  `;

  document.getElementById('g-bld-back2')
    ?.addEventListener('click', ()=>renderGuildBuildings(gid));
  document.getElementById('g-bld-benefits')
    ?.addEventListener('click', ()=>renderGuildBuildingBenefits(gid, key));

  if (canUpgrade){
    document.getElementById('g-bld-up')?.addEventListener('click', ()=>{
      const nowGold = (typeof getGuildGold==='function') ? getGuildGold(gid) : 0;
      if (nowGold < costNext){
        if (typeof showGameMessage==='function'){
          showGameMessage(
            'Oro gilda insufficiente',
            `Ti servono ${formatGold(costNext)} monete d'oro di gilda per il livello successivo.
             Saldo attuale: ${formatGold(nowGold)}.`
          );
        } else {
          alert('Oro gilda insufficiente.');
        }
        return;
      }
      if (typeof addGuildGold==='function') addGuildGold(gid, -costNext);
      if (typeof setGuildBuildingLevel==='function') setGuildBuildingLevel(gid, key, nextLvl);

      if (typeof showGameMessage==='function'){
        showGameMessage('Edificio potenziato', `${DEF.name} √® ora a livello ${nextLvl} (${nextBenefitText}).`);
      }

      const gLine = document.getElementById('g-gold-line');
      if (gLine && typeof getGuildGold==='function'){
        gLine.innerHTML = `<strong>Oro:</strong> ${formatGold(getGuildGold(gid))} monete d'oro`;
      }

      renderGuildBuildingDetail(gid, key); // refresh
    });
  }
}

function renderGuildDiplomacy(gid){
  if (typeof ensureGuildDiplomacyStore==='function') ensureGuildDiplomacyStore();

  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  if (!g){ renderMyGuild(); return; }

  const me = (typeof currentUser==='string' && currentUser) ? currentUser : null;
  const isLeader = (me && g.owner === me);

  // dati
  const allies = (typeof listAllies==='function') ? listAllies(gid) : [];
  const wars   = (typeof listWars==='function') ? listWars(gid) : [];
  const pendIn = (typeof listPendingFor==='function') ? listPendingFor(gid) : [];   // ricevute
  const pendOut= (typeof listPendingFrom==='function') ? listPendingFrom(gid) : []; // inviate

  // renderer carta gilda (stile lista gilde)
  const card = (otherId, extraRight='')=>{
    const og = all[otherId];
    if (!og) return '';
    const mem = (typeof countGuildMembers==='function') ? countGuildMembers(otherId) : 0;
    const limit = og.limit || 60;
    const privacy = (og.privacy==='invite' ? 'Su invito' : 'Aperta');
    return `
      <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; border:1px solid #6b4226; padding:6px 8px; border-radius:10px; background:#f6ecd1;">
        <div style="display:flex; gap:10px; align-items:center;">
          <div class="guild-banner" style="width:84px; height:50px;">${bannerSVG(og.banner||{})}</div>
          <div>
            <div><strong>${og.name}</strong> [${og.tag}]</div>
            <div class="muted">Membri: ${mem}/${limit} ‚Ä¢ Privacy: ${privacy}</div>
          </div>
        </div>
        ${extraRight || ''}
      </div>
    `;
  };

  const alliesHtml = allies.length
    ? allies.map(id=>card(id)).join('')
    : `<div class="muted">Nessuna alleanza.</div>`;

  const warsHtml = wars.length
  ? wars.map(id=>`<div data-war-progress="${id}" style="cursor:pointer;">${card(id)}</div>`).join('')
  : `<div class="muted">Nessuna guerra in corso.</div>`;

  const pendHtml = (pendIn.length || pendOut.length)
  ? `
    ${pendIn.length ? `<div class="muted" style="margin:6px 0 6px;">Richieste ricevute:</div>` + pendIn.map(p=>card(p.from)).join('') : ''}
    ${pendOut.length ? `<div class="muted" style="margin:10px 0 6px;">Richieste inviate:</div>` + pendOut.map(p=>card(
      p.to,
      `<div class="actions"><button class="tiny-btn minus" data-ally-withdraw="${p.to}">Ritira richiesta</button></div>`
    )).join('') : ''}
  `
  : `<div class="muted">Nessuna richiesta in sospeso.</div>`;

  const leaderActions = !isLeader ? '' : `
    <div class="traits-block">
      <div class="title">Azioni Diplomatiche</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <button class="magic-button" id="dip-propose">üïäÔ∏è Proponi alleanza</button>
        <button class="magic-button" id="dip-break">‚õìÔ∏è‚Äçüí• Sciogli alleanza</button>
        <button class="magic-button" id="dip-war">‚öîÔ∏è Dichiara guerra</button>
        <button class="magic-button" id="dip-surrender">ü§ù Dichiara resa</button>
        <button class="magic-button" id="dip-history">üìú Cronologia</button>
      </div>
    </div>
  `;

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Diplomazia</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="dip-back">‚Üê Indietro</button>
      </div>
      <div class="traits-grid" style="grid-template-columns:1fr; gap:12px;">
        <div style="text-align:left;">
  <div style="font-weight:bold; margin-bottom:6px;">Alleanze</div>
  ${alliesHtml}
</div>
<div style="text-align:left;">
  <div style="font-weight:bold; margin:12px 0 6px;">Alleanze in sospeso</div>
  ${pendHtml}
</div>
<div style="text-align:left;">
  <div style="font-weight:bold; margin:12px 0 6px;">Guerre in corso</div>
  ${warsHtml}
</div>
      </div>
    </div>
    ${leaderActions}
  `;

  // back
  document.getElementById('dip-back')?.addEventListener('click', renderMyGuild);

  // leader-only: aperture selettori
  if (isLeader){
    document.getElementById('dip-propose')?.addEventListener('click', ()=> renderDiplomacySelect(gid, 'ally_propose'));
    document.getElementById('dip-break')?.addEventListener('click',   ()=> renderDiplomacySelect(gid, 'ally_break'));
    document.getElementById('dip-war')?.addEventListener('click',     ()=> renderDiplomacySelect(gid, 'war_declare'));
    document.getElementById('dip-surrender')?.addEventListener('click',()=> renderDiplomacySelect(gid, 'war_surrender'));
    document.getElementById('dip-history')?.addEventListener('click', ()=> openDiplomacyHistory(gid));
  }

// Apertura "Andamento Guerra" cliccando la card (solo se √® davvero una guerra attiva)
body.querySelectorAll('[data-war-progress]').forEach(card => {
  if (card._warBound) return;
  card._warBound = true;

  card.addEventListener('click', () => {
    const otherId = card.getAttribute('data-war-progress');
    const myGid   = (typeof getUserGuildId==='function') ? getUserGuildId() : null;
    if (!myGid || !otherId) return;
    if (typeof atWar==='function' && atWar(myGid, otherId)) {
      openWarProgressWindow(myGid, otherId);
    }
  });
});


// === RITIRA RICHIESTA (vista principale Diplomazia) ===
body.querySelectorAll('[data-ally-withdraw]').forEach(btn => {
  if (btn._bound) return;
  btn._bound = true;

  btn.addEventListener('click', () => {
    const otherId = btn.getAttribute('data-ally-withdraw');
    if (!otherId) return;

    // 1) Stato: rimuovi la pending su entrambe
    if (typeof removePendingAlliance === 'function') {
      removePendingAlliance(gid, otherId); // gid = mittente, otherId = destinatario
    }

    // 2) Messaggio al leader destinatario
    if (typeof sendGuildMessage === 'function') {
      const myName = (getGuilds()?.[gid]?.name) || '‚Äî';
      sendGuildMessage(otherId, {
        title: 'Richiesta di alleanza ritirata',
        body: `La gilda "${myName}" ha ritirato la richiesta di alleanza.`,
        type: 'guild_alliance_withdrawn',
        fromGuildId: gid,
        toGuildId: otherId,
        when: Date.now(),
        unread: true
      });
    }

    // 3) Toast + refresh
    showToast('Richiesta di alleanza ritirata.', 'warn', 3000);
    renderGuildDiplomacy(gid);
  });
});

}

// === FINESTRA: Andamento Guerra =============================================
function openWarProgressWindow(myGid, otherGid){
  // Stoppa eventuale timer/listener precedenti se riapro la finestra
  try{
    if (window._warProgressTimer){ clearInterval(window._warProgressTimer); window._warProgressTimer = null; }
    if (window._warProgressStorageHandler){
      window.removeEventListener('storage', window._warProgressStorageHandler);
      window._warProgressStorageHandler = null;
    }
  }catch(_){}

  const root = document.getElementById('guild-screen-body');
  if (!root) return;

  const guilds = (typeof getGuilds==='function') ? (getGuilds()||{}) : {};
  const me  = guilds?.[myGid]    || {};
  const foe = guilds?.[otherGid] || {};
  const rec = (typeof getWarData==='function') ? getWarData(myGid, otherGid) : null;

  // numeri sicuri (0 di default)
const myWins   = Number(rec?.wins?.[String(myGid)]     || 0);
const myLosses = Number(rec?.losses?.[String(myGid)]   || 0);
const foeWins  = Number(rec?.wins?.[String(otherGid)]  || 0);
const foeLoss  = Number(rec?.losses?.[String(otherGid)]|| 0);

// totali corretti basati su ‚Äúchi ha iniziato‚Äù
const totFatte    = Number(rec?.totalInitiated?.[String(myGid)]     || 0);
const totRicevute = Number(rec?.totalInitiated?.[String(otherGid)]  || 0);

// PARZIALI per le due righe:
// ‚ÄúSfide FATTE‚Äù = esiti da INIZIATORE della MIA gilda
const myInitWins   = Number(rec?.initiatedWins?.[String(myGid)]   || 0);
const myInitLosses = Number(rec?.initiatedLosses?.[String(myGid)] || 0);

// ‚ÄúSfide RICEVUTE‚Äù = esiti da INIZIATORE dell‚ÄôALTRA gilda (specchio)
const myRecvWins   = Number(rec?.initiatedLosses?.[String(otherGid)] || 0); // loro perdono iniziando ‚Üí noi vinciamo ricevendo
const myRecvLosses = Number(rec?.initiatedWins?.[String(otherGid)]   || 0); // loro vincono iniziando ‚Üí noi perdiamo ricevendo

// ‚ö†Ô∏è Totali ‚Äúvinte/perse‚Äù devono essere PER LA MIA GILDA, su totale match disputati dalla MIA gilda
const totalMatchesForMe = myWins + myLosses;  // 1 partita = o win mia o loss mia (non sommare anche quelle del foe)

// Per la riga ‚ÄúSfide per vittoria‚Äù
const targetWin = 2000;

  root.innerHTML = `
    <div class="traits-block">
      <div class="title">Andamento guerra</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="war-back">‚Üê Indietro</button>
      </div>

      <div style="margin-bottom:8px;">
        <strong>${me.name || 'La tua gilda'}</strong> vs <strong>${foe.name || 'Gilda nemica'}</strong>
      </div>

      <div style="border:1px solid #6b4226; border-radius:8px; background:#f6ecd1; padding:10px 12px;">
        <div style="margin-bottom:6px;">
  <strong>Sfide fatte</strong>: ${totFatte}
  ‚Ä¢ <strong>Vinte</strong>: ${myInitWins}
  ‚Ä¢ <strong>Perse</strong>: ${myInitLosses}
</div>

        <div style="margin-bottom:6px;">
  <strong>Sfide ricevute</strong>: ${totRicevute}
  ‚Ä¢ <strong>Vinte</strong>: ${myRecvWins}
  ‚Ä¢ <strong>Perse</strong>: ${myRecvLosses}
</div>

        <div style="margin-bottom:6px;">
  <strong>Totale sfide vinte</strong>: ${myWins} su ${totalMatchesForMe}
</div>
<div style="margin-bottom:10px;">
  <strong>Totale sfide perse</strong>: ${myLosses} su ${totalMatchesForMe}
</div>

        <div><strong>Sfide per vittoria</strong>: ${myWins} / ${targetWin}</div>
      </div>
    </div>
  `;

  // üîÑ Auto-refresh ogni 2s (se la finestra resta aperta)
  window._warProgressTimer = setInterval(()=>{
    if (document.getElementById('war-back')) {
      // richiama se stesso per ricaricare i dati aggiornati
      openWarProgressWindow(myGid, otherGid);
    } else {
      clearInterval(window._warProgressTimer);
      window._warProgressTimer = null;
    }
  }, 2000);

  // ‚ö° Refresh immediato quando cambia il localStorage globale
  window._warProgressStorageHandler = (e)=>{
    try{
      // Chiave globale impostata in storage.js (es: 'mitharia_global:guildWarsData')
      if (e && typeof e.key === 'string' && e.key.includes('global:guildWarsData')){
        if (document.getElementById('war-back')) {
          openWarProgressWindow(myGid, otherGid);
        }
      }
    }catch(_){}
  };
  window.addEventListener('storage', window._warProgressStorageHandler, false);

  // Indietro: cleanup e ritorno a Diplomazia
  document.getElementById('war-back')?.addEventListener('click', () => {
    try{
      if (window._warProgressTimer){ clearInterval(window._warProgressTimer); window._warProgressTimer = null; }
      if (window._warProgressStorageHandler){
        window.removeEventListener('storage', window._warProgressStorageHandler);
        window._warProgressStorageHandler = null;
      }
    }catch(_){}
    if (typeof renderGuildDiplomacy==='function') renderGuildDiplomacy(myGid);
  });
}

// === FINESTRA: Cronologia Diplomazia =========================================
function openDiplomacyHistory(gid, page=1){
  const root = document.getElementById('guild-screen-body');
  if (!root) return;

  const guilds = (typeof getGuilds==='function') ? (getGuilds()||{}) : {};
  const meG = guilds[gid] || { name:'Gilda', tag:'' };
  const hist = (typeof listDiplomacyHistory==='function') ? (listDiplomacyHistory(gid)||[]) : [];

  // --- Paginazione: 10 eventi per pagina ---
  const PER_PAGE = 10;
  const totalPages = Math.max(1, Math.ceil(hist.length / PER_PAGE));
  let curPage = Math.min(Math.max(1, Number(page)||1), totalPages);
  window._dipHistPage = curPage; // ricorda la pagina corrente tra i re-render

  const start = (curPage - 1) * PER_PAGE;
  const end   = start + PER_PAGE;
  const histPage = hist.slice(start, end);

  // Stato pulsanti per la pagina corrente
  const showPrev = (curPage > 1);
  const showNext = (curPage < totalPages);

  const fmtGuild = (otherId) => {
    const g = guilds[otherId] || {};
    const name = g.name || ('Gilda '+otherId);
    const tag  = g.tag ? ` [${g.tag}]` : '';
    return `${name}${tag}`;
  };
  const fmtWhen = (ts) => {
    try {
      const d = new Date(Number(ts)||Date.now());
      // gg/mm/aaaa hh:mm
      const pad = n => String(n).padStart(2,'0');
      return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    } catch(_) { return ''; }
  };
  const iconLabel = (t) => {
    switch(t){
      case 'ally_start': return {i:'üïäÔ∏è', l:'Alleanza iniziata'};
      case 'ally_end'  : return {i:'‚õìÔ∏è‚Äçüí•', l:'Alleanza terminata'};
      case 'war_start' : return {i:'‚öîÔ∏è', l:'Guerra iniziata'};
      case 'war_end'   : return {i:'ü§ù', l:'Guerra conclusa'};
      default          : return {i:'‚Ä¢', l:t};
    }
  };

  // Raggruppa per giorno (opzionale, ma carino)
  const groups = {};
  histPage.forEach(ev=>{
    const d = new Date(Number(ev.when)||Date.now());
    const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    (groups[key] ||= []).push(ev);
  });
  const dayKeys = Object.keys(groups).sort().reverse();

  const rowsHtml = dayKeys.map(day=>{
    const [Y,M,D] = day.split('-');
    const dayTitle = `${D}/${M}/${Y}`;
    const items = groups[day].map(ev=>{
      const meta = iconLabel(ev.type);
      const dir  = ev.dir === 'in' ? ' (ricevuta)' : ' (inviata)';
      return `
        <div class="traits-item" style="display:flex;justify-content:space-between;gap:8px;align-items:center;">
          <div>
            <div><strong>${meta.i} ${meta.l}</strong> ‚Äî con <strong>${fmtGuild(ev.with)}</strong>${dir}</div>
            <div class="muted" style="font-size:12px;margin-top:2px;">${fmtWhen(ev.when)}</div>
          </div>
        </div>`;
    }).join('');

    return `
      <div class="traits-sep"></div>
      <div style="font-weight:bold;margin:8px 0 4px;">${dayTitle}</div>
      ${items || `<div class="muted">Nessun evento.</div>`}
    `;
  }).join('');

  root.innerHTML = `
    <div class="traits-block">
      <div class="title">Cronologia ‚Äî ${meG.name} ${meG.tag?`[${meG.tag}]`:''}</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="dip-hist-back">‚Üê Indietro</button>
      </div>
      <div class="traits-grid" style="grid-template-columns:1fr; gap:12px;">
        ${hist.length ? rowsHtml : `<div class="muted">Ancora nessun evento diplomatico.</div>`}
        ${
          (hist.length > PER_PAGE)
            ? `
              <div style="display:flex; gap:8px; justify-content:${(showPrev && showNext) ? 'space-between' : 'center'}; align-items:center; margin-top:6px;">
                ${ showPrev ? `<button class="mini-button" id="dip-hist-prev">‚Üê Pagina precedente</button>` : '' }
                ${ showNext ? `<button class="mini-button" id="dip-hist-next">Pagina successiva ‚Üí</button>` : '' }
              </div>
            `
            : ''
        }
      </div>
    </div>
  `;

  // back ‚Üí ritorna alla schermata Diplomazia
  document.getElementById('dip-hist-back')?.addEventListener('click', ()=> renderGuildDiplomacy(gid));

  // Navigazione pagine (creati solo se i bottoni esistono)
  const prevBtn = document.getElementById('dip-hist-prev');
  if (prevBtn) {
    prevBtn.addEventListener('click', ()=>{
      openDiplomacyHistory(gid, (window._dipHistPage || 1) - 1);
    });
  }
  const nextBtn = document.getElementById('dip-hist-next');
  if (nextBtn) {
    nextBtn.addEventListener('click', ()=>{
      openDiplomacyHistory(gid, (window._dipHistPage || 1) + 1);
    });
  }

  // Auto-aggiorna se cambia qualcosa (accetta/rifiuta, guerra, resa, ecc.)
  const rerender = ()=> openDiplomacyHistory(gid, window._dipHistPage || 1);
  try {
    // eventi in-page
    window.addEventListener('diplomacy:updated', rerender);
    window.addEventListener('wars:updated', rerender);
    // cross-tab via localStorage
    window._dipHistStorageHandler = (e)=> {
      if (e && e.key === 'mitharia_signal') rerender();
    };
    window.addEventListener('storage', window._dipHistStorageHandler);
  } catch(_) {}

  // pulizia dei listener quando esci con "Indietro"
  const btn = document.getElementById('dip-hist-back');
  if (btn) {
    btn.addEventListener('click', ()=>{
      try{
        window.removeEventListener('diplomacy:updated', rerender);
        window.removeEventListener('wars:updated', rerender);
        if (window._dipHistStorageHandler){
          window.removeEventListener('storage', window._dipHistStorageHandler);
          window._dipHistStorageHandler = null;
        }
      } catch(_){}
    }, { once:true });
  }
}


// Vista di selezione per le 4 azioni
function renderDiplomacySelect(myGid, mode) {
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const all = (typeof getGuilds === 'function') ? getGuilds() : {};
  const me = all[myGid];
  if (!me) { renderMyGuild(); return; }

  const allies = (typeof listAllies === 'function') ? listAllies(myGid) : [];
  const wars = (typeof listWars === 'function') ? listWars(myGid) : [];
  const pendIn = (typeof listPendingFor === 'function') ? listPendingFor(myGid) : [];
  const pendOut = (typeof listPendingFrom === 'function') ? listPendingFrom(myGid) : [];

  // set di pending
  const pendingTargets = new Set(pendIn.map(p => p.from).concat(pendOut.map(p => p.to)));

  // titolo azione
  const titleMap = {
    ally_propose: 'Proponi alleanza',
    ally_break: 'Sciogli alleanza',
    war_declare: 'Dichiara guerra',
    war_surrender: 'Dichiara resa'
  };

  // funzione per bottone destro
  const rightBtn = (otherId) => {
    if (mode === 'ally_propose') return `<button class="magic-button guild-mini" data-ally-propose="${otherId}">Richiedi alleanza</button>`;
    if (mode === 'ally_break') return `<button class="magic-button guild-mini" data-ally-break="${otherId}">Sciogli alleanza</button>`;
    if (mode === 'war_declare') return `<button class="magic-button guild-mini" data-war-declare="${otherId}">Dichiara guerra</button>`;
    if (mode === 'war_surrender') return `<button class="magic-button guild-mini" data-war-surrender="${otherId}">Dichiara resa</button>`;
    return '';
  };

  // card singola
  const card = (otherId) => {
    const og = all[otherId]; if (!og) return '';
    const mem = (typeof countGuildMembers === 'function') ? countGuildMembers(otherId) : 0;
    const limit = og.limit || 60;
    return `
      <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; border:1px solid #6b4226; padding:6px 8px; border-radius:10px; background:#f6ecd1;">
        <div style="display:flex; gap:10px; align-items:center;">
          <div class="guild-banner" style="width:84px; height:50px;">${bannerSVG(og.banner || {})}</div>
          <div>
            <div><strong>${og.name}</strong> [${og.tag}]</div>
            <div class="muted">Membri: ${mem}/${limit}</div>
          </div>
        </div>
        ${rightBtn(otherId)}
      </div>
    `;
  };

  // candidati iniziali in base alla modalit√†
  let candidates = Object.keys(all).filter(id => id !== myGid);
  if (mode === 'ally_propose') {
  candidates = candidates.filter(id => !allies.includes(id) && !pendingTargets.has(id) && !wars.includes(id));
} else if (mode === 'ally_break') {
    candidates = allies.slice();
  } else if (mode === 'war_declare') {
    candidates = candidates.filter(id => !wars.includes(id) && !allies.includes(id) && !pendingTargets.has(id));
  } else if (mode === 'war_surrender') {
    candidates = wars.slice();
  }

  const perPage = 6;
  let page = 1;

  // render pagina
  const renderPage = () => {
    const totalPages = Math.max(1, Math.ceil(candidates.length / perPage));
    const start = (page - 1) * perPage;
    const slice = candidates.slice(start, start + perPage);
    const listHtml = slice.length ? slice.map(card).join('') : `<div class="muted">Nessuna gilda disponibile.</div>`;
    const navHtml = (totalPages > 1)
      ? `<div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
          ${page > 1 ? `<button class="magic-button" id="dip-prev">‚Üê Pagina precedente</button>` : `<span></span>`}
          ${page < totalPages ? `<button class="magic-button" id="dip-next">Pagina successiva ‚Üí</button>` : `<span></span>`}
        </div>`
      : '';

    body.innerHTML = `
      <div class="traits-block">
        <div class="title">${titleMap[mode] || 'Seleziona gilda'}</div>
        <div style="margin:6px 0 10px;">
          <button class="mini-button mini-button--dark" id="dip-sel-back">‚Üê Indietro</button>
        </div>
        <input id="dip-search" placeholder="Cerca per nome o TAG" style="width:260px; margin-bottom:8px;">
        <div class="traits-grid" style="grid-template-columns:1fr;">
          ${listHtml}
        </div>
        ${navHtml}
      </div>
    `;

    // ricerca live (mantiene focus e cursore)
const s = document.getElementById('dip-search');
if (s) {
  s.value = window._dipQuery || ''; // ripristina testo precedente
  s.focus();
  const L = s.value.length;
  try { s.setSelectionRange(L, L); } catch (_) {}

  s.oninput = () => {
    const q = (s.value || '').trim().toLowerCase();
    window._dipQuery = s.value; // salva temporaneamente il testo cercato

    const base = Object.keys(all).filter(id => id !== myGid);
    let filtered = base.filter(id => {
      const og = all[id];
      return (og.name || '').toLowerCase().includes(q) || (og.tag || '').toLowerCase().includes(q);
    });

    if (mode === 'ally_propose') filtered = filtered.filter(id => !allies.includes(id) && !pendingTargets.has(id) && !wars.includes(id));
    if (mode === 'ally_break') filtered = allies.filter(id => filtered.includes(id));
    if (mode === 'war_declare') filtered = filtered.filter(id => !wars.includes(id) && !allies.includes(id) && !pendingTargets.has(id));
    if (mode === 'war_surrender') filtered = wars.filter(id => filtered.includes(id));

    candidates = filtered;
    page = 1;
    renderPage();
  };
}


    // navigazione
    document.getElementById('dip-prev')?.addEventListener('click', () => { page--; renderPage(); });
    document.getElementById('dip-next')?.addEventListener('click', () => { page++; renderPage(); });
    document.getElementById('dip-sel-back')?.addEventListener('click', () => {
  window._dipQuery = '';  // üîπ reset della ricerca
  renderGuildDiplomacy(myGid);
});

    // === Azioni diplomatiche ===
// PROPPONI ALLEANZA
body.querySelectorAll('[data-ally-propose]').forEach(btn => {
  btn.onclick = () => {
    const targetGuildId = btn.getAttribute('data-ally-propose');
    const myGuildName = getGuilds()?.[myGid]?.name || 'la tua gilda';

    // Stato -> pendente
    addPendingAlliance(myGid, targetGuildId);

    // Messaggio corretto (oggetto, non stringhe separate)
    sendGuildMessage(targetGuildId, {
      title: 'Richiesta di Alleanza',
      body: `La gilda ${myGuildName} ti ha proposto un'alleanza.`,
      type: 'guild_alliance_request',
      fromGuildId: myGid,
      toGuildId: targetGuildId
    });

    showToast('Richiesta di alleanza inviata!', 'ok', 3000);
renderGuildDiplomacy(myGid);
  };
});
// SCIOGLI ALLEANZA
body.querySelectorAll('[data-ally-break]').forEach(btn => {
  btn.onclick = () => {
    const otherId = btn.getAttribute('data-ally-break');
    if (!otherId) return;

    const guilds = (typeof getGuilds === 'function') ? getGuilds() : {};
    const myName = guilds?.[myGid]?.name || 'la tua gilda';
    const otherName = guilds?.[otherId]?.name || 'la loro gilda';

    // 1) Stato
if (typeof removeAlliance === 'function') removeAlliance(myGid, otherId);

// 2) Messaggio al capogilda avversario (gi√† lo avevi)
if (typeof sendGuildMessage === 'function') {
  sendGuildMessage(otherId, {
    title: 'Alleanza sciolta',
    body: `La tua alleanza con "${myName}" √® stata sciolta.`,
    type: 'guild_notice',
    when: Date.now(),
    unread: true
  });
}

// 3) Toast + refresh
showToast(`Alleanza con "${otherName}" sciolta.`, 'warn', 3000);
renderGuildDiplomacy(myGid);
  };
}); // <-- fine forEach SCIOGLI ALLEANZA

// DICHIARA GUERRA
body.querySelectorAll('[data-war-declare]').forEach(btn => {
  if (btn._bound) return;
  btn._bound = true;

  btn.addEventListener('click', () => {
    const targetGuildId = btn.getAttribute('data-war-declare');
    if (!targetGuildId) return;

    const guilds = (typeof getGuilds === 'function') ? getGuilds() : {};
    const myName     = guilds?.[myGid]?.name   || 'la tua gilda';
    const targetName = guilds?.[targetGuildId]?.name || 'la loro gilda';

    // Stato
    if (typeof declareWar === 'function') declareWar(myGid, targetGuildId);

    // Messaggio al leader avversario
    if (typeof sendGuildMessage === 'function') {
      sendGuildMessage(targetGuildId, {
        title: 'Dichiarazione di guerra',
        body: `La gilda "${myName}" ti ha dichiarato guerra!`,
        type: 'guild_war_declare',
        fromGuildId: myGid,
        toGuildId: targetGuildId,
        when: Date.now(),
        unread: true
      });
    } 

    // Toast + refresh
    showToast(`Hai dichiarato guerra a "${targetName}".`, 'err', 3000);
    renderGuildDiplomacy(myGid);
  });
}); // <-- fine dichiara guerra

// DICHIARA RESA
body.querySelectorAll('[data-war-surrender]').forEach(btn => {
  if (btn._bound) return;
  btn._bound = true;

  btn.addEventListener('click', () => {
    const targetGuildId = btn.getAttribute('data-war-surrender');
    if (!targetGuildId) return;

    const guilds = (typeof getGuilds === 'function') ? getGuilds() : {};
    const targetName = guilds?.[targetGuildId]?.name || 'la loro gilda';

    // Stato
    if (typeof endWar === 'function') endWar(myGid, targetGuildId);

    // Messaggio al leader avversario
    if (typeof sendGuildMessage === 'function') {
      sendGuildMessage(targetGuildId, {
        title: 'Dichiarazione di resa',
        body: `La gilda "${(guilds?.[myGid]?.name || '‚Äî')}" ha dichiarato la resa.`,
        type: 'guild_war_surrender',
        fromGuildId: myGid,
        toGuildId: targetGuildId,
        when: Date.now(),
        unread: true
      });
    }

    // Toast + refresh
    showToast(`Hai dichiarato la resa a "${targetName}".`, 'warn', 3000);
    renderGuildDiplomacy(myGid);
  });
}); // <-- fine dichiara resa

}; // <-- fine funzione renderDiplomacySelect

  // prima render
  renderPage();
}



// === Pannello "Benefici Attivi" (Missioni / Sfide-Dungeon / Gilda) ===
function renderActiveBonuses(origin){
  // Scegli il contenitore in base alla schermata di origine
  let body = null;
  if (origin === 'missions') {
    body = document.getElementById('missions-list');                   // Missioni
  } else if (origin === 'challenges') {
    body = document.getElementById('challenges-root');                 // Sfide/Dungeon: pagina intera
  } else {
    body = document.getElementById('guild-screen-body')                // fallback Gilda
        || document.getElementById('main-screen-body');
  }
  if (!body) return;

  const gid = (typeof getUserGuildId==='function') ? getUserGuildId() : null;
  const g   = (gid && typeof getGuilds==='function') ? getGuilds()[gid] : null;

  // Lista benefici attivi
    const items = [];
if (g && typeof getGuildBuildingLevel==='function'){
  const lvl1 = getGuildBuildingLevel(gid, 'hall_of_legends');
  if (lvl1>0){
    items.push(`Sala delle Leggende (Liv. ${lvl1}): +${lvl1*4}% XP eroe`);
  }
  const lvl2 = getGuildBuildingLevel(gid, 'beast_sanctum');
  if (lvl2>0){
    items.push(`Santuario delle Bestie (Liv. ${lvl2}): +${lvl2} XP creatura`);
  }
  const lvl3 = getGuildBuildingLevel(gid, 'guild_treasury');
  if (lvl3>0){
    items.push(`Tesoreria della Gilda (Liv. ${lvl3}): +${lvl3*5}% oro guadagnato`);
  }
  const lvl4 = getGuildBuildingLevel(gid, 'library_of_knowledge');
if (lvl4 > 0){
  items.push(`Biblioteca del Sapere (Liv. ${lvl4}): -${lvl4*30} min cooldown missioni`);
}
const lvl5 = getGuildBuildingLevel(gid, 'blessing_altar');
if (lvl5 > 0){
  items.push(`Altare delle Benedizioni (Liv. ${lvl5}): +${lvl5*3}% fortuna frammenti di cristallo`);
}
}

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Benefici Attivi</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="benefits-back">‚Üê Indietro</button>
      </div>
      <div class="traits-grid" style="grid-template-columns:1fr; text-align:left;">
        ${
          items.length>0
          ? items.map(it=>`<div>${it}</div>`).join('')
          : `<div class="muted">Nessun beneficio attivo.</div>`
        }
      </div>
    </div>
  `;

  document.getElementById('benefits-back')?.addEventListener('click', ()=>{
    // Torna dove eravamo
    if (origin === 'missions') {
      if (typeof renderMissionsUI === 'function') renderMissionsUI();
    } else if (origin === 'challenges') {
  // abbiamo sovrascritto #challenges-root: forza il rebuild dei tab
  _challengesLayoutReady = false;
  if (typeof showChallenges === 'function') showChallenges();       // ricostruisce layout tab + contenuti
}
 else {
      // gilda / fallback
      if (typeof renderMyGuild === 'function') renderMyGuild();
    }
  });
}
// Stato persistente della ricerca in "Ultime sfide"
window._pvpHistQuery = ''; // '' = nessun filtro

function renderPvpHistoryWindow(page = 0){
  const root = document.getElementById('challenges-root');
  const tabbar = document.getElementById('challenges-tabbar');
  const tabSfide = document.getElementById('challenges-tab-sfide');
  const tabDungeon = document.getElementById('challenges-tab-dungeon');
  const hist = document.getElementById('pvp-history-view');
  if (!root || !hist) return;

// Titolo grande della sezione: cambia da "Sfide e Dungeon" a "Ultime sfide"
const bigTitle = document.querySelector('#challenges > h2');
if (bigTitle) bigTitle.textContent = 'Ultime sfide';

// Nascondi i bottoncini sotto il titolo quando siamo nella vista "Ultime sfide"
const benBtn = document.getElementById('challenges-benefits-btn'); // "Benefici gilda"
if (benBtn && benBtn.parentElement) benBtn.parentElement.style.display = 'none';

const persBtn = document.getElementById('challenges-personal-btn'); // "Bonus personali" (se presente)
if (persBtn && persBtn.parentElement) persBtn.parentElement.style.display = 'none';

const histBtn = document.getElementById('challenges-history-btn'); // "Ultime sfide" (il nostro)
if (histBtn && histBtn.parentElement) histBtn.parentElement.style.display = 'none';

// Testo di ricerca corrente (persistente)
let query = String(window._pvpHistQuery || '').trim();

  // prendi lo storico (solo PvP) e prepara la paginazione
const list = (typeof getMyPvpLog === 'function') ? getMyPvpLog() : [];
const me = (typeof currentUser === 'string') ? currentUser : '';

// opponent = l'altro giocatore in ogni record
function opponentOf(e){
  return (e.aUser === me) ? (e.bUser || '') : (e.aUser || '');
}

// filtro per nome (match parziale, case-insensitive)
const q = query.toLowerCase();
const filtered = q
  ? list.filter(e => opponentOf(e).toLowerCase().includes(q))
  : list;

// paginazione sui risultati filtrati
const PER_PAGE = 6;
const total = filtered.length;
const totalPages = Math.max(1, Math.ceil(total / PER_PAGE));
page = Math.max(0, Math.min(page, totalPages - 1));

const start = page * PER_PAGE;
const end = start + PER_PAGE;
const pageItems = filtered.slice(start, end);



  function esc(s){ return String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function stamp(ts){
    if (typeof fmtDateTimeShort === 'function') return fmtDateTimeShort(ts); // gi√† in uso nei messaggi
    try { return new Date(ts).toLocaleString('it-IT'); } catch(_) { return String(ts); }
  }

    const rows = pageItems.map(e => {
    const iAmA    = (e.aUser === me);
    const iWin    = (e.winner === (iAmA ? 'a' : 'b'));
    const myDelta = iAmA ? Number(e.aDelta||0) : Number(e.bDelta||0);

    const tagA = e.aTag ? `[${esc(e.aTag)}]` : '';
    const tagB = e.bTag ? `[${esc(e.bTag)}]` : '';
    const whoA = `${tagA}${esc(e.aUser)}`;
    const whoB = `${tagB}${esc(e.bUser)}`;

    const dateLine = stamp(e.when).replace(',', ' ‚Ä¢');

    // üëá Salute persa per ME in questa sfida, se presente nel log
    const rawHp = iAmA ? e.aHpLoss : e.bHpLoss;
    let hpStr = '';
    if (typeof rawHp === 'number' && !isNaN(rawHp) && rawHp > 0) {
      hpStr = rawHp.toFixed(1).replace('.', ',');
    }
    const hpLine = hpStr ? `<div>Salute persa: -${hpStr}</div>` : '';

    return `
      <div style="padding:10px 12px; border:1px solid #6b4226; border-radius:8px; margin-bottom:8px; background:#f7f2e5; color:#1d1309;">
        <div><strong>${whoA}</strong> VS <strong>${whoB}</strong></div>
        <div style="margin-top:4px;">${iWin ? 'üèÜ <strong>Vittoria!</strong>' : 'üíÄ <strong>Sconfitta</strong>'}</div>
        <div>Punti: ${myDelta>0?'+':''}${myDelta}</div>
        ${hpLine}
        <div class="muted">${dateLine}</div>
      </div>
    `;
  }).join('');


  hist.innerHTML = `
  <div class="traits-block">
    <div class="title">Ultime sfide</div>
    <div style="margin:6px 0 10px;">
      <button class="mini-button mini-button--dark" id="pvp-history-backtochallenges">‚Üê Indietro</button>
    </div>

    <!-- üîé Cerca per nome (match parziale) -->
<div style="display:flex; gap:8px; align-items:center; margin:4px 0 10px;">
  <input id="pvp-filter-q" placeholder="Cerca per nome" value="${esc(query)}"
         style="flex:1; padding:8px 10px; border:1px solid #6b4226; border-radius:8px; background:#fff; color:#000;">
</div>

    <div class="traits-grid" style="grid-template-columns:1fr; text-align:left;">
      ${ pageItems.length ? rows : `<div class="muted">Nessuna sfida PvP registrata${query ? ' per "' + esc(query) + '"' : ''}.</div>` }
    </div>

    <!-- Pager -->
    <div id="pvp-pager" style="display:flex; align-items:center; justify-content:space-between; margin-top:10px;">
      ${ page > 0 
          ? `<button class="mini-button mini-button--dark" id="pvp-page-prev">Pagina precedente</button>`
          : `<span></span>` }
      <span></span>
      ${ page < totalPages - 1
          ? `<button class="mini-button mini-button--dark" id="pvp-page-next">Pagina successiva</button>`
          : `<span></span>` }
    </div>
  </div>
`;

  // Nascondi la UI tab e mostra la vista
  tabbar?.classList.add('hidden');
  tabSfide?.classList.add('hidden');
  tabDungeon?.classList.add('hidden');
  hist.classList.remove('hidden');
document.getElementById('pvp-history-backtochallenges')?.addEventListener('click', ()=>{
  // ripristina titolo grande
  const bigTitle = document.querySelector('#challenges > h2');
  if (bigTitle) bigTitle.textContent = 'Sfide e Dungeon';

  // ri-mostra i bottoncini sotto il titolo
  ['challenges-benefits-btn','challenges-personal-btn','challenges-history-btn'].forEach(id=>{
    const btn = document.getElementById(id);
    if (btn && btn.parentElement) btn.parentElement.style.display = '';
  });
window._pvpHistQuery = '';

  // torna ai tab
  tabbar?.classList.remove('hidden');
  tabSfide?.classList.remove('hidden');
  tabDungeon?.classList.add('hidden');
  hist.classList.add('hidden');
});

// === CERCA PER NOME ===
const inp = document.getElementById('pvp-filter-q');
if (inp && !inp._bound) {
  inp._bound = true;
  let t = null;
  inp.addEventListener('input', () => {
    clearTimeout(t);

    // ‚¨áÔ∏è salva posizione cursore prima del re-render
    const caret = (typeof inp.selectionStart === 'number') ? inp.selectionStart : (inp.value || '').length;
    window._pvpRestoreCaret = { pos: caret };

    t = setTimeout(() => {
      window._pvpHistQuery = inp.value || '';
      renderPvpHistoryWindow(0);
    }, 200);
  });
}
// ‚¨áÔ∏è ripristina focus e posizione cursore nella barra di ricerca
if (window._pvpRestoreCaret) {
  const want = window._pvpRestoreCaret.pos || 0;
  const input2 = document.getElementById('pvp-filter-q');
  if (input2) {
    // focus
    input2.focus();
    // caret clamped alla lunghezza attuale del valore
    const p = Math.max(0, Math.min(want, input2.value.length));
    try { input2.setSelectionRange(p, p); } catch(e) {}
  }
  window._pvpRestoreCaret = null; // reset flag
}

// Paginazione
const prevBtn = document.getElementById('pvp-page-prev');
const nextBtn = document.getElementById('pvp-page-next');

if (prevBtn) prevBtn.onclick = () => renderPvpHistoryWindow(page - 1);
if (nextBtn) nextBtn.onclick = () => renderPvpHistoryWindow(page + 1);

// Se cambia lo storico mentre sono nella vista, ridisegno rimanendo sulla stessa pagina (clamp automatico)
window.addEventListener('pvp_log_changed', (ev)=>{
  const u = (ev.detail||{}).user;
  if (!u || u === me) renderPvpHistoryWindow(page);
}, { once:true });

  // Men√π principale (stesso comportamento del resto dell‚Äôapp)
  const back = document.getElementById('pvp-history-back');
  if (back) back.onclick = () => {
    if (typeof goBack === 'function') { goBack(); } // torna al men√π
    else {
      // fallback se non disponibile
      document.getElementById('challenges')?.classList.add('hidden');
      document.getElementById('menu')?.classList.remove('hidden');
    }

    // ripristina stato per quando rientri in ‚ÄúSfide‚Äù
    tabbar?.classList.remove('hidden');
    hist.classList.add('hidden');
  };

  // refresh live se arriva una nuova sfida
  window.addEventListener('pvp_log_changed', (ev)=>{
    if ((ev.detail||{}).user === me) {
      renderPvpHistoryWindow(); // ridisegna
    }
  }, { once:true });
}

// === Pannello "Bonus personali attivi" (Missioni / Sfide-Dungeon / Gilda) ===
function renderPersonalBonuses(origin){
  // Scegli contenitore come in renderActiveBonuses
  let body = null;
  if (origin === 'missions') {
    body = document.getElementById('missions-list');
  } else if (origin === 'challenges') {
    body = document.getElementById('challenges-root');
  } else {
    body = document.getElementById('guild-screen-body') || document.getElementById('main-screen-body');
  }
  if (!body) return;

  const items = [];
  if (typeof listPersonalBonusesActive === 'function'){
    const list = listPersonalBonusesActive();
    const now = Date.now();
    list.forEach(entry=>{
      const rem = Math.max(0, Number(entry.until||0) - now);
      items.push(`${entry.label} ‚Äî resta: ${gs_formatDH(rem)}`);
    });
  }

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Bonus personali attivi</div>
      <div class="traits-grid" style="grid-template-columns:1fr; text-align:left;">
        ${
          (items && items.length)
            ? items.map(x=>`<div>${x}</div>`).join('')
            : `<div class="muted">Nessun bonus personale attivo.</div>`
        }
      </div>
      <div style="margin-top:10px;">
        <button class="mini-button mini-button--dark" id="personal-back">‚Üê Indietro</button>
      </div>
    </div>
  `;

  document.getElementById('personal-back')?.addEventListener('click', ()=>{
    if (origin === 'missions') {
      if (typeof renderMissionsUI === 'function') renderMissionsUI();
    } else if (origin === 'challenges') {
      _challengesLayoutReady = false;
      if (typeof showChallenges === 'function') showChallenges();
    } else {
      if (typeof renderMyGuild === 'function') renderMyGuild();
    }
  });
}


function renderGuildBuildingBenefits(gid, key){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const DEF = {
    hall_of_legends: { name: 'Sala delle Leggende', type:'hero_pct', perLevel:4 },
    beast_sanctum:   { name: 'Santuario delle Bestie', type:'creature_flat', perLevel:1 },
    guild_treasury:  { name: 'Tesoreria della Gilda', type:'gold_pct', perLevel:5 },
    library_of_knowledge: { name:'Biblioteca del Sapere', type:'mission_cd', perLevel:30 },
    blessing_altar:  { name:'Altare delle Benedizioni', type:'crystal_frag', perLevel:3 }
  }[key];

  if (!DEF){ renderGuildBuildings(gid); return; }

  const rows = Array.from({length:5}, (_,i)=>{
  const lvl = i+1;
  if (DEF.type === 'hero_pct'){
    const pct = lvl * DEF.perLevel;
    return `<div><strong>Livello ${lvl}</strong>  +${pct}% EXP eroe dalle attivit√†</div>`;
  } else if (DEF.type === 'creature_flat'){
    const flat = lvl * DEF.perLevel;
    return `<div><strong>Livello ${lvl}</strong>  +${flat} XP creatura dalle attivit√†</div>`;
  } else if (DEF.type === 'gold_pct'){
    const pct = lvl * DEF.perLevel;
    return `<div><strong>Livello ${lvl}</strong>  +${pct}% oro guadagnato</div>`;
  } else if (DEF.type === 'mission_cd'){
    const mins = lvl * DEF.perLevel;
    return `<div><strong>Livello ${lvl}</strong>  -${mins} min al cooldown missioni</div>`;
  } else if (DEF.type === 'crystal_frag'){
    const bonus = lvl * DEF.perLevel; // 3,6,9,12,15
    return `<div><strong>Livello ${lvl}</strong>  +${bonus}% fortuna frammenti di cristallo</div>`;
  }
  return '';
}).join('');


  body.innerHTML = `
    <div class="traits-block">
      <div class="title">${DEF.name} ‚Äî Benefici</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="g-bld-benefits-back">‚Üê Indietro</button>
      </div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div style="text-align:left;">
          ${rows}
        </div>
      </div>
    </div>
  `;

  document.getElementById('g-bld-benefits-back')
    ?.addEventListener('click', ()=>renderGuildBuildingDetail(gid, key));
}



// === Bonus XP Eroe da edifici di gilda ===
function getGuildHeroXpBonusFactor(){
  try{
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    if (!gid) return 1;
    const lvl = (typeof getGuildBuildingLevel === 'function')
      ? (getGuildBuildingLevel(gid, 'hall_of_legends') || 0)
      : 0;
    const pct = Math.max(0, Math.min(5, Number(lvl)||0)) * 4; // 0..20
    return 1 + (pct / 100);
  }catch(e){ return 1; }
}
function applyGuildHeroXpBonus(rawXp){
  const g = (typeof getGuildHeroXpBonusFactor==='function') ? getGuildHeroXpBonusFactor() : 1;
  const p = (typeof getPersonalHeroXpBonusFactor==='function') ? getPersonalHeroXpBonusFactor() : 1;
  // somma percentuali: 1 + (g-1 + p-1)
  const f = 1 + ((g-1) + (p-1));
  return Math.max(0, Math.ceil((Number(rawXp)||0) * f));
}
window.getGuildHeroXpBonusFactor = getGuildHeroXpBonusFactor;
window.applyGuildHeroXpBonus = applyGuildHeroXpBonus;

// === Bonus XP Creatura da edifici di gilda (flat) ===
function getGuildCreatureXpBonusFlat(){
  try{
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    const lvl = (gid && typeof getGuildBuildingLevel === 'function')
      ? (getGuildBuildingLevel(gid, 'beast_sanctum') || 0)
      : 0;
    const guildFlat = Math.max(0, Math.min(5, Number(lvl)||0));
    const personal = (typeof getPersonalCreatureXpBonusFlat==='function') ? getPersonalCreatureXpBonusFlat() : 0;
    return guildFlat + personal; // somma flat
  }catch(e){ return 0; }
}
window.getGuildCreatureXpBonusFlat = getGuildCreatureXpBonusFlat;

// === Bonus Oro da edifici di gilda (%): Tesoreria della Gilda ===
function getGuildGoldBonusFactor(){
  try{
    const gid = (typeof getUserGuildId==='function') ? getUserGuildId() : null;
    if (!gid) return 1;
    const lvl = (typeof getGuildBuildingLevel==='function')
      ? (getGuildBuildingLevel(gid, 'guild_treasury') || 0)
      : 0;
    const pct = Math.max(0, Math.min(5, Number(lvl)||0)) * 5; // 0,5,10,15,20,25
    return 1 + (pct/100);
  }catch(e){ return 1; }
}
function applyGuildGoldBonus(rawGold){
  const g = (typeof getGuildGoldBonusFactor==='function') ? getGuildGoldBonusFactor() : 1;
  const p = (typeof getPersonalGoldBonusFactor==='function') ? getPersonalGoldBonusFactor() : 1;
  const f = 1 + ((g-1) + (p-1)); // somma percentuali
  return Math.max(0, Math.ceil((Number(rawGold)||0) * f));
}
window.getGuildGoldBonusFactor = getGuildGoldBonusFactor;
window.applyGuildGoldBonus = applyGuildGoldBonus;

// === Biblioteca del Sapere: riduzione cooldown missioni ===
function getGuildMissionCooldownReductionMs(){
  try{
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    if (!gid) return 0;
    const lvl = (typeof getGuildBuildingLevel === 'function')
      ? (getGuildBuildingLevel(gid, 'library_of_knowledge') || 0)
      : 0;
    // -30 minuti per livello (max 150')
    const minutes = Math.max(0, Math.min(5, Number(lvl)||0)) * 30;
    return minutes * 60 * 1000;
  }catch(e){ return 0; }
}
function getEffectiveMissionCooldownMs(){
  const base = (typeof MISSION_COOLDOWN_MS !== 'undefined') ? MISSION_COOLDOWN_MS : (8*60*60*1000);
  const cut  = getGuildMissionCooldownReductionMs();
  return Math.max(0, base - cut);
}
window.getGuildMissionCooldownReductionMs = getGuildMissionCooldownReductionMs;
window.getEffectiveMissionCooldownMs = getEffectiveMissionCooldownMs;

// === Altare delle Benedizioni: bonus frammenti di cristallo (missioni) ===
// Livello -> bonus frazionale (0..0.15): 0.03 per livello
function getGuildCrystalFragBonusFraction(){
  try{
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    if (!gid) return 0;
    const lvl = (typeof getGuildBuildingLevel === 'function')
      ? (getGuildBuildingLevel(gid, 'blessing_altar') || 0)
      : 0;
    const bonus = Math.max(0, Math.min(5, Number(lvl)||0)) * 0.03; // 0..0.15
    return bonus;
  }catch(e){ return 0; }
}

// Probabilit√† effettiva di frammento missione: p = base + (1-base)*bonus
function getMissionCrystalFragChance(){
  const pBase = 0.20; // 20% fisso
  const b = getGuildCrystalFragBonusFraction(); // 0..0.15
  const p = pBase + (1 - pBase) * b;
  return Math.max(0, Math.min(1, p));
}
window.getGuildCrystalFragBonusFraction = getGuildCrystalFragBonusFraction;
window.getMissionCrystalFragChance = getMissionCrystalFragChance;


// --- Apertura pannellino "Donazioni" riutilizzabile ---
function openGuildDonations(gid){
  const sub = document.getElementById('g-subview');
  if (!sub) return;

  const myGoldNow = getNum('gold', 0);
  sub.innerHTML = `
    <div class="traits-block">
      <div class="title">Donazioni</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div id="g-my-gold-line" class="muted">Il tuo oro: ${formatGold(myGoldNow)} monete d'oro</div>
        <label>Quantit√† da donare
          <input id="g-donate-amount" type="number" min="1" step="1" style="width:160px">
        </label>
        <button class="magic-button magic-button--slim" id="g-donate-do">Dona</button>
        <div class="muted">La donazione aumenta l'oro della gilda e diminuisce di pari misura il tuo oro personale.</div>
      </div>
    </div>
  `;

  const doBtn = document.getElementById('g-donate-do');
  if (doBtn) doBtn.onclick = ()=>{
    const amt = Math.floor(Number(document.getElementById('g-donate-amount').value || 0));
    if (!Number.isFinite(amt) || amt <= 0){ alert('Inserisci una quantit√† valida.'); return; }

    const have = getNum('gold', 0);
    if (amt > have){ alert('Non hai abbastanza oro.'); return; }

    // Applica: - oro eroe, + oro gilda
    setNum('gold', have - amt);
    if (typeof addGuildGold === 'function') addGuildGold(gid, amt);

// ‚ûï Quest giornaliera: "Dona 500 monete d'oro alla gilda"
if (typeof incrementQuest === 'function') incrementQuest('q_daily_guild_donate_500gold', amt);

// ‚ûï Quest settimanale: "Dona 3000 oro alla gilda" (accumula l'ammontare)
if (typeof incrementQuest === 'function') incrementQuest('q_weekly_guild_donate_3000', amt);

// ‚ûï Catena "Gilda": avanza il conteggio donazioni per lo step corrente
if (typeof incrementMainGuildDonation === 'function') incrementMainGuildDonation(amt);
// (il badge lo aggiorni gi√† subito sotto)

if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();


    // Aggiorna UI
    const myLine = document.getElementById('g-my-gold-line');
    if (myLine) myLine.textContent = `Il tuo oro: ${formatGold(getNum('gold',0))} monete d'oro`;

    const gLine = document.getElementById('g-gold-line'); // visibile solo al leader
    if (gLine && typeof getGuildGold === 'function') {
      gLine.innerHTML = `<strong>Oro:</strong> ${formatGold(getGuildGold(gid))} monete d'oro`;
    }

    // Messaggio conferma
    if (typeof showGameMessage === 'function') {
      showGameMessage('Grazie per la donazione!', `Hai donato ${formatGold(amt)} monete d'oro alla gilda.`);
    }
  };
}
window.openGuildDonations = openGuildDonations;

// Delegato globale di sicurezza per Donazioni (definisci una sola volta)
if (!window._donateDelegated) {
  document.addEventListener('click', function(e){
    const t = e.target;
    if (!t) return;
    if (t.id === 'g-donate-btn') {
      const gid = (typeof getUserGuildId==='function') ? getUserGuildId() : null;
      if (gid && typeof openGuildDonations === 'function') {
        openGuildDonations(gid);
      }
    }
  });
  window._donateDelegated = true;
}

// === Negozio della Gilda: finestra dedicata (stile edifici) + articoli fissi ===
let guildShopTimer = null;

// Catalogo articoli fissi (cooldown centralizzato in storage.js via storageKey)
const GUILD_SHOP_ITEMS = [
  { id:'k_ottone',   storageKey:'key_mercante',     label:'Chiave del Mercante',      keyId:'ottone',  cost:60000,  award:{type:'key',  qty:1} },
  { id:'k_argento',  storageKey:'key_avventuriero', label:'Chiave dell‚Äôavventuriero', keyId:'argento', cost:90000,  award:{type:'key',  qty:1} },
  { id:'k_oro',      storageKey:'key_re',           label:'Chiave del re',            keyId:'oro',     cost:120000, award:{type:'key',  qty:1} },
  { id:'k_runica',   storageKey:'key_arcana',       label:'Chiave arcana',            keyId:'runica',  cost:150000, award:{type:'key',  qty:1} },
  { id:'dust20',     storageKey:'dust20',           label:'20 Polvere arcana',                        cost:30000,  award:{type:'dust', qty:20} },
];
const DAY_MS = 24*60*60*1000; // se gi√† definito altrove, non duplicare

// Pacchetti bonus personali (durate che si sommano nel tempo)
const GUILD_SHOP_BONUS_PACKS = [
  // XP EROE +10%
  { id:'bp_xp_24h',  type:'heroXp',     label:'Bonus XP eroe 24h (+10%)',  cost:5000,   durationMs: 1*DAY_MS },
  { id:'bp_xp_7d',   type:'heroXp',     label:'Bonus XP eroe 7 giorni (+10%)',  cost:30000,  durationMs: 7*DAY_MS },
  { id:'bp_xp_30d',  type:'heroXp',     label:'Bonus XP eroe 30 giorni (+10%)', cost:115000, durationMs:30*DAY_MS },

  // ORO +10%
  { id:'bp_gold_24h', type:'gold',      label:'Bonus oro 24h (+10%)',      cost:6000,   durationMs: 1*DAY_MS },
  { id:'bp_gold_7d',  type:'gold',      label:'Bonus oro 7 giorni (+10%)',      cost:36000,  durationMs: 7*DAY_MS },
  { id:'bp_gold_30d', type:'gold',      label:'Bonus oro 30 giorni (+10%)',     cost:138000, durationMs:30*DAY_MS },

  // XP CREATURA +1
  { id:'bp_cxp_24h',  type:'creatureXp',label:'Bonus XP creatura 24h (+1)', cost:8000,   durationMs: 1*DAY_MS },
  { id:'bp_cxp_7d',   type:'creatureXp',label:'Bonus XP creatura 7 giorni (+1)', cost:48000,  durationMs: 7*DAY_MS },
  { id:'bp_cxp_30d',  type:'creatureXp',label:'Bonus XP creatura 30 giorni (+1)', cost:184000, durationMs:30*DAY_MS },
];

// Piccola descrizione sotto il titolo (come richiesto)
function gs_getShopSubtitle(){
  return `
    <div class="muted" style="margin-top:-6px;margin-bottom:8px;">
      Un emporio speciale della Gilda: qui trovi chiavi rare, polvere arcana in pacchetti,
      segreti e bonus esclusivi che non compaiono nelle botteghe normali.
    </div>
  `;
}

// Formatta durata (giorni/ore/minuti)
function gs_formatDH(ms){
  const totalMin = Math.ceil(ms / 60000);
  const d = Math.floor(totalMin / (60*24));
  const h = Math.floor((totalMin - d*60*24) / 60);
  const m = totalMin % 60;
  const dd = d === 1 ? 'giorno' : 'giorni';
  const hh = h === 1 ? 'ora'   : 'ore';
  const mm = m === 1 ? 'minuto': 'minuti';
  if (d > 0) return `${d} ${dd} e ${h} ${hh}`;
  if (h > 0) return `${h} ${hh} e ${m} ${mm}`;
  return `${m} ${mm}`;
}

// APERTURA "NUOVA FINESTRA" in stile edifici (header con ‚Üê, corpo, footer)
function openGuildShopWindow(gid){
  const root = document.getElementById('guild-screen-body'); // finestra intera (come Edifici)
  if (!root) return;

  const myGold = getNum('gold', 0);

  root.innerHTML = `
  <div class="traits-block">
    <div class="title">Negozio della Gilda</div>
    <div style="margin:6px 0 10px;">
      <button class="mini-button mini-button--dark" id="g-shop-back">‚Üê Indietro</button>
    </div>

    <div class="muted" style="margin-bottom:8px;">
      Il Negozio della Gilda √® un emporio riservato ai membri: un luogo mutevole dove compaiono opportunit√† segrete
      e potenziamenti temporanei. Le sue regole non sono scolpite nella pietra‚Ä¶ conviene tornare spesso.
    </div>

    <p id="guild-shop-gold-line"><strong>Oro disponibile:</strong> <span id="guild-shop-gold">${formatGold(myGold)}</span> monete d'oro</p>

    <!-- Banner offerta segreta -->
    <div id="gs-secret-banner" style="margin-bottom:8px;"></div>
    <!-- Dettaglio offerta segreta -->
    <div id="gs-secret-detail"></div>

    <div class="guild-shop-list" id="guild-shop-list"></div>
<div class="title" style="margin-top:12px;">Bonus personali</div>
<div class="muted" style="margin-bottom:8px;">Acquista potenziamenti temporanei personali. Le durate si sommano se compri pi√π pacchetti dello stesso tipo.</div>
<div class="guild-shop-list" id="guild-shop-bonus-list"></div>

  </div>
`;


  // ‚Üê Indietro (stesso stile degli Edifici)
  const backBtn = document.getElementById('g-shop-back');
  if (backBtn){
    backBtn.onclick = ()=>{
      if (guildShopTimer) clearInterval(guildShopTimer);
      if (typeof renderMyGuild==='function') renderMyGuild();
      else window.history.back();
    };
  }
if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
renderGuildShopSecretBanner();

  renderGuildShopList();
renderGuildShopBonusList();
  startGuildShopTick();
  if (typeof updateGoldBadges==='function') updateGoldBadges();
  if (typeof updateGuildBadges==='function') updateGuildBadges();
}
let guildShopSecretTimer = null;

// ---------- Miniera della Gilda (stile finestra edifici) ----------
let guildMineTimer = null;

function openGuildMineWindow(gid) {
  const root = document.getElementById('guild-screen-body'); // come per gli altri edifici
  if (!root) return;

  // Descrizione (tu chiedi: "la miniera serve per scavare oro ...")
  const desc = `
    La Miniera della Gilda permette agli eroi di collaborare per scavare oro.
    Ogni minuto si guadagnano <strong>10 oro</strong>.
    √à possibile entrare in miniera solo <strong>3 volte al giorno</strong>.
    Durante lo scavo non √® possibile avviare missioni o sfide.
    Una volta entrati in miniera non √® possibile uscire prima della fine del tempo scelto.
    I bonus personali o i bonus della gilda non influenzano l'oro guadagnato in Miniera.
  `;

  // Stato attuale (se ci fosse una run attiva o riscattabile)
  const active = userStore.get('guildMine_active') || null; // { gid, endAt, durationMin, startedAt }
  const claim = userStore.get('guildMine_claimable') || null; // { gid, gold, durationMin, finishedAt }

  root.innerHTML = `
    <div class="traits-block">
      <div class="title">Miniera della Gilda</div>
      <div style="margin:6px 0 10px;">
        <button class="mini-button mini-button--dark" id="g-mine-back">‚Üê Indietro</button>
      </div>
      <div style="text-align:center; margin-bottom:10px;">
        <img src="minieragilda.png" alt="Miniera della Gilda"
             style="width:100%; max-width:260px; border-radius:8px;">
      </div>

      <div class="muted" style="margin-bottom:8px;">${desc}</div>

      <div id="g-mine-area">
        <!-- Area dinamica: se attiva mostra countdown, se claimable mostra Riscuoti, altrimenti i tre pulsanti -->
      </div>

    </div>
  `;

  // Back (top)
  document.getElementById('g-mine-back')?.addEventListener('click', ()=> {
    // ferma timer locale
    if (guildMineTimer) { clearInterval(guildMineTimer); guildMineTimer = null; }
    if (typeof renderMyGuild === 'function') renderMyGuild(); else document.getElementById('menu')?.classList.remove('hidden');
  });

  // Return (bottom)
  document.getElementById('g-mine-return')?.addEventListener('click', ()=> {
    if (guildMineTimer) { clearInterval(guildMineTimer); guildMineTimer = null; }
    if (typeof renderMyGuild === 'function') renderMyGuild(); else document.getElementById('menu')?.classList.remove('hidden');
  });

  // RENDER AREA
  function renderMineArea() {
    const area = document.getElementById('g-mine-area');
    if (!area) return;

    const activeLocal = userStore.get('guildMine_active') || null;
    const claimLocal  = userStore.get('guildMine_claimable') || null;

    if (claimLocal && claimLocal.gid === gid) {
      // Mostra pulsante Riscuoti (a destra come per le quest ‚Äî qui contenuto semplice)
      area.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>Scavo completato: <strong>${claimLocal.durationMin} minuti</strong>. Oro disponibile: <strong>${formatGold(claimLocal.gold)}</strong></div>
          <div><button class="magic-button" id="g-mine-claim">Riscuoti</button></div>
        </div>
      `;
      const btn = document.getElementById('g-mine-claim');
      if (btn) btn.onclick = ()=> {
        // Accredita oro (NO bonus personali o gilda)
        addNum('gold', Number(claimLocal.gold || 0));
        // pulisci stato
        userStore.remove('guildMine_claimable');
        // aggiorna UI + badge
        if (typeof updateGoldBadges === 'function') updateGoldBadges();
        if (typeof updateGuildBadges === 'function') updateGuildBadges();
        showGameMessage('Ricompensa ricevuta', `Hai ottenuto ${formatGold(Number(claimLocal.gold||0))} oro dalla Miniera.`);

        // Nota: qui NON applichiamo bonus gilda/pers.
        renderMineArea();
      };
      return;
    }

    if (activeLocal && activeLocal.gid === gid) {
      // Run attiva: mostra countdown
      const remainMs = Math.max(0, Number(activeLocal.endAt || 0) - Date.now());
      area.innerHTML = `
        <div id="g-mine-active-box">
          <div><strong>Scavo in corso</strong></div>
          <div>Rimane: <span id="g-mine-countdown">${msToMMSS(remainMs)}</span></div>
          <div class="muted">Mentre sei in miniera non puoi fare missioni o sfide. Non puoi uscire prima della fine.</div>
        </div>
      `;
      startGuildMineTick();
      return;
    }

    // Se qui, non attivo e non claimable ‚Üí mostra i 3 pulsanti (60 / 120 / 180 minuti)
    area.innerHTML = `
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
        <button class="magic-button" id="g-mine-60">Entra in miniera 60 minuti</button>
        <button class="magic-button" id="g-mine-120">Entra in miniera 120 minuti</button>
        <button class="magic-button" id="g-mine-180">Entra in miniera 180 minuti</button>
      </div>
    `;

    // wiring start
    document.getElementById('g-mine-60')?.addEventListener('click', ()=> attemptStartMine(gid, 60));
    document.getElementById('g-mine-120')?.addEventListener('click', ()=> attemptStartMine(gid, 120));
    document.getElementById('g-mine-180')?.addEventListener('click', ()=> attemptStartMine(gid, 180));
  }

  renderMineArea();

  // --- Helper: tenta di avviare (3 volte al giorno limit) ---
  function attemptStartMine(gid, minutes) {
    // controllo: numero di ingressi oggi (key per giorno)
    const todayKey = (new Date()).toISOString().slice(0,10); // 'YYYY-MM-DD'
    const key = `guildMine_entries_${todayKey}`;
    const map = userStore.get(key) || {}; // { gid: count }
    const count = Number(map[gid] || 0);
    if (count >= 3) {
      showGameMessage('Limite giornaliero raggiunto', 'Puoi entrare in Miniera solo 3 volte al giorno.');
      return;
    }

    // controllo conflitti: non puoi iniziare missioni/sfide durante la run ‚Äî enforce via flag semplice
    // se esiste 'missionActive' interrompi
    const missionActive = userStore.get('missionActive') || null;
    if (missionActive) {
      showGameMessage('Impossibile entrare', 'Non puoi entrare in miniera mentre una missione √® attiva.');
      return;
    }

    // conferma
    const txt = `Confermi di entrare nella Miniera della Gilda per ${minutes} minuti?`;
    if (typeof showConfirmDialog === 'function') {
      showConfirmDialog({ title: 'Conferma entrata', text: txt, okText: 'Entra', onConfirm: ()=> startGuildMine(gid, minutes) });
    } else {
      if (confirm(txt)) startGuildMine(gid, minutes);
    }
  }

  // Avvia il tick se necessario
  function startGuildMineTick() {
    if (guildMineTimer) { clearInterval(guildMineTimer); guildMineTimer = null; }
    const tick = () => {
      const activeNow = userStore.get('guildMine_active') || null;
      const cdEl = document.getElementById('g-mine-countdown');
      if (!activeNow) {
        if (cdEl) cdEl.textContent = '';
        clearInterval(guildMineTimer); guildMineTimer = null;
        renderMineArea();
        return;
      }
      const remain = Number(activeNow.endAt || 0) - Date.now();
      if (cdEl) cdEl.textContent = msToMMSS(remain > 0 ? remain : 0);
      if (remain <= 0) {
        // finito: sposta in claimable
        clearInterval(guildMineTimer); guildMineTimer = null;
        finalizeGuildMine();
      }
    };
    tick();
    guildMineTimer = setInterval(tick, 1000);
  }

  // Avvia la run: scrive userStore.guildMine_active
  function startGuildMine(gid, minutes) {
    const now = Date.now();
    const endAt = now + (minutes * 60 * 1000);
    const obj = { gid, durationMin: minutes, startedAt: now, endAt: endAt, who: currentUser || null };
    userStore.set('guildMine_active', obj);

    // incrementa contatore oggi
    const todayKey = (new Date()).toISOString().slice(0,10);
    const key = `guildMine_entries_${todayKey}`;
    const map = userStore.get(key) || {};
    map[gid] = (Number(map[gid]||0) + 1);
    userStore.set(key, map);

// --- TRIGGER: segna l'entrata nella Miniera per la quest giornaliera ---
try {
  if (typeof incrementQuest === 'function') {
    incrementQuest('q_daily_enter_guild_mine_once', 1);
    // opzionale: rinfresca l'UI delle quest se la funzione esiste
    if (typeof renderQuestsUI === 'function') renderQuestsUI();
    // updateQuestsBadge viene chiamata da incrementQuest ma lasciamo un fallback
    if (typeof updateQuestsBadge === 'function') updateQuestsBadge();
  }
} catch (e) {
  console.warn('Errore incrementQuest (miniera):', e);
}

    // aggiorna UI e avvia ticker
    renderMineArea();
    startGuildMineTick();
    if (typeof updateGuildBadges === 'function') updateGuildBadges();
  }

  // Quando finisce: calcola oro, sposta in claimable
  function finalizeGuildMine() {
    const activeNow = userStore.get('guildMine_active') || null;
    if (!activeNow) { renderMineArea(); return; }

    // calcolo oro: 10 oro/minuto * duration (NON applicare bonus gilda/pers)
    const baseGold = 10 * Number(activeNow.durationMin || 0);
    const claimObj = {
      gid: activeNow.gid,
      durationMin: activeNow.durationMin,
      gold: baseGold,
      finishedAt: Date.now()
    };

    // salva claimable e rimuovi active
    userStore.set('guildMine_claimable', claimObj);
    userStore.remove('guildMine_active');

    // aggiorna badge (mostra pallino) e UI
    if (typeof updateGuildBadges === 'function') updateGuildBadges();
    renderMineArea();
  }

  // se la finestra si apre e c'era una run gi√† attiva, avvia tick (resume)
  if (userStore.get('guildMine_active')) startGuildMineTick();
}
function isInGuildMine() {
  return !!userStore.get('guildMine_active');
}

function renderGuildShopSecretBanner(){
  const box = document.getElementById('gs-secret-banner');
  if (!box) return;

  // pulizia timer
  if (guildShopSecretTimer) { clearInterval(guildShopSecretTimer); guildShopSecretTimer = null; }

  const active = (typeof isGuildSpecialActiveNow === 'function') ? isGuildSpecialActiveNow() : false;
  const s = (typeof getGuildSpecial === 'function') ? getGuildSpecial() : null;

  if (!active || !s){
    box.innerHTML = '';
    return;
  }

  const rem = Math.max(0, Number(s.expires) - Date.now());
  box.innerHTML = `
  <button class="magic-button guild-shop-btn guild-shop-secret-btn" id="gs-secret-btn">
    <div class="label">
      Entra per scoprire l‚Äôoggetto segreto della settimana
      <span id="gs-secret-dot" class="dot${s.seen ? ' hidden' : ''}"></span>
    </div>
    <div class="cost" id="gs-secret-remaining"><strong>Scade tra: ${gs_formatDH(rem)}</strong></div>
  </button>
`;

  const btn = document.getElementById('gs-secret-btn');
if (btn) btn.onclick = openGuildSecretWindow;


  // tick countdown rimanente
  guildShopSecretTimer = setInterval(()=>{
    const st = (typeof getGuildSpecial === 'function') ? getGuildSpecial() : null;
    if (!st) { clearInterval(guildShopSecretTimer); return; }
    const now = Date.now();
    const left = Math.max(0, Number(st.expires) - now);
    const el = document.getElementById('gs-secret-remaining');
    if (el) el.textContent = left>0 ? `Scade tra: ${gs_formatDH(left)}` : 'Scaduto';
    if (left<=0){
      clearInterval(guildShopSecretTimer);
      renderGuildShopSecretBanner(); // sparisce alla scadenza
      if (typeof updateGuildBadges==='function') updateGuildBadges();
    }
  }, 1000);
}

function openGuildSecretDetail(){
  // appena entri, il pallino rosso deve sparire
  if (typeof setGuildSpecialSeen==='function') setGuildSpecialSeen();
  if (typeof updateGuildBadges==='function') updateGuildBadges();

  const wrap = document.getElementById('gs-secret-detail');
  if (!wrap) return;

  const s = (typeof getGuildSpecial==='function') ? getGuildSpecial() : null;
  if (!s) { wrap.innerHTML = ''; return; }

  const item = s.item || {};
  const catLabel = { weapon:'Arma', armor:'Armatura', magic:'Magia', creature:'Creatura' }[item.category] || 'Oggetto';
  const rareLabel = { rara:'Rara', epica:'Epica', leggendaria:'Leggendaria', mitica:'Mitica' }[item.rarity] || 'Rara';
  const price = Number(item.price||0);

  wrap.innerHTML = `
    <div class="traits-block">
      <div class="title">Oggetto segreto</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div><strong>Categoria:</strong> ${catLabel}</div>
        <div><strong>Rarit√†:</strong> ${rareLabel}</div>
        <div><strong>Nome:</strong> ${item.name}</div>
        <div><strong>Prezzo:</strong> ${formatGold(price)} monete d'oro</div>
        <div style="margin-top:10px;">
          <button class="magic-button" id="gs-secret-buy" ${s.bought ? 'disabled':''}>${s.bought ? 'Gi√† acquistato' : 'Acquista'}</button>
        </div>
      </div>
    </div>
  `;

  const buyBtn = document.getElementById('gs-secret-buy');
  if (buyBtn && !s.bought){
    buyBtn.onclick = buyGuildSpecialItem;
  }
}

function buyGuildSpecialItem(){
  const s = (typeof getGuildSpecial==='function') ? getGuildSpecial() : null;
  if (!s) return;
  if (!(typeof isGuildSpecialActiveNow==='function' && isGuildSpecialActiveNow())) {
    showGameMessage('Offerta scaduta', 'L‚Äôoggetto segreto non √® pi√π disponibile.');
    renderGuildShopSecretBanner();
    return;
    }
  if (s.bought){
    showGameMessage('Gi√† acquistato', 'Hai gi√† acquistato questo oggetto segreto.');
    return;
  }

  const item = s.item || {};
  const price = Number(item.price||0);
  const gold = getNum('gold', 0);
  if (gold < price){
    showGameMessage('Oro insufficiente', `Ti servono <strong>${formatGold(price)}</strong> monete d'oro.`);
    return;
  }

    // conferma
  const txt = `Confermi l‚Äôacquisto di <strong>${item.name}</strong> per <strong>${formatGold(price)}</strong> monete d'oro?`;
  if (typeof showConfirmDialog === 'function'){
    showConfirmDialog({
      title:'Conferma acquisto segreto',
      text:txt, okText:'Conferma', cancelText:'Annulla',
      onConfirm: ()=> finalizeBuyGuildSpecialItem()
    });
  } else {
    if (confirm(`Acquista ${item.name} a ${formatGold(price)} monete d'oro?`)) finalizeBuyGuildSpecialItem();
  }

}

function finalizeBuyGuildSpecialItem(){
  const s = (typeof getGuildSpecial==='function') ? getGuildSpecial() : null;
  if (!s) return;
  const item = s.item || {};
  const price = Number(item.price||0);

  // scala oro
  addNum('gold', -price);

  // accredita inventario in base alla categoria
  if (item.category === 'weapon'){
    const owned = userStore.get('weapons') || {};
    const key = item.name;
    owned[key] = (Number(owned[key]||0) + 1);
    userStore.set('weapons', owned);
  } else if (item.category === 'armor'){
    const arr = userStore.get('armors') || [];
    if (!arr.includes(item.name)) arr.push(item.name);
    userStore.set('armors', arr);
  } else if (item.category === 'magic'){
    const arr = userStore.get('magics') || [];
    if (!arr.includes(item.name)) arr.push(item.name);
    userStore.set('magics', arr);
  } else if (item.category === 'creature'){
    const arr = userStore.get('creatures') || [];
    if (!arr.includes(item.name)) arr.push(item.name);
    userStore.set('creatures', arr);
  }

  if (typeof setGuildSpecialBought==='function') setGuildSpecialBought();

  // UI
  const goldNow = getNum('gold', 0);
  const goldLine = document.getElementById('guild-shop-gold');
  if (goldLine) goldLine.textContent = formatGold(goldNow);
  if (typeof updateGoldBadges==='function') updateGoldBadges();

  openGuildSecretDetail(); // rinfresca il dettaglio (disabilita bottone)
  showGameMessage('Acquisto effettuato', `Hai ottenuto <strong>${item.name}</strong>!`);
// ‚ûï Quest giornaliera: acquisto al negozio della gilda
if (typeof incrementQuest === 'function') incrementQuest('q_daily_guild_shop_buy_1', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

}

// pulizia timer quando si cambia vista
window.addEventListener('hashchange', ()=>{ if (guildShopSecretTimer) clearInterval(guildShopSecretTimer); });

function renderGuildShopList(){
  const list = document.getElementById('guild-shop-list');
  if (!list) return;

  list.innerHTML = '';
  GUILD_SHOP_ITEMS.forEach(item=>{
    const rem = (typeof getGuildShopRemaining==='function') ? getGuildShopRemaining(item.storageKey) : 0;
    const disabled = rem > 0;

    const btn = document.createElement('button');
    btn.className = 'magic-button guild-shop-btn';
    btn.id = 'gs-btn-' + item.id;
    btn.disabled = !!disabled;
    btn.dataset.itemId = item.id;

    const label = document.createElement('div');
    label.className = 'label';
    label.innerHTML = `<div>${item.label}</div>`;


    const cost = document.createElement('div');
    cost.className = 'cost';
    cost.id = 'gs-cost-' + item.id;
    cost.textContent = disabled ? `Disponibile tra: ${gs_formatDH(rem)}` : `${formatGold(item.cost)} üí∞`;

    btn.appendChild(label);
    btn.appendChild(cost);

    btn.onclick = ()=> tryBuyGuildShopItem(item.id);
    list.appendChild(btn);
  });
}
function renderGuildShopBonusList(){
  const list = document.getElementById('guild-shop-bonus-list');
  if (!list) return;
  list.innerHTML = '';

  GUILD_SHOP_BONUS_PACKS.forEach(pack=>{
    const btn = document.createElement('button');
    btn.className = 'magic-button guild-shop-btn';
    btn.id = 'gs-bonus-' + pack.id;

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = pack.label;

    const cost = document.createElement('div');
    cost.className = 'cost';
    cost.textContent = `${formatGold(pack.cost)} üí∞`;

    btn.appendChild(label);
    btn.appendChild(cost);
    btn.onclick = ()=> tryBuyGuildBonusPack(pack.id);

    list.appendChild(btn);
  });
}

function tryBuyGuildBonusPack(packId){
  const pack = GUILD_SHOP_BONUS_PACKS.find(x=>x.id===packId);
  if (!pack) return;

  const gold = getNum('gold', 0);
  if (gold < pack.cost){
    showGameMessage('Oro insufficiente', `Ti servono <strong>${formatGold(pack.cost)}</strong> monete d'oro.`);
    return;
  }

  const txt = `Confermi l‚Äôacquisto di <strong>${pack.label}</strong> per <strong>${formatGold(pack.cost)}</strong> monete d'oro?`;
  if (typeof showConfirmDialog === 'function'){
    showConfirmDialog({
      title: 'Conferma acquisto',
      text: txt,
      okText: 'Conferma',
      cancelText: 'Annulla',
      onConfirm: ()=> finalizeGuildBonusPurchase(pack)
    });
  } else {
    if (confirm(`${pack.label} ‚Äî costo ${formatGold(pack.cost)} oro. Confermi?`)){
      finalizeGuildBonusPurchase(pack);
    }
  }
}

function finalizeGuildBonusPurchase(pack){
  // scala oro
  addNum('gold', -pack.cost);

  // estende il bonus personale
  if (typeof extendPersonalBonus === 'function'){
    extendPersonalBonus(pack.type, pack.durationMs);
  }

  // UI refresh
  if (typeof updateGoldBadges==='function') updateGoldBadges();
  const goldLine = document.getElementById('guild-shop-gold');
  if (goldLine) goldLine.textContent = formatGold(getNum('gold',0));
  showGameMessage('Acquisto effettuato', `Hai attivato <strong>${pack.label}</strong>. Le durate si sommano se ricompri lo stesso tipo.`);
// ‚ûï Quest giornaliera: acquisto al negozio della gilda
if (typeof incrementQuest === 'function') incrementQuest('q_daily_guild_shop_buy_1', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

}

function startGuildShopTick(){
  if (guildShopTimer) clearInterval(guildShopTimer);
  const tick = ()=>{
    GUILD_SHOP_ITEMS.forEach(item=>{
      const rem = (typeof getGuildShopRemaining==='function') ? getGuildShopRemaining(item.storageKey) : 0;
      const costEl = document.getElementById('gs-cost-' + item.id);
      const btnEl  = document.getElementById('gs-btn-' + item.id);
      if (!costEl || !btnEl) return;

      if (rem > 0){
        costEl.textContent = `Disponibile tra: ${gs_formatDH(rem)}`;
        btnEl.disabled = true;
      } else {
        costEl.textContent = `${formatGold(item.cost)} üí∞`;
        btnEl.disabled = false;
      }
    });
  };
  tick();
  guildShopTimer = setInterval(tick, 1000);
}

function tryBuyGuildShopItem(itemId){
  const item = GUILD_SHOP_ITEMS.find(x=>x.id===itemId);
  if (!item) return;

  // blocca se in cooldown
  const rem = (typeof getGuildShopRemaining==='function') ? getGuildShopRemaining(item.storageKey) : 0;
  if (rem > 0) return;

  const gold = getNum('gold', 0);
  if (gold < item.cost){
    showGameMessage('Oro insufficiente', `Ti servono <strong>${formatGold(item.cost)}</strong> monete d'oro.`);
    return;
  }

  const txt = `Confermi l‚Äôacquisto di <strong>${item.label}</strong> per <strong>${formatGold(item.cost)}</strong> monete d'oro?`;
  if (typeof showConfirmDialog === 'function'){
    showConfirmDialog({
      title: 'Conferma acquisto',
      text: txt,
      okText: 'Conferma',
      cancelText: 'Annulla',
      onConfirm: ()=> finalizeGuildShopPurchase(item)
    });
  } else {
    if (confirm(item.label + ' ‚Äî costo ' + formatGold(item.cost) + ' oro. Confermi?')){
      finalizeGuildShopPurchase(item);
    }
  }
}

function finalizeGuildShopPurchase(item){
  // spesa oro
  addNum('gold', -item.cost);

  // premio
  if (item.award?.type === 'key' && typeof addKey==='function'){
    addKey(item.keyId, item.award.qty||1);
  } else if (item.award?.type === 'dust' && typeof addArcaneDust==='function'){
    addArcaneDust(item.award.qty||0);
  }

  // salva cooldown centralizzato
  if (typeof setGuildShopLastPurchase==='function') setGuildShopLastPurchase(item.storageKey);

  // UI refresh
  if (typeof updateGoldBadges==='function') updateGoldBadges();
  renderGuildShopList();
  showGameMessage('Acquisto effettuato', `Hai acquistato <strong>${item.label}</strong>.`);
// ‚ûï Quest giornaliera: acquisto al negozio della gilda
if (typeof incrementQuest === 'function') incrementQuest('q_daily_guild_shop_buy_1', 1);
if (typeof renderQuestsUI === 'function') renderQuestsUI();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

}

// Chiudi il timer quando navighi via
window.addEventListener('hashchange', ()=>{ if (guildShopTimer) clearInterval(guildShopTimer); });


// Renderer SVG per lo stendardo (12 forme + 12 simboli)
function bannerSVG(cfg){
  const base   = (cfg && cfg.base)   || '#7b3b2a';
  const emblem = (cfg && cfg.emblem) || '#f5d565';
  const sym    = (cfg && cfg.symbol) || 'cerchio';
  const shapeType = (cfg && cfg.shape) || 'rettangolo';

  function baseShape(){
    switch(shapeType){
      case 'cerchio':   return `<circle cx="100" cy="60" r="54" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'ovale':     return `<ellipse cx="100" cy="60" rx="88" ry="50" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'losanga':   return `<path d="M100 6 L194 60 L100 114 L6 60 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'triangolo': return `<path d="M6 6 L6 114 L194 60 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'goccia':    return `<path d="M100 14 C140 14 172 42 172 76 C172 98 146 114 100 114 C54 114 28 98 28 76 C28 42 60 14 100 14 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'scudo':     return `<path d="M30 6 H170 Q188 6 188 24 V72 Q188 102 100 114 Q12 102 12 72 V24 Q12 6 30 6 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'scudetto':  return `<path d="M24 6 H176 V54 Q176 88 100 114 Q24 88 24 54 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'stendardo': return `<path d="M6 6 H194 V96 L100 114 L6 96 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'coda':      return `<path d="M6 6 H194 V114 H122 L100 96 L78 114 H6 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'esagono':   return `<path d="M48 6 H152 L194 60 L152 114 H48 L6 60 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'ottagono':  return `<path d="M52 6 H148 L194 52 V68 L148 114 H52 L6 68 V52 Z" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
      case 'rettangolo':
      default:          return `<rect x="6" y="6" width="188" height="108" rx="12" ry="12" fill="${base}" stroke="#3a2016" stroke-width="4"/>`;
    }
  }

  function symbolShape(){
    switch(sym){
      case 'stella':
        return `<path d="M100 22 L115 60 L156 60 L122 82 L136 120 L100 98 L64 120 L78 82 L44 60 L85 60 Z" fill="${emblem}"/>`;
      case 'diamante':
        return `<path d="M100 24 L168 60 L100 96 L32 60 Z" fill="${emblem}"/>`;
      case 'triangolo':
        return `<path d="M100 30 L132 90 H68 Z" fill="${emblem}"/>`;
      case 'scudo':
        return `<path d="M84 34 H116 V58 Q116 78 100 90 Q84 78 84 58 Z" fill="${emblem}"/>`;
      case 'spade':
        return `<g stroke="${emblem}" stroke-width="6" stroke-linecap="round">
                  <path d="M70 86 L130 34"/><path d="M130 86 L70 34"/>
                </g>
                <g fill="${emblem}">
                  <circle cx="70" cy="86" r="4"/><circle cx="130" cy="86" r="4"/>
                </g>`;
      case 'teschio':
        return `<g fill="${emblem}">
                  <circle cx="100" cy="60" r="20"/><rect x="92" y="74" width="16" height="10" rx="2"/>
                </g>
                <g fill="${base}">
                  <circle cx="92" cy="58" r="4"/><circle cx="108" cy="58" r="4"/>
                  <rect x="96" y="76" width="8" height="2"/>
                </g>`;
      case 'aquila':
        return `<path d="M60 70 Q80 40 100 58 Q120 40 140 70 Q120 68 100 82 Q80 68 60 70 Z" fill="${emblem}"/>`;
      case 'sole':
        return `<g>
                  <circle cx="100" cy="60" r="16" fill="${emblem}"/>
                  <g stroke="${emblem}" stroke-width="6" stroke-linecap="round">
                    <path d="M100 32 V16"/><path d="M100 104 V88"/>
                    <path d="M72 60 H56"/><path d="M144 60 H128"/>
                    <path d="M80 40 L68 28"/><path d="M132 92 L120 80"/>
                    <path d="M80 80 L68 92"/><path d="M132 28 L120 40"/>
                  </g>
                </g>`;
      case 'luna':
        return `<g><circle cx="106" cy="60" r="18" fill="${emblem}"/><circle cx="114" cy="60" r="18" fill="${base}"/></g>`;
      case 'torre':
        return `<g fill="${emblem}">
                  <rect x="86" y="44" width="28" height="38"/>
                  <rect x="82" y="40" width="36" height="8"/>
                  <rect x="82" y="40" width="6" height="8"/>
                  <rect x="98" y="40" width="6" height="8"/>
                  <rect x="112" y="40" width="6" height="8"/>
                </g>`;
      case 'corona':
        return `<path d="M82 84 H118 L112 66 L100 74 L88 66 Z" fill="${emblem}"/>`;
      case 'cerchio':
      default:
        return `<circle cx="100" cy="60" r="28" fill="${emblem}"/>`;
    }
  }

  return `<svg viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
            ${baseShape()}
            ${symbolShape()}
          </svg>`;
}

// === Lista Gilde =============================================================

function renderGuildList({page=1, q=''}={}){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  // Salva stato corrente per tornare alla stessa pagina dopo la vista membri
  window._guildListState = { page, q };

  const guildsMap = (typeof getGuilds === 'function') ? getGuilds() : {};
  let arr = Object.values(guildsMap);

  // filtro ricerca
  const qq = String(q||'').trim().toLowerCase();
  if (qq) {
    arr = arr.filter(g => (g.name||'').toLowerCase().includes(qq) || (g.tag||'').toLowerCase().includes(qq));
  }

  // ‚ÄúClassifica‚Äù: per ora ordina per #membri (desc)
  arr.sort((a,b) => (countGuildMembers(b.id) - countGuildMembers(a.id)));

  // paginazione 6
  const perPage = 6;
  const total = arr.length;
  const totalPages = Math.max(1, Math.ceil(total/perPage));
  const cur = Math.min(Math.max(1, page), totalPages);
  const start = (cur-1)*perPage;
  const pageRows = arr.slice(start, start+perPage);

  const inGuild = !!(typeof getUserGuildId==='function' && getUserGuildId());

  // nav condizionale
  const navHtml = (totalPages > 1) ? `
    <div style="display:flex; gap:8px; justify-content:space-between; margin-top:8px;">
      ${cur>1 ? `<button class="magic-button" id="g-prev">Pagina precedente</button>` : `<span></span>`}
      ${cur<totalPages ? `<button class="magic-button" id="g-next">Pagina successiva</button>` : `<span></span>`}
    </div>
  ` : '';

  body.innerHTML = `
    <p style="margin-bottom:8px;">
      <button class="mini-button mini-button--dark" id="g-back2">‚Üê Indietro</button>
      &nbsp;&nbsp;<input id="g-search" placeholder="Cerca per nome o TAG" style="width:260px">
    </p>

    <div class="traits-block">
      <div class="title">Lista Gilde</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        ${
          pageRows.length ? pageRows.map(g=>{
            const mem = countGuildMembers(g.id);
            const limit = g.limit || GUILD_MEMBER_LIMIT;
            const privacy = (g.privacy === 'invite') ? 'Su invito' : 'Aperta';
            const canJoin = !inGuild && mem < limit;
            const btnLabel = (g.privacy === 'invite') ? 'Richiedi accesso' : 'Unisciti';
// --- icona relazione (alleanza/guerra) per la card gilda ---
const myGid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
let relationHtml = '';
try {
  if (myGid && typeof areAllied === 'function' && typeof atWar === 'function') {
    if (areAllied(myGid, g.id)) {
  relationHtml = `<div style="text-align:right; margin-top:6px;">
    <span class="ally-icon" title="Alleanza" style="font-size:1.35em; line-height:1;">üïäÔ∏è</span>
  </div>`;
} else if (atWar(myGid, g.id)) {
  relationHtml = `<div style="text-align:right; margin-top:6px;">
    <span class="war-icon" title="Guerra" style="font-size:1.35em; line-height:1;">‚öîÔ∏è</span>
  </div>`;
}
  }
} catch(_) {}

            return `
              <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; border:1px solid #6b4226; padding:6px 8px; border-radius:10px; background:#f6ecd1;">
                <div style="display:flex; gap:10px; align-items:center;">
                  <div class="guild-banner" style="width:84px; height:50px;">${bannerSVG(g.banner||{})}</div>
                  <div>
                    <div><strong>${g.name}</strong> [${g.tag}]</div>
                    <div class="muted">
  <button class="linklike" data-members="${g.id}" title="Vedi membri"><u>Dettaglio</u>:</button>
  ${mem}/${limit}
  &nbsp;‚Ä¢&nbsp; Privacy: ${privacy}
</div>

                  </div>
                </div>
                ${inGuild ? '' : `
  <div>
    <button class="magic-button guild-mini" data-join="${g.id}" ${canJoin ? '' : 'disabled'}>${btnLabel}</button>
  </div>
`}
${relationHtml}
              </div>
            `;
          }).join('') : `<div class="muted">Nessuna gilda trovata.</div>`
        }
      </div>
    </div>

    ${navHtml}
  `;

  // wire
  const bk = document.getElementById('g-back2');
  if (bk) bk.onclick = () => {
  const hasGuild = (typeof getUserGuildId === 'function' && getUserGuildId());
  hasGuild ? renderMyGuild() : renderGuildHub();
};


  const s = document.getElementById('g-search');
  if (s){
    s.value = q||'';
    s.oninput = ()=>renderGuildList({page:1, q:s.value});
    // mantieni focus e cursore dopo il re-render
    s.focus();
    const L = s.value.length; try{ s.setSelectionRange(L, L); }catch(e){}
  }

  const prev = document.getElementById('g-prev');
  if (prev) prev.addEventListener('click', ()=>renderGuildList({page:cur-1, q:s?.value||''}));
  const next = document.getElementById('g-next');
  if (next) next.addEventListener('click', ()=>renderGuildList({page:cur+1, q:s?.value||''}));

  // join / request
  body.querySelectorAll('[data-join]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const gid = btn.getAttribute('data-join');
      const g = (typeof getGuilds==='function' ? getGuilds() : {})[gid];
      if (!g) return;

      if (typeof getUserGuildId==='function' && getUserGuildId()){ return; }

      const mem = countGuildMembers(gid);
      const limit = g.limit || GUILD_MEMBER_LIMIT;
      if (mem >= limit){ alert('La gilda √® piena.'); return; }

      if (g.privacy === 'invite'){
        // richiesta al leader
        const leader = g.owner;
        const me = (typeof currentUser==='string' && currentUser) ? currentUser : 'giocatore';
        const msg = {
  id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
  title: 'Richiesta accesso gilda',
  body: `Il giocatore ${me} ha richiesto di entrare nella gilda "${g.name}" [${g.tag}].`,
  type: 'guild_request',      // <‚Äî NUOVO: tipo messaggio
  gid: gid,                   // <‚Äî id gilda
  gname: g.name,              // <‚Äî nome gilda
  gtag: g.tag,                // <‚Äî tag gilda
  applicant: me,              // <‚Äî chi richiede
  when: Date.now(),
  unread: true
};

        if (typeof deliverMessageToUser==='function') deliverMessageToUser(leader, msg);
        if (typeof showGameMessage==='function') showGameMessage('Richiesta inviata', 'Il Capogilda ricever√† una notifica.');
      } else {
        // gilda aperta ‚Üí entra subito
        if (typeof addGuildMember==='function') addGuildMember(gid, currentUser, 'member');
if (typeof setUserGuildId==='function') setUserGuildId(gid);

// ‚úÖ Quest principali ‚Äì step "Crea o entra in una gilda"
if (typeof markMainGuildJoinCompletedIfNeeded === 'function') markMainGuildJoinCompletedIfNeeded();
if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

if (typeof showGameMessage==='function') showGameMessage('Sei entrato in gilda', `Benvenuto in <strong>${g.name} [${g.tag}]</strong>.`);

        renderMyGuild();
      }
    });
  });

  // click su "Membri" ‚Üí vista membri di quella gilda (no popup)
  body.querySelectorAll('[data-members]').forEach(el=>{
  el.addEventListener('click', ()=>{
    const gid = el.getAttribute('data-members');
    const state = window._guildListState || {page:cur, q:s?.value||''};
    // üîπ segna che arrivo dalla Lista gilde
    window._gm_back_origin = 'guild_list';
    if (typeof renderGuildMembersView === 'function') {
      renderGuildMembersView(gid, state.page, state.q);
    } else {
      if (typeof showGameMessage==='function') showGameMessage('Membri', 'Vista membri non disponibile.');
    }
  });
});
}

// Vista Membri in stile "Sala degli Eroi"
function renderGuildMembersView(gid, backPage=1, backQuery=''){
  // 1) recupero dati gilda + membri
  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  const members = (typeof getGuildMembers==='function') ? getGuildMembers(gid) : [];

  // 2) riferimenti DOM della finestra
  const screenGuild   = document.getElementById('guild-screen');
  const screenMembers = document.getElementById('guild-members-view');
  const titleEl = document.getElementById('gm-title');
  const bodyEl  = document.getElementById('gm-body');
  const search  = document.getElementById('gm-search');
  const diploBox = document.getElementById('gm-diplobox');

  // ‚¨áÔ∏è nuovi bottoni back
  const backGuildBtn = document.getElementById('gm-back-guild'); // in alto: torna al men√π gilda
  const backMainBtn  = document.getElementById('gm-back-main');  // in basso: torna al men√π principale

  if (!screenMembers || !titleEl || !bodyEl) return;

  // 3) titolo dinamico
  const title = g ? `Membri di ${g.name} [${g.tag}]` : 'Membri di Gilda';
  titleEl.textContent = title;

// --- Stato diplomazia della gilda (alleanze/guerre) ---
function renderDiplobox() {
  if (!diploBox) return;

  try {
    const allGuilds = (typeof getGuilds==='function') ? (getGuilds() || {}) : {};
    const allies = (typeof listAllies==='function') ? (listAllies(gid) || []) : [];
    const wars   = (typeof listWars==='function')   ? (listWars(gid)   || []) : [];

    const fmt = (id) => {
      const gg = allGuilds[id] || {};
      const name = gg.name ? `${gg.name}` : `Gilda ${id}`;
      const tag  = gg.tag ? ` [${gg.tag}]` : '';
      return `<span class="badge" style="display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border-radius:999px;border:1px solid #d0caa9;">${name}${tag}</span>`;
    };

    const alliesRow = allies.length
      ? `<div><strong>Alleanze:</strong> ${allies.map(fmt).join(' ')}</div>`
      : '';
    const warsRow = wars.length
      ? `<div style="margin-top:4px;"><strong>Guerre:</strong> ${wars.map(id => 
          `<span class="badge" style="display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border-radius:999px;border:1px solid #d0caa9;">
             <span class="war-icon" title="Guerra">‚öîÔ∏è</span> ${fmt(id).replace(/^<span class="badge"[^>]*>|<\/span>$/g,'')}
           </span>`).join(' ')}</div>`
      : '';

    const html = `${alliesRow}${warsRow}`;
    diploBox.innerHTML = html;
    diploBox.style.display = html ? '' : 'none';
  } catch(_) {
    diploBox.style.display = 'none';
  }
}

// iniziale
renderDiplobox();

// aggiornamenti automatici: eventi emessi da storage.js
function _bindDiploLiveUpdates() {
  if (!diploBox || diploBox._bound) return;
  diploBox._bound = true;

  // eventi custom (stessa tab)
  window.addEventListener('diplomacy:updated', renderDiplobox);
  window.addEventListener('wars:updated', renderDiplobox);

  // cross-tab: ascolta "storage" (storage.js scrive mitharia_signal)
  window.addEventListener('storage', (e)=>{
    if (e && e.key === 'mitharia_signal' && /^(diplomacy|wars):/.test(String(e.newValue||''))) {
      renderDiplobox();
    }
  });
}
_bindDiploLiveUpdates();

  // 4) funzione renderer delle righe (supporta filtro testo)
  function renderRows(q = '') {
    const qq = String(q || '').trim().toLowerCase();
    const filtered = qq
      ? members.filter(m => (m.user || '').toLowerCase().includes(qq))
      : members.slice();

    // directory eroi per arricchire Classe/Livello/Punti e ottenere l'id profilo
    const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];

    bodyEl.innerHTML = filtered.map(m => {
      const hero = dir.find(h => (h.name || '') === m.user) || {};
      const tag = g ? `[${g.tag}]` : (hero.tag ? `[${hero.tag}]` : '');
      const name = m.user || (hero.name || '');
      const classe = hero.classe || '‚Äî';
      const lvl = (typeof getHeroLevelOfUser === 'function')
        ? (getHeroLevelOfUser(m.user) ?? (hero.level ?? '‚Äî'))
        : (hero.level ?? '‚Äî');
      const points = (hero.points != null) ? Number(hero.points) : '‚Äî';

      // link al profilo se ho l'id in directory
      const nameCell = hero.id
        ? `<button class="link-button" onclick="openHeroProfile('${hero.id}')">${escapeHtml(name)}</button>`
        : escapeHtml(name);

      return `
        <tr>
          <td>${escapeHtml(tag)}</td>
          <td>${nameCell}</td>
          <td>${escapeHtml(classe)}</td>
          <td>${lvl}</td>
          <td>${points}</td>
        </tr>`;
    }).join('') || `<tr><td colspan="5" class="muted">Nessun membro.</td></tr>`;
  }

  // 5) wiring ricerca live
  if (search){
    search.value = '';
    search.oninput = () => renderRows(search.value);
  }

  // 6) mostra finestra membri e nascondi schermata gilda
  if (screenGuild)   screenGuild.classList.add('hidden');
  screenMembers.classList.remove('hidden');

  // 7) prima renderizzazione
  renderRows();

  // 8) back (alto) ‚Üí torna alla schermata di origine
if (backGuildBtn){
  backGuildBtn.onclick = () => {
    screenMembers.classList.add('hidden');
    if (screenGuild) screenGuild.classList.remove('hidden');

    const origin = window._gm_back_origin || 'my_guild';

    if (origin === 'guild_list' && typeof renderGuildList === 'function') {
      renderGuildList({ page: backPage || 1, q: backQuery || '' });
    } else if (typeof renderMyGuild === 'function') {
      try { renderMyGuild(); } catch(e){}
    } else if (typeof renderGuildList === 'function') {
      // fallback finale
      renderGuildList({ page: 1, q: '' });
    }

    // opzionale: pulizia flag
    // window._gm_back_origin = null;
  };
}

  // 9) back (basso) ‚Üí men√π principale
  if (backMainBtn){
    backMainBtn.onclick = () => {
      screenMembers.classList.add('hidden');
      if (screenGuild) screenGuild.classList.add('hidden');
      document.getElementById('menu')?.classList.remove('hidden');
    };
  }
}

// === La mia Gilda ============================================================

function renderMyGuild(){
  const body = document.getElementById('guild-screen-body');
  if (!body) return;

  const gid = (typeof getUserGuildId==='function') ? getUserGuildId() : null;
  if (!gid){ renderGuildHub(); return; }

  const all = (typeof getGuilds==='function') ? getGuilds() : {};
  const g = all[gid];
  if (!g){ if (typeof setUserGuildId==='function') setUserGuildId(null); renderGuildHub(); return; }

  const members = (typeof getGuildMembers==='function') ? getGuildMembers(gid) : [];
  const me = (typeof currentUser==='string' && currentUser) ? currentUser : null;
  const myRole = (typeof getGuildMemberRole==='function') ? getGuildMemberRole(gid, me) : null;
  // Calcolo Rank gilda (per punti totali dei membri)
let guildRankText = '‚Äî';
try {
  const allGuilds = (typeof getGuilds === 'function') ? (getGuilds() || {}) : {};
  const ids = Object.keys(allGuilds);
  const rows = ids.map(id => {
    const gg = allGuilds[id] || {};
    const pts = (typeof computeGuildPoints === 'function') ? computeGuildPoints(id) : 0;
    return { id, name: String(gg.name || ''), points: Number(pts) || 0 };
  });
  // Ordina per punti ‚Üì poi nome ‚Üë (stessa regola della classifica)
  rows.sort((a,b) => (b.points - a.points) || a.name.localeCompare(b.name));
  const pos = rows.findIndex(r => r.id === gid);
  if (pos >= 0) guildRankText = String(pos + 1);
} catch(_) {}
 
  const isLeader = (myRole === 'leader');

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">La mia Gilda</div>
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div style="display:flex; gap:12px; align-items:center;">
          <div class="guild-banner">${bannerSVG(g.banner||{})}</div>
          <div>
            <div style="font-size:18px;"><strong>${g.name}</strong> [${g.tag}]</div>
	    <div class="muted">Rank: #${guildRankText}</div>
            <div class="muted">Fondatore: ${g.owner}</div>
            <div class="muted">Privacy: ${(g.privacy==='invite'?'Su invito':'Aperta')}</div>
            ${isLeader ? `<div id="g-gold-line"><strong>Oro:</strong> ${formatGold((typeof getGuildGold==='function') ? getGuildGold(gid) : (Number(g.gold)||0))} monete d'oro</div>` : ``}
          </div>
        </div>
      </div>
    </div>

    <div class="traits-block">
      <div class="guild-actions-grid">
        <button class="magic-button" id="g-members-btn">Membri</button>
        <button class="magic-button" id="g-buildings-btn">Edifici</button>
        <button class="magic-button" id="g-diplomacy-btn">Diplomazia</button>
        <button class="magic-button" id="g-donate-btn">Donazioni</button>
        <button class="magic-button" id="g-shop-btn">Negozio della gilda <span id="g-shop-badge" class="dot hidden"></span></button>
        ${isLeader ? `<button class="magic-button" id="g-invite-btn">Invita</button>` : ``}
<button class="magic-button" id="g-list-btn">Lista Gilde</button>
<button class="magic-button" id="g-mine-btn" style="position: relative;">
  Miniera della Gilda
  <span id="g-mine-dot" class="dot"></span>
</button>

        <button class="magic-button" id="g-settings-btn">Impostazioni</button>
      </div>
    </div>

    <div id="g-subview"></div>
  `;

  // Membri
const membersBtn = document.getElementById('g-members-btn');
if (membersBtn) membersBtn.onclick = () => {
  // üîπ segna che arrivo dal menu "La mia Gilda"
  window._gm_back_origin = 'my_guild';
  const backState = window._guildListState || { page: 1, q: '' };
  renderGuildMembersView(gid, backState.page, backState.q);
};

   // Edifici
   const buildingsBtn = document.getElementById('g-buildings-btn');
   if (buildingsBtn) buildingsBtn.onclick = ()=>{
     renderGuildBuildings(gid);
   };

// Donazioni (tutti i membri possono donare; solo il leader vede il saldo gilda)
const donateBtn = document.getElementById('g-donate-btn');
if (donateBtn) donateBtn.onclick = ()=>{
  openGuildDonations(gid);   // ‚¨ÖÔ∏è chiama la funzione riutilizzabile
};

// Negozio della gilda (chiavi & polvere - cooldown personale)
const shopBtn = document.getElementById('g-shop-btn');
if (shopBtn) shopBtn.onclick = ()=>{
  openGuildShopWindow(gid);   // ‚Üê useremo la ‚Äúnuova finestra‚Äù in stile edifici
};

// Diplomazia
const dipBtn = document.getElementById('g-diplomacy-btn');
if (dipBtn) dipBtn.onclick = ()=>{ if (typeof renderGuildDiplomacy==='function') renderGuildDiplomacy(gid); };

  // Invita (MVP: invio messaggio all‚Äôutente indicato)
  const invBtn = document.getElementById('g-invite-btn');
  if (invBtn){
    invBtn.onclick = ()=>{
      const sub = document.getElementById('g-subview');
      sub.innerHTML = `
        <div class="traits-block">
          <div class="title">Invita un giocatore</div>
          <div class="traits-grid" style="grid-template-columns:1fr;">
            <label>Username <input id="g-invite-user" style="width:260px"></label>
            <button class="magic-button magic-button--slim" id="g-invite-send">Invia invito</button>
            <div class="muted">MVP: l‚Äôinvito invia un messaggio all‚Äôutente indicato.</div>
          </div>
        </div>
      `;
      const send = document.getElementById('g-invite-send');
      if (send) send.onclick = ()=>{
        const to = String(document.getElementById('g-invite-user').value||'').trim();
        if (!to){ alert('Inserisci uno username.'); return; }
        const msg = {
  id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
  type: 'guild_invite',
  gid: g.id,
  gname: g.name,
  gtag: g.tag,
  inviter: me,
  title: 'Invito alla gilda',
  body: `Il giocatore ${me} ti invita a entrare in "${g.name}" [${g.tag}].`,
  when: Date.now(),
  unread: true
};
deliverMessageToUser(to, msg);
showGameMessage?.('Invito inviato', `Messaggio inviato a <strong>${to}</strong>.`);
      };
    };
  }
const listBtn = document.getElementById('g-list-btn');
if (listBtn) listBtn.onclick = () => {
  // apre la lista gilde in sola lettura (vedi patch 2)
  renderGuildList({ page: 1, q: '' });
};
// wiring Miniera Gilda (aggiungere vicino agli altri wiring per i pulsanti g-*)
const mineBtn = document.getElementById('g-mine-btn');
if (mineBtn && !mineBtn._bound) {
  mineBtn._bound = true;
  mineBtn.addEventListener('click', ()=> {
    const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
    if (!gid) { showGameMessage('Non sei in una gilda', 'Devi essere in una gilda per entrare nella Miniera.'); return; }
    openGuildMineWindow(gid);
  });
}

  // Impostazioni (placeholder ‚Äî password dialog la mettiamo al prossimo step)
  const settingsBtn = document.getElementById('g-settings-btn');
  if (settingsBtn) settingsBtn.onclick = ()=>{
    const sub = document.getElementById('g-subview');
    const membersKick = members.filter(m => m.user !== g.owner);
    sub.innerHTML = `
  <div class="traits-block">
    <div class="title">Impostazioni</div>
    <div class="traits-grid" style="grid-template-columns:1fr;">
      ${!isLeader ? `<button class="magic-button magic-button--slim" id="g-leave">Lascia gilda</button>` : ``}
      ${isLeader ? `<button class="magic-button magic-button--slim" id="g-edit">Modifica Gilda</button>` : ``}
      ${isLeader ? `<button class="magic-button magic-button--slim" id="g-broadcast">Messaggio collettivo</button>` : ``}
      ${isLeader ? `<button class="magic-button magic-button--slim" id="g-disband">Sciogli gilda</button>` : ``}
      ${isLeader ? `
        <div style="display:flex; gap:8px; align-items:center;">
          <select id="g-kick-who" style="min-width:180px;">
            ${members.filter(m=>m.user!==g.owner).map(m=>`<option value="${m.user}">${m.user}</option>`).join('') || `<option disabled>(Nessun membro espellibile)</option>`}
          </select>
          <button class="magic-button magic-button--slim" id="g-kick">Espelli membro</button>
        </div>
      ` : ``}
      ${!isLeader ? `<div class="muted">Per abbandonare la Gilda √® necessario aver trascorso almeno 24 ore in Gilda.</div>` : ``}
    </div>
  </div>
`;



    // Lascia gilda (vincolo 24h)
const leave = document.getElementById('g-leave');
if (leave) leave.onclick = ()=>{
  if (!canLeaveGuildNow(gid, me)){
    const leftMs = guildLeaveRemainingMs(gid, me);
    showGuildCooldownPopup(leftMs); // ‚Üê popup con contatore
    return;
  }
  askConfirm({
    title: 'Lascia gilda',
    text: `Sei sicuro di voler lasciare <strong>${g.name}</strong>?`,
    okText: 'Conferma',
    onConfirm: ()=>{
      if (typeof removeGuildMember==='function') removeGuildMember(gid, me);
      if (typeof setUserGuildId==='function') setUserGuildId(null);
      if (typeof showGameMessage==='function') showGameMessage('Hai lasciato la gilda', 'Puoi sempre unirti o crearne una nuova.');
      renderGuildHub();
    }
  });
};
// Modifica Gilda (leader)
const edit = document.getElementById('g-edit');
if (edit) edit.addEventListener('click', ()=>{
  renderGuildEdit(gid);   // vedi funzione al punto 2
});


    // Sciogli gilda (leader)
    const disband = document.getElementById('g-disband');
    if (disband) disband.addEventListener('click', ()=>{
      askConfirm({
        title: 'Sciogli gilda',
        text: `Vuoi davvero sciogliere <strong>${g.name}</strong>? Questa azione rimuove tutti i membri.`,
        okText: 'Conferma',
        onConfirm: ()=>{
          const all = (typeof getGuilds==='function') ? getGuilds() : {};
          delete all[gid];
          if (typeof setGuilds==='function') setGuilds(all);
          const map = (typeof getGuildMembersMap==='function') ? getGuildMembersMap() : {};
          delete map[gid];
          if (typeof setGuildMembersMap==='function') setGuildMembersMap(map);
          if (typeof getUserGuildId==='function' && getUserGuildId() === gid) setUserGuildId(null);
          if (typeof showGameMessage==='function') showGameMessage('Gilda sciolta', 'La gilda √® stata eliminata.');
          renderGuildHub();
        }
      });
    });

const bcBtn = document.getElementById('g-broadcast');
if (bcBtn){
  bcBtn.style.display = isLeader ? 'inline-block' : 'none'; // sicurezza extra
  bcBtn.onclick = ()=> openGuildBroadcastScreen(gid);
}

    // Espelli membro (leader)
    const kick = document.getElementById('g-kick');
    if (kick) kick.addEventListener('click', ()=>{
      const whoSel = document.getElementById('g-kick-who');
      const who = whoSel ? whoSel.value : '';
      if (!who){ return; }
      askConfirm({
        title: 'Espelli membro',
        text: `Vuoi davvero espellere <strong>${who}</strong>?`,
        okText: 'Conferma',
        onConfirm: ()=>{
  // rimuovi dalla lista membri
  if (typeof removeGuildMember==='function') removeGuildMember(gid, who);

  // üîß azzera subito il flag guildId dell'account espulso (sul device)
  if (typeof forceClearGuildFlagForUser==='function') forceClearGuildFlagForUser(who, gid);

  // üì© (opzionale) notifica all‚Äôutente espulso
  if (typeof deliverMessageToUser==='function') {
    const gname = g?.name || 'la gilda';
    const gtag  = g?.tag  || '';
    deliverMessageToUser(who, {
  id: 'm'+Date.now()+'_'+Math.floor(Math.random()*1e6),
  type: 'guild_notice', // <<<<<<<<<<  NUOVO
  title: 'Sei stato espulso',
  body: `Sei stato rimosso da "${gname}"${gtag?` [${gtag}]`:''}.`,
  when: Date.now(),
  unread: true
});
  }

  // feedback + refresh UI
  if (typeof showGameMessage==='function') showGameMessage('Membro espulso', `${who} √® stato rimosso dalla gilda.`);
  renderMyGuild();
}

      });
    });
  };
if (typeof ensureGuildSpecialForCurrentWeek === 'function') ensureGuildSpecialForCurrentWeek();
  setTimeout(()=>{ 
    if (typeof updateGuildBadges === 'function') updateGuildBadges();
  }, 0);
}


// 24h minimo per lasciare la gilda
function canLeaveGuildNow(gid, username){
  const arr = (typeof getGuildMembers==='function') ? getGuildMembers(gid) : [];
  const m = arr.find(x => x.user === username);
  if (!m || !m.joinedAt) return true;
  const passed = Date.now() - Number(m.joinedAt);
  return passed >= (24*60*60*1000);
}
// Legge una chiave nello storage dell'utente "username"
function _getUserKey(username, key, defVal){
  try{
    const k = (typeof STORAGE_PREFIX==='string'?STORAGE_PREFIX:'mitharia_') + 'u:' + username + ':' + key;
    const raw = localStorage.getItem(k);
    if (raw == null) return defVal;
    const val = JSON.parse(raw);
    return (val==null? defVal : val);
  }catch(e){ return defVal; }
}

// Livello eroe di un utente (default 1 se non presente)
function getHeroLevelOfUser(username){
  const lvl = _getUserKey(username, 'level', 1);
  const n = Number(lvl); 
  return Number.isFinite(n) && n>0 ? n : 1;
}

// Rimuove il flag gilda dall'account di un altro utente (se punta proprio a quel gid)
function forceClearGuildFlagForUser(username, gid){
  try {
    const prefix = (typeof STORAGE_PREFIX === 'string') ? STORAGE_PREFIX : 'mitharia_';
    const k = prefix + 'u:' + username + ':guildId';
    const curr = JSON.parse(localStorage.getItem(k));
    if (curr === gid) localStorage.removeItem(k);
  } catch(e) { /* no-op */ }
}

// Imposta il flag gilda sull'account di un altro utente
function forceSetGuildFlagForUser(username, gid){
  try {
    const prefix = (typeof STORAGE_PREFIX === 'string') ? STORAGE_PREFIX : 'mitharia_';
    const k = prefix + 'u:' + username + ':guildId';
    localStorage.setItem(k, JSON.stringify(gid));
  } catch(e) { /* no-op */ }
}

// ms rimanenti prima di poter lasciare la gilda
function guildLeaveRemainingMs(gid, username){
  const arr = (typeof getGuildMembers==='function') ? getGuildMembers(gid) : [];
  const m = arr.find(x => x.user === username);
  if (!m || !m.joinedAt) return 0;
  const end = Number(m.joinedAt) + 24*60*60*1000;
  return Math.max(0, end - Date.now());
}

// Popup informativo non chiudibile cliccando fuori, con countdown
function showGuildCooldownPopup(remainingMs){
  // crea overlay
  const overlay = document.createElement('div');
  overlay.id = 'guild-cooldown-overlay';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(0,0,0,.55)';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = '9999';

  // crea modal
  const modal = document.createElement('div');
  modal.style.background = '#f6ecd1';
  modal.style.border = '1px solid #6b4226';
  modal.style.borderRadius = '12px';
  modal.style.maxWidth = '520px';
  modal.style.width = '92vw';
  modal.style.boxShadow = '0 8px 24px rgba(0,0,0,.35)';
  modal.style.padding = '14px';

  modal.innerHTML = `
    <div style="font-weight:700; font-size:18px; margin-bottom:6px;">Attenzione</div>
    <div id="guild-cooldown-text" style="text-align:left; line-height:1.4; margin-bottom:12px;">
      Puoi lasciare la gilda solo dopo 24 ore dal tuo ingresso.<br>
      Rimangono <strong id="guild-cooldown-timer">‚Äî:‚Äî:‚Äî</strong>.
    </div>
    <div style="display:flex; justify-content:flex-end;">
      <button id="guild-cooldown-ok" class="magic-button magic-button--slim">OK</button>
    </div>
  `;

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const timerEl = modal.querySelector('#guild-cooldown-timer');
  const okBtn   = modal.querySelector('#guild-cooldown-ok');

  function fmt(ms){
    let s = Math.ceil(ms/1000);
    const h = Math.floor(s/3600); s -= h*3600;
    const m = Math.floor(s/60);   s -= m*60;
    const pad = n => String(n).padStart(2,'0');
    return `${pad(h)}:${pad(m)}:${pad(s)}`;
  }

  let left = Math.max(0, Number(remainingMs)||0);
  if (timerEl) timerEl.textContent = fmt(left);

  const iv = setInterval(()=>{
    left = Math.max(0, left - 1000);
    if (timerEl) timerEl.textContent = fmt(left);
    if (left <= 0){
      clearInterval(iv);
    }
  }, 1000);

  okBtn.addEventListener('click', ()=>{
    clearInterval(iv);
    document.body.removeChild(overlay);
  });
}

// Torna al menu
function backFromCrystalsScreen() {
  document.getElementById('crystals-screen')?.classList.add('hidden');
  document.getElementById('menu')?.classList.remove('hidden');
}

// Disegna il contenuto della pagina (stato + spiegazione)
function renderCrystalsScreen() {
  const body = document.getElementById('crystals-screen-body');
  if (!body) return;

  const parts   = getNum('crystalParts', 0);
  const full    = getNum('crystals', 0);
  const canMake = Math.floor(parts / 3);

  body.innerHTML = `
    <div class="traits-block">
      <div class="traits-grid" style="grid-template-columns:1fr;">
        <div style="font-size:20px; line-height:1.2;"><strong>Frammenti:</strong> ${parts}/3</div>
        <div style="font-size:20px; line-height:1.2;"><strong>Cristalli completi:</strong> <span id="crystals-count-page">${full}</span></div>
      </div>
    </div>

    <div class="crystals-info-box" style="margin-top:10px; text-align:left;">
      <div class="title">Come funziona</div>
      <div>
        <p>Ogni 3 frammenti ‚Üí 1 Cristallo completo.</p>
        <p>Puoi fondere in qualsiasi momento.</p>
        <p>I Cristalli di Potenziamento servono per potenziare le caratteristiche delle tue
        <strong>armi</strong>, <strong>armature</strong> e <strong>magie</strong>.
        Usali con saggezza per aumentare <strong>danno</strong>, <strong>difesa</strong>, <strong>velocit√†</strong>
        e persino sbloccare <strong>effetti extra unici</strong>!</p>
        <p style="margin-top:8px;">
          ${canMake > 0
            ? `Puoi fondere <strong>${canMake}</strong> ${canMake>1?'cristalli':'cristallo'}.`
            : `Non hai ancora abbastanza parti per fondere.`}
        </p>
      </div>
    </div>
  `;

  // Wire pulsanti pagina
  const fuseBtn = document.getElementById('crystals-fuse-btn');
if (fuseBtn) {
  fuseBtn.onclick = () => {
    showFuseCrystalsScreen();
  };
}

  const useBtn = document.getElementById('crystals-use-btn');
  if (useBtn) {
    useBtn.disabled = (full <= 0);
    // üîÅ 2c: apri la *pagina* "Usa Cristalli", non il popup
    useBtn.onclick = showUseCrystalsScreen;
  }
// ‚¨áÔ∏è Attiva lo stato e l'onclick del nuovo pulsante "Ripristina cristalli"
wireResetButtonOnCrystalsScreen();

}

// Espone la funzione se usi handler inline da HTML
window.showCrystalsScreen = showCrystalsScreen;

// ====== Ripristina Cristalli ‚Äì CONFIG ======
const CRYSTAL_RESET_COST = 100000;
// ====== Costi cristalli ======
const CRYSTAL_FUSE_COST = 2000; // oro per ogni cristallo fuso

// Stato locale per il wizard di reset (come "usa cristalli", ma semplificato)
let crystalResetState = {
  category: null,    // 'weapons' | 'armors' | 'magics'
  itemName: null,    // nome completo (inclusa rarit√†)
  page: 1            // (se vuoi paginare l‚Äôelenco)
};

function ensureUpgradeMaps(){
  if (!userStore.get('weaponUp')) userStore.set('weaponUp', {});
  if (!userStore.get('armorUp'))  userStore.set('armorUp', {});
  if (!userStore.get('magicUp'))  userStore.set('magicUp', {});
  if (!userStore.get('weaponExtraProgress')) userStore.set('weaponExtraProgress', {});
}

// Ritorna true se esiste almeno UN oggetto con ‚â•1 cristallo investito
function hasAnyCrystalInvested(){
  ensureUpgradeMaps();
  const wu = userStore.get('weaponUp') || {};
  const au = userStore.get('armorUp')  || {};
  const mu = userStore.get('magicUp')  || {};
  const we = userStore.get('weaponExtraProgress') || {};

  const sumUp = (obj, keys) => Object.values(obj).some(v =>
    (keys || []).reduce((s, k)=> s + (Number(v?.[k])||0), 0) > 0
  );

  const anyW = sumUp(wu, ['Danno','Velocit√†']) || Object.values(we).some(v => Number(v||0) > 0);
  const anyA = sumUp(au, ['Difesa','Resistenza']);
  const anyM = sumUp(mu, ['Danno','Velocit√†']);
  return anyW || anyA || anyM;
}

// Calcola quanti cristalli recuperi da un singolo oggetto
function calcInvestedCrystals(cat, name){
  ensureUpgradeMaps();

  if (cat === 'weapons'){
    const up       = (userStore.get('weaponUp') || {})[name] || {};
    const progMap  = userStore.get('weaponExtraProgress') || {};
    const prog     = Number(progMap[name] || 0);

    // Effetto inciso? (compatibile con chiave nuova e mappa legacy)
    const chosenMap = userStore.get('weaponExtraChosen') || {};
    const engraved  = chosenMap[name] || userStore.get(`weaponExtraEffect_${name}`) || null;

    // I 20 cristalli usati per sbloccare l'Effetto Extra non si recuperano se inciso
    const UNLOCK_COST = 20;
    const extraRecoverable = engraved ? Math.max(0, prog - UNLOCK_COST) : prog;

    return (Number(up.Danno||0) + Number(up.Velocit√†||0) + Number(extraRecoverable)) | 0;

  } else if (cat === 'armors'){
    const up = (userStore.get('armorUp') || {})[name] || {};
    return (Number(up.Difesa||0) + Number(up.Resistenza||0)) | 0;

  } else if (cat === 'magics'){
    const up = (userStore.get('magicUp') || {})[name] || {};
    return (Number(up.Danno||0) + Number(up.Velocit√†||0)) | 0;
  }

  return 0;
}

// Elenco degli oggetti posseduti CON potenziamento ‚â•1 (filtrato per categoria)
function listOwnedWithInvested(cat){
  ensureUpgradeMaps();

  let ownedNames = [];
  if (cat === 'weapons'){
    const inv = userStore.get('weapons') || {};         // {name: qty}
    ownedNames = Object.keys(inv).filter(n => Number(inv[n]||0) > 0);
  } else if (cat === 'armors'){
    ownedNames = userStore.get('armors') || [];         // [name]
  } else if (cat === 'magics'){
    ownedNames = userStore.get('magics') || [];         // [name]
  }

  // Tieni solo quelli con ‚â•1 cristallo investito
  return ownedNames.filter(n => calcInvestedCrystals(cat, n) > 0);
}

// === Navigazione pagina Reset Cristalli ===
function showResetCrystalsScreen(){
  document.getElementById('crystals-screen')?.classList.add('hidden');
  document.getElementById('crystal-reset-screen')?.classList.remove('hidden');

  crystalResetState = { category: null, itemName: null, page: 1 };
  renderCrystalReset();
}

function backFromResetCrystalsScreen(){
  document.getElementById('crystal-reset-screen')?.classList.add('hidden');
  document.getElementById('crystals-screen')?.classList.remove('hidden');
}

// Chiama questa dentro renderCrystalsScreen() per ‚Äúaccendere‚Äù il bottone
function wireResetButtonOnCrystalsScreen(){
  const btn = document.getElementById('crystals-reset-btn');
  if (!btn) return;
  btn.disabled = false;
  btn.onclick = showResetCrystalsScreen;
}

// ====== Render pagina Reset (wizard 3 step come "Usa cristalli") ======
function renderCrystalReset(){
  const body = document.getElementById('crystal-reset-body');
  if (!body) return;

  // STEP 1: scegli categoria
  if (!crystalResetState.category){
    body.innerHTML = `
      <div class="traits-block">
        <div class="title">Seleziona Categoria</div>
        <div class="traits-grid" style="grid-template-columns: 1fr 1fr 1fr;">
          <button class="magic-button" data-cat="weapons">Armi</button>
          <button class="magic-button" data-cat="armors">Armature</button>
          <button class="magic-button" data-cat="magics">Magie</button>
        </div>
      </div>
      <div class="back-button-container" style="margin-top:12px;">
        <button type="button" onclick="backFromResetCrystalsScreen()">Torna indietro</button>
      </div>
    `;
    body.querySelectorAll('[data-cat]').forEach(b=>{
      b.addEventListener('click', ()=>{
        crystalResetState.category = b.getAttribute('data-cat');
        crystalResetState.itemName = null;
        renderCrystalReset();
      });
    });
    return;
  }

  // STEP 2: elenco oggetti potenziati (solo quelli con ‚â•1 cristallo)
if (!crystalResetState.itemName) {
  const cat  = crystalResetState.category;
  const list = listOwnedWithInvested(cat);

  const emptyHtml = `
    <p class="muted">Nessun oggetto di questa categoria ha cristalli da ripristinare.</p>
    <div class="back-button-container" style="margin-top:12px;">
      <button type="button" onclick="crystalResetState.category=null; renderCrystalReset();">Torna indietro</button>
    </div>
  `;

  if (!list.length) {
    body.innerHTML = emptyHtml;
    return;
  }

  // Costruisco i pulsanti con le stesse dimensioni dei bottoni inventario (stili inline)
  var buttonsHtml = '';
  for (var i = 0; i < list.length; i++) {
    var n = list[i];
    var label = n;

    // (2) Se arma, mostra effetto extra inciso tra parentesi
    if (cat === 'weapons') {
      var chosenMap = userStore.get('weaponExtraChosen') || {};
      var engraved  = chosenMap[n] || userStore.get('weaponExtraEffect_' + n);
      if (engraved) {
        label = n + ' (' + engraved + ')';
      }
    }

    buttonsHtml +=
      '<button class="magic-button item-to-reset" data-name="' + n + '"' +
      ' style="padding:6px 10px; font-size:14px; width:100%; margin:4px 0;">' +
      label +
      '</button>';
  }

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">Seleziona ${cat === 'weapons' ? 'arma' : (cat === 'armors' ? 'armatura' : 'magia')}</div>
      <div class="reset-list">
        ${buttonsHtml}
      </div>
    </div>
    <div class="back-button-container" style="margin-top:12px;">
      <button type="button" onclick="crystalResetState.category=null; renderCrystalReset();">Torna indietro</button>
    </div>
  `;

  // Wiring click
  var items = body.querySelectorAll('.item-to-reset');
  for (var j = 0; j < items.length; j++) {
    items[j].addEventListener('click', function () {
      crystalResetState.itemName = this.getAttribute('data-name');
      renderCrystalReset();
    });
  }
  return;
}


  // STEP 3: dettaglio oggetto + pulsante "Ripristina cristalli"
  const cat  = crystalResetState.category;
  const name = crystalResetState.itemName;

  // Calcola i bonus attuali (solo reading, niente +/-)
  ensureUpgradeMaps();
  let rowsHtml = '';
  if (cat === 'weapons'){
    const up = (userStore.get('weaponUp') || {})[name] || { Danno:0, Velocit√†:0 };
    const extra = (userStore.get('weaponExtraProgress') || {})[name] || 0;
    rowsHtml = `
      <div class="up-row"><span>Danno</span><div class="up-ctrls"><span class="up-val">+${up.Danno|0}</span></div></div>
      <div class="up-row"><span>Velocit√†</span><div class="up-ctrls"><span class="up-val">+${up.Velocit√†|0}</span></div></div>
      <div class="up-row"><span>Effetto Extra</span><div class="up-ctrls"><span class="up-val">${extra|0}/20</span></div></div>
    `;
  } else if (cat === 'armors'){
    const up = (userStore.get('armorUp') || {})[name] || { Difesa:0, Resistenza:0 };
    rowsHtml = `
      <div class="up-row"><span>Difesa</span><div class="up-ctrls"><span class="up-val">+${up.Difesa|0}</span></div></div>
      <div class="up-row"><span>Resistenza</span><div class="up-ctrls"><span class="up-val">+${up.Resistenza|0}</span></div></div>
    `;
  } else if (cat === 'magics'){
    const up = (userStore.get('magicUp') || {})[name] || { Danno:0, Velocit√†:0 };
    rowsHtml = `
      <div class="up-row"><span>Danno</span><div class="up-ctrls"><span class="up-val">+${up.Danno|0}</span></div></div>
      <div class="up-row"><span>Velocit√†</span><div class="up-ctrls"><span class="up-val">+${up.Velocit√†|0}</span></div></div>
    `;
  }

  const invested = calcInvestedCrystals(cat, name);

  body.innerHTML = `
    <div class="traits-block">
      <div class="title">${name}</div>
      <div class="traits-grid" style="grid-template-columns: 1fr;">
        ${rowsHtml}
      </div>
    </div>

    <div class="hero-change-meta" style="margin: 8px 0;">
      <span class="gold">Costo ripristino: <strong>${formatGold(CRYSTAL_RESET_COST)}</strong> monete d'oro</span><br>
      <span class="gold">Cristalli recuperati: <strong>${invested}</strong></span>
    </div>

    <div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap;">
      <button class="magic-button" id="cr-reset-apply">Ripristina cristalli</button>
      <button class="magic-button" onclick="crystalResetState.itemName=null; renderCrystalReset();">Torna indietro</button>
    </div>
  `;

  document.getElementById('cr-reset-apply')?.addEventListener('click', ()=>{
    confirmResetCrystals(cat, name, invested);
  });
}

// Conferma e applica il reset
function confirmResetCrystals(cat, name, invested){
  if ((invested|0) <= 0){
    showGameMessage('Nessun cristallo', 'Questo oggetto non ha cristalli da ripristinare.');
    return;
  }
  const gold = getNum('gold', 0);
  if (gold < CRYSTAL_RESET_COST){
    const diff = CRYSTAL_RESET_COST - gold;
    showGameMessage('Oro insufficiente', `Ti mancano <strong>${formatGold(diff)}</strong> monete d'oro.`);
    return;
  }

  // Usiamo il popup di conferma come per la stirpe/abilit√† (stile coerente)
  showConfirmDialog({
    title: 'Conferma ripristino',
    text: `Sei sicuro di voler ripristinare i cristalli?<br>Spenderai <strong>${formatGold(CRYSTAL_RESET_COST)}</strong> monete d'oro e recupererai <strong>${invested}</strong> cristalli di potenziamento.`,
    okText: 'S√¨, ripristina',
    cancelText: 'No',
    onConfirm: () => applyCrystalReset(cat, name, invested)
  });
}

// Applica: scala oro, rimborsa cristalli, resetta mappe e aggiorna UI
// Applica: scala oro, rimborsa cristalli, resetta mappe e aggiorna UI
function applyCrystalReset(cat, name, invested){
  // 1) Scala oro
  addNum('gold', -CRYSTAL_RESET_COST);
  updateGoldBadges(); // aggiorna tutti i badge (profilo/botteghe)

  // 2) Rimborsa cristalli
  addNum('crystals', invested);

  // 3) Reset potenziamenti
  ensureUpgradeMaps();
  if (cat === 'weapons'){
    // Azzera i potenziamenti numerici
    const wu = userStore.get('weaponUp') || {};
    delete wu[name];
    userStore.set('weaponUp', wu);

    // ‚ùóÔ∏èPreserva incisione e lo sblocco "Extra"
    const legacyMap = userStore.get('weaponExtraChosen') || {};
    const engraved  = userStore.get(`weaponExtraEffect_${name}`) || legacyMap[name] || null;

    const wp = userStore.get('weaponExtraProgress') || {};
    if (engraved) {
      // Mantieni sblocco: almeno 20 (i 20 non sono rimborsabili)
      wp[name] = Math.max(20, Number(wp[name] || 0));
      userStore.set('weaponExtraProgress', wp);

      // Riallinea chiavi (idempotente)
      userStore.set(`weaponExtraEffect_${name}`, engraved);
      legacyMap[name] = engraved;
      userStore.set('weaponExtraChosen', legacyMap);
    } else {
      // Se non inciso, puoi azzerare il progresso Extra
      delete wp[name];
      userStore.set('weaponExtraProgress', wp);
    }

    // üö´ NON rimuovere l‚Äôeffetto inciso!
    // (tolte le vecchie righe che cancellavano le chiavi)

    // Aggiorna eventuale UI armi equipaggiate (nome/effetti)
    if (typeof updateEquippedWeaponsUI === 'function') updateEquippedWeaponsUI();

  } else if (cat === 'armors'){
    const au = userStore.get('armorUp') || {};
    delete au[name];
    userStore.set('armorUp', au);

  } else if (cat === 'magics'){
    const mu = userStore.get('magicUp') || {};
    delete mu[name];
    userStore.set('magicUp', mu);
  }

  // 4) Feedback + refresh step 2 (l'oggetto sparir√† dall‚Äôelenco se torna a 0)
  showGameMessage('Ripristino eseguito', `Hai recuperato <strong>${invested}</strong> cristalli di potenziamento.`);
  crystalResetState.itemName = null;
  renderCrystalReset();
}

// Integra il bottone nuovo quando renderizzi la pagina cristalli
// (chiama questa funzione DENTRO renderCrystalsScreen())
if (typeof wireResetButtonOnCrystalsScreen === 'function'){
  // se la funzione √® stata gi√† definita quando carichi la pagina, nulla
}

function showUseCrystalsScreen(){
  // Nasconde la pagina cristalli e mostra la pagina "usa"
  document.getElementById('crystals-screen')?.classList.add('hidden');
  document.getElementById('crystal-spend-screen')?.classList.remove('hidden');

  // reset stato wizard
  if (typeof resetCrystalSpendState === 'function') resetCrystalSpendState();
  if (typeof crystalSpendState === 'object') {
    crystalSpendState.page = crystalSpendState.page || { weapons:1, armors:1, magics:1 };
  }
  // disegna il contenuto riusando il renderer del wizard
  if (typeof renderCrystalSpend === 'function') renderCrystalSpend();
}

function backFromUseCrystalsScreen(){
  document.getElementById('crystal-spend-screen')?.classList.add('hidden');
  document.getElementById('crystals-screen')?.classList.remove('hidden');
}
window.showUseCrystalsScreen = showUseCrystalsScreen;



// === CRISTALLI DI POTENZIAMENTO ===
function ensureCrystalsModal() {
  let ov = document.getElementById('crystals-overlay');
  let md = document.getElementById('crystals-modal');
  if (ov && md) return;

  if (!ov) {
    ov = document.createElement('div');
    ov.id = 'crystals-overlay';
    ov.className = 'hidden';
    ov.onclick = closeCrystals;
    document.body.appendChild(ov);
  }
  if (!md) {
    md = document.createElement('div');
    md.id = 'crystals-modal';
    md.className = 'hidden';
    md.innerHTML = `
      <h3 style="text-align:center;">Cristalli di Potenziamento</h3>
      <div id="crystals-body"></div>
      <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end;">
        <button class="magic-button" id="btn-fuse-crystals">Fondi</button>
        <button class="magic-button" onclick="closeCrystals()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(md);

    // Hook pulsante "Fondi"
    md.querySelector('#btn-fuse-crystals').addEventListener('click', () => {
  // Se posso fondere 2+ apro la pagina; se 0/1 gestiamo l√¨
  showFuseCrystalsScreen();
});

  }
}

function renderCrystalsPopup() {
  const body = document.getElementById('crystals-body');
  if (!body) return;

  const parts = getNum('crystalParts', 0);   // es. 0,1,2,3,4...
  const full  = getNum('crystals', 0);       // cristalli completi gi√† fusi
  const canMake = Math.floor(parts / 3);

  const useBtn = (full > 0)
    ? ` <button class="mini-button" id="btn-use-crystals">Utilizza</button>`
    : ``;

  body.innerHTML = `
    <p><strong>Frammenti:</strong> ${parts}/3</p>
    <p><strong>Cristalli completi:</strong> <span id="crystals-count">${full}</span>${useBtn}</p>

    <div class="crystals-info-box">
      <div class="title">Come funziona</div>
      <div>
        <p>Ogni 3 frammenti ‚Üí 1 Cristallo completo.</p>
        <p>Puoi fondere in qualsiasi momento.</p>
        <p>I Cristalli di Potenziamento servono per potenziare le caratteristiche delle tue
        <strong>armi</strong>, <strong>armature</strong> e <strong>magie</strong>.
        Usali con saggezza per aumentare <strong>danno</strong>, <strong>difesa</strong>, <strong>velocit√†</strong>
        e persino sbloccare <strong>effetti extra unici</strong>!</p>
      </div>
    </div>

    <p style="margin-top:8px;">
      ${canMake > 0
        ? `Puoi fondere <strong>${canMake}</strong> ${canMake>1?'cristalli':'cristallo'}.`
        : `Non hai ancora abbastanza parti per fondere.`
      }
    </p>
  `;

  // Hook "Utilizza"
  if (full > 0) {
    document.getElementById('btn-use-crystals')?.addEventListener('click', showUseCrystals);
  }
}

function showCrystals() {
  ensureCrystalsModal();
  renderCrystalsPopup();

  const ov = document.getElementById('crystals-overlay');
  const md = document.getElementById('crystals-modal');
  ov.classList.remove('hidden');
  md.classList.remove('hidden');

  // NEW: ancora il popup sotto al titolo della vista corrente
  const sectionSelector =
    document.querySelector('#inventory:not(.hidden)') ? '#inventory' :
    document.querySelector('#shop:not(.hidden)')      ? '#shop' :
                                                        '#menu'; // fallback
  positionModalBelowSectionTitle(md, sectionSelector, 16);
}

function closeCrystals() {
  const ov = document.getElementById('crystals-overlay');
  const md = document.getElementById('crystals-modal');
  if (ov) ov.classList.add('hidden');
  if (md) md.classList.add('hidden');
}

// üî• Fusione: trasforma i "terzi" in cristalli completi
function fuseCrystals() {
  const parts = getNum('crystalParts', 0);
  const canMake = Math.floor(parts / 3);

  if (canMake <= 0) {
    showGameMessage('Fusione', 'Non hai abbastanza frammenti di Cristallo di Potenziamento.');
    return;
  }

    // scala i terzi usati e aggiungi cristalli completi
  addNum('crystalParts', -(canMake * 3));
  addNum('crystals', canMake);

  // ‚úÖ QUEST SETTIMANALE: fondi cristalli ‚Üí avanza di canMake
  if (typeof incrementQuest === 'function') incrementQuest('q_weekly_fuse_crystal', canMake);
  if (typeof renderWeeklyQuestsUI === 'function') renderWeeklyQuestsUI();
  if (typeof updateQuestsBadge === 'function') updateQuestsBadge();


  showGameMessage('Fusione riuscita',
    `Complimenti, hai ottenuto <strong>${canMake}</strong> ${canMake>1?'cristalli':'cristallo'} di potenziamento!`
  );

  // refresh sia del popup (se aperto) che della pagina (se aperta)
try { renderCrystalsPopup(); } catch(e) {}
try { renderCrystalsScreen(); } catch(e) {}

}
// === MAPPE POTENZIAMENTI (per-giocatore) ===
function ensureUpgradeMaps() {
  if (!userStore.get('weaponUp')) userStore.set('weaponUp', {});
  if (!userStore.get('weaponExtraProgress')) userStore.set('weaponExtraProgress', {}); // 0..20
  if (!userStore.get('armorUp')) userStore.set('armorUp', {});
  if (!userStore.get('magicUp')) userStore.set('magicUp', {});
}

// === MODALE "USA CRISTALLI" ===
function showUseCrystals() {
  ensureUpgradeMaps();
  ensureCrystalSpendModal();
  resetCrystalSpendState();
  renderCrystalSpend(); // step 1
  closeCrystals();

  const ov = document.getElementById('crystal-spend-overlay');
  const md = document.getElementById('crystal-spend-modal');
  ov.classList.remove('hidden');
  md.classList.remove('hidden');

  // NEW: posizione sotto al titolo della vista corrente
  const sectionSelector =
    document.querySelector('#inventory:not(.hidden)') ? '#inventory' :
    document.querySelector('#shop:not(.hidden)')      ? '#shop' :
                                                        '#menu';
  positionModalBelowSectionTitle(md, sectionSelector, 16);
}
function closeUseCrystals() {
  document.getElementById('crystal-spend-overlay')?.classList.add('hidden');
  document.getElementById('crystal-spend-modal')?.classList.add('hidden');
}

// stato temporaneo (non salvato) del wizard
const CRYSTAL_MAX_EXTRA = 20; // Effetto Extra max 20
const crystalSpendState = {
  category: null,   // 'weapons' | 'armors' | 'magics'
  itemName: null,
  pending: {},      // { stat: delta }
  spent: 0          // cristalli spesi temporaneamente
};

function resetCrystalSpendState() {
  crystalSpendState.category = null;
  crystalSpendState.itemName = null;
  crystalSpendState.pending = {};
  crystalSpendState.spent = 0;
}

// crea (una volta) il modale del wizard
function ensureCrystalSpendModal() {
  let ov = document.getElementById('crystal-spend-overlay');
  let md = document.getElementById('crystal-spend-modal');
  if (ov && md) return;

  if (!ov) {
    ov = document.createElement('div');
    ov.id = 'crystal-spend-overlay';
    ov.className = 'hidden';
    ov.onclick = closeUseCrystals;
    document.body.appendChild(ov);
  }
  if (!md) {
    md = document.createElement('div');
    md.id = 'crystal-spend-modal';
    md.className = 'hidden';
    md.innerHTML = `
      <h3 style="text-align:center;">Usa Cristalli</h3>
      <div id="crystal-spend-body"></div>
      <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end;">
        <button class="magic-button" onclick="closeUseCrystals()">Chiudi</button>
      </div>
    `;
    document.body.appendChild(md);
  }
}

// rendering del contenuto in base allo step
function renderCrystalSpend() {
  const body = document.getElementById('crystal-spend-body');
  if (!body) return;

  const crystalsAvail = getNum('crystals', 0) - (crystalSpendState.spent || 0);

  // STEP 1 ‚Äî scegli categoria
  if (!crystalSpendState.category) {
    body.innerHTML = `
      <p style="margin-bottom:8px;">
        <button class="mini-button mini-button--dark" id="cs-back">‚Üê Indietro</button>
        &nbsp;&nbsp;<strong>Cristalli disponibili:</strong> ${getNum('crystals',0)}
      </p>
      <div class="traits-block">
        <div class="title">Scegli Categoria</div>
        <div class="traits-grid" style="grid-template-columns: 1fr;">
          <button class="magic-button" data-cat="weapons">Armi</button>
          <button class="magic-button" data-cat="armors">Armature</button>
          <button class="magic-button" data-cat="magics">Magie</button>
        </div>
      </div>
    `;
    body.querySelector('#cs-back')?.addEventListener('click', backFromUseCrystalsScreen);
    body.querySelectorAll('[data-cat]').forEach(btn => {
      btn.addEventListener('click', () => {
        crystalSpendState.category = btn.getAttribute('data-cat');
        renderCrystalSpend();
      });
    });
    return;
  }

  // STEP 2 ‚Äî scegli oggetto
if (!crystalSpendState.itemName) {
  let owned = [];
  let weaponsObj = null; // <- serve solo per le armi

  if (crystalSpendState.category === 'weapons') {
    weaponsObj = userStore.get('weapons') || {};
    owned = Object.keys(weaponsObj);
  } else if (crystalSpendState.category === 'armors') {
    owned = userStore.get('armors') || [];
  } else if (crystalSpendState.category === 'magics') {
    owned = userStore.get('magics') || [];
  }

  // helper per renderizzare correttamente il nome
  const renderName = (n) => {
    if (crystalSpendState.category === 'weapons') {
      const qty = weaponsObj && Number(weaponsObj[n] || 0);
      const qtyLabel = qty > 0 ? ` x${qty}` : '';
      return `${formatWeaponName(n)}${qtyLabel}`;
    }
    // per armature/magie scrivi solo il nome
    return n;
  };

  // escape minimale per gli attributi html
  const esc = (s) => String(s).replace(/"/g, '&quot;');

  // --- PAGINAZIONE: max 10 elementi per pagina ---
crystalSpendState.page = crystalSpendState.page || { weapons:1, armors:1, magics:1 };
const key = crystalSpendState.category;
const perPage = window.CRYSTAL_PER_PAGE || 10;
const total   = owned.length;
const totalPages = Math.max(1, Math.ceil(total / perPage));
const curPage = Math.min(Math.max(1, Number(crystalSpendState.page[key] || 1)), totalPages);
const start   = (curPage - 1) * perPage;
const slice   = owned.slice(start, start + perPage);
crystalSpendState.page[key] = curPage;

// bottoni nav come richiesto
const go = (p) => `onclick="(function(){ crystalSpendState.page = crystalSpendState.page || {}; crystalSpendState.page['${key}']=${p}; renderCrystalSpend(); })()"`;

const nextBtn = (curPage < totalPages)
  ? `<button type="button" style="width:100%; margin-top:10px;" ${go(curPage + 1)}>Pagina Successiva</button>` : '';
const prevBtn = (curPage > 1)
  ? `<button type="button" style="width:100%; margin-top:10px;" ${go(curPage - 1)}>Pagina Precedente</button>` : '';
const navHtml = (curPage === 1)
  ? nextBtn
  : (curPage === totalPages ? prevBtn : (nextBtn + prevBtn));

document.getElementById('crystal-spend-body').innerHTML = `
  <p style="margin-bottom:8px;">
    <button class="mini-button mini-button--dark" id="cs-back1">‚Üê Indietro</button>
    &nbsp;&nbsp;<strong>Cristalli disponibili:</strong> ${getNum('crystals',0)}
  </p>
  <div class="traits-block">
    <div class="title">Scegli ${
      crystalSpendState.category === 'weapons' ? 'Arma' :
      crystalSpendState.category === 'armors' ? 'Armatura' : 'Magia'
    }</div>
    <div class="traits-grid" style="grid-template-columns: 1fr;">
      ${
        slice.length
  ? slice.map(n => `<button class="magic-button" style="width:100%; padding:6px 10px; font-size:14px;" data-pick="${esc(n)}">${renderName(n)}</button>`).join('')
  : `<div class="muted">Non possiedi elementi in questa categoria.</div>`
      }
    </div>
  </div>
  ${navHtml}
`;


  document.getElementById('cs-back1')?.addEventListener('click', () => {
    crystalSpendState.category = null;
    crystalSpendState.pending = {};
    crystalSpendState.spent = 0;
    renderCrystalSpend();
  });
  document.querySelectorAll('[data-pick]').forEach(btn => {
    btn.addEventListener('click', () => {
      crystalSpendState.itemName = btn.getAttribute('data-pick');
      renderCrystalSpend();
    });
  });
  return;
}


  // STEP 3 ‚Äî modifica stats
  const name = crystalSpendState.itemName;
  const cat  = crystalSpendState.category;

  let rowsHtml = '';
  if (cat === 'weapons') {
    const up = userStore.get('weaponUp') || {};
    const base = up[name] || { Danno: 0, Velocit√†: 0 };
    const extraProgMap = userStore.get('weaponExtraProgress') || {};
    const extra = (extraProgMap[name] || 0) + (crystalSpendState.pending.Extra || 0);
    const dano = (base.Danno + (crystalSpendState.pending.Danno || 0)) || 0;
    const velo = (base.Velocit√† + (crystalSpendState.pending.Velocit√† || 0)) || 0;

    rowsHtml = `
      <div class="up-row">
        <span>Danno</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Danno">‚àí</button>
          <span class="up-val">+${dano}</span>
          <button class="mini-button" data-inc="Danno">+</button>
        </div>
      </div>
      <div class="up-row">
        <span>Velocit√†</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Velocit√†">‚àí</button>
          <span class="up-val">+${velo}</span>
          <button class="mini-button" data-inc="Velocit√†">+</button>
        </div>
      </div>
      <div class="up-row">
        <span>Effetto Extra</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Extra">‚àí</button>
          <span class="up-val">${extra}/20</span>
          <button class="mini-button" data-inc="Extra">+</button>
        </div>
      </div>
    `;
  } else if (cat === 'armors') {
    const up = userStore.get('armorUp') || {};
    const base = up[name] || { Difesa: 0, Resistenza: 0 };
    const dif = (base.Difesa + (crystalSpendState.pending.Difesa || 0)) || 0;
    const res = (base.Resistenza + (crystalSpendState.pending.Resistenza || 0)) || 0;

    rowsHtml = `
      <div class="up-row">
        <span>Difesa</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Difesa">‚àí</button>
          <span class="up-val">+${dif}</span>
          <button class="mini-button" data-inc="Difesa">+</button>
        </div>
      </div>
      <div class="up-row">
        <span>Resistenza</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Resistenza">‚àí</button>
          <span class="up-val">+${res}</span>
          <button class="mini-button" data-inc="Resistenza">+</button>
        </div>
      </div>
    `;
  } else {
    const up = userStore.get('magicUp') || {};
    const base = up[name] || { Danno: 0, Velocit√†: 0 };
    const dano = (base.Danno + (crystalSpendState.pending.Danno || 0)) || 0;
    const velo = (base.Velocit√† + (crystalSpendState.pending.Velocit√† || 0)) || 0;

    rowsHtml = `
      <div class="up-row">
        <span>Danno</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Danno">‚àí</button>
          <span class="up-val">+${dano}</span>
          <button class="mini-button" data-inc="Danno">+</button>
        </div>
      </div>
      <div class="up-row">
        <span>Velocit√†</span>
        <div class="up-ctrls">
          <button class="mini-button" data-dec="Velocit√†">‚àí</button>
          <span class="up-val">+${velo}</span>
          <button class="mini-button" data-inc="Velocit√†">+</button>
        </div>
      </div>
    `;
  }

  body.innerHTML = `
    <p>
      <button class="mini-button mini-button--dark" id="cs-back2">‚Üê Indietro</button>
      &nbsp;&nbsp;<strong>Cristalli disponibili:</strong> ${getNum('crystals',0)} (rimasti: ${crystalsAvail})
    </p>
    <div class="traits-block">
      <div class="title">${name}</div>
      <div class="traits-grid" style="grid-template-columns: 1fr;">
        ${rowsHtml}
      </div>
    </div>
    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
      <button class="magic-button hidden" id="cs-apply">Salva</button>
    </div>
  `;

  body.querySelector('#cs-back2')?.addEventListener('click', () => {
    crystalSpendState.itemName = null;
    crystalSpendState.pending = {};
    crystalSpendState.spent = 0;
    renderCrystalSpend();
  });

  const saveBtn = body.querySelector('#cs-apply');
  function refreshSaveVisibility() {
    const pendingKeys = Object.keys(crystalSpendState.pending || {});
    const hasChanges = pendingKeys.some(k => crystalSpendState.pending[k] > 0);
    if (hasChanges) saveBtn.classList.remove('hidden');
    else saveBtn.classList.add('hidden');
  }

  body.querySelectorAll('[data-inc]').forEach(btn => {
    btn.addEventListener('click', () => {
      adjustCrystalStat(btn.getAttribute('data-inc'), +1);
      refreshSaveVisibility();
    });
  });
  body.querySelectorAll('[data-dec]').forEach(btn => {
    btn.addEventListener('click', () => {
      adjustCrystalStat(btn.getAttribute('data-dec'), -1);
      refreshSaveVisibility();
    });
  });

  saveBtn?.addEventListener('click', applyCrystalSpend);
  refreshSaveVisibility();
}


// modifica temporanea (pendente) e aggiorna UI
function adjustCrystalStat(stat, delta) {
  const crystalsAvail = getNum('crystals', 0) - crystalSpendState.spent;

  if (delta > 0) {
    if (crystalsAvail <= 0) return;
    // cap per Extra
    if (stat === 'Extra') {
      const current = (userStore.get('weaponExtraProgress') || {})[crystalSpendState.itemName] || 0;
      const pend = crystalSpendState.pending.Extra || 0;
      if (current + pend >= CRYSTAL_MAX_EXTRA) return;
    }
    crystalSpendState.pending[stat] = (crystalSpendState.pending[stat] || 0) + 1;
    crystalSpendState.spent += 1;
  } else {
    // delta < 0: rimuovi solo se c‚Äôera un incremento pendente
    if ((crystalSpendState.pending[stat] || 0) <= 0) return;
    crystalSpendState.pending[stat] -= 1;
    crystalSpendState.spent = Math.max(0, crystalSpendState.spent - 1);
  }

  renderCrystalSpend();
}

// salva: applica i delta e scala i cristalli
function applyCrystalSpend() {
  const spent = Number(crystalSpendState.spent || 0);
  if (spent <= 0) { closeUseCrystals(); return; }

  const cat = crystalSpendState.category;
  const name = crystalSpendState.itemName;
  const pend = crystalSpendState.pending || {};

  ensureUpgradeMaps();

  if (cat === 'weapons') {
    const up = userStore.get('weaponUp') || {};
    const ex = userStore.get('weaponExtraProgress') || {};
    const curr = up[name] || { Danno: 0, Velocit√†: 0 };
    curr.Danno = (curr.Danno || 0) + (pend.Danno || 0);
    curr.Velocit√† = (curr.Velocit√† || 0) + (pend.Velocit√† || 0);
    up[name] = curr;
    ex[name] = Math.min(CRYSTAL_MAX_EXTRA, (ex[name] || 0) + (pend.Extra || 0));
    userStore.set('weaponUp', up);
    userStore.set('weaponExtraProgress', ex);
  } else if (cat === 'armors') {
    const up = userStore.get('armorUp') || {};
    const curr = up[name] || { Difesa: 0, Resistenza: 0 };
    curr.Difesa = (curr.Difesa || 0) + (pend.Difesa || 0);
    curr.Resistenza = (curr.Resistenza || 0) + (pend.Resistenza || 0);
    up[name] = curr;
    userStore.set('armorUp', up);
  } else if (cat === 'magics') {
    const up = userStore.get('magicUp') || {};
    const curr = up[name] || { Danno: 0, Velocit√†: 0 };
    curr.Danno = (curr.Danno || 0) + (pend.Danno || 0);
    curr.Velocit√† = (curr.Velocit√† || 0) + (pend.Velocit√† || 0);
    up[name] = curr;
    userStore.set('magicUp', up);
  }

  // sottrai cristalli (numero garantito)
  addNum('crystals', -spent);

  // aggiorna UI cristalli (popup + schermata)
  try { renderCrystalsPopup(); } catch(e) { /* noop */ }
  try { renderCrystalsScreen(); } catch(e) { /* noop */ }

  // ‚ûï Catena "Cristalli": avanza il conteggio cumulativo (se la funzione esiste)
  try {
    if (typeof incrementMainCrystalsUsed === 'function') incrementMainCrystalsUsed(spent);
  } catch (e) { /* noop */ }

  // Aggiorna badge UI e, se il pannello Missioni/Main √® visibile, aggiorna anche la UI delle quest
  try {
    if (typeof updateQuestsBadge === 'function') updateQuestsBadge();

    const missionsEl = document.getElementById('missions');
    const mainTabEl = document.getElementById('missions-tab-main');
    const mainTabVisible = mainTabEl && !mainTabEl.classList.contains('hidden');
    if (missionsEl && !missionsEl.classList.contains('hidden') && mainTabVisible) {
      if (typeof renderMainQuestsUI === 'function') renderMainQuestsUI();
    }
  } catch (e) { /* noop */ }

  // feedback utente
  const parola = spent === 1 ? 'cristallo' : 'cristalli';
  try {
    showGameMessage('Potenziamento applicato', `Hai speso <strong>${spent}</strong> ${parola}.`);
  } catch (e) { /* noop */ }

  // chiudi popup di spend (manteniamo la chiamata di chiusura come prima)
  try { closeUseCrystals(); } catch(e) { /* noop */ }
}


function formatStatWithBonus(label, baseVal, bonusVal) {
  const base = Number(baseVal) || 0;
  const bonus = Number(bonusVal) || 0;
  return `${label}: <strong>${base}</strong>${bonus > 0 ? ` <span class="bonus">(+${bonus})</span>` : ''}`;
}
// Helper: nome arma con eventuale effetto extra scelto
// Format: "Spada (Furia)" se ha un effetto extra inciso
function formatWeaponName(name) { 
  if (!name) return 'Nessuna';

  // prova a leggere da mappa cumulativa
  const chosenMap = userStore.get('weaponExtraChosen') || {};
  // oppure dal singolo valore
  const direct = userStore.get(`weaponExtraEffect_${name}`);

  const eff = chosenMap[name] || direct;

  return eff ? `${name} (${eff})` : name;
}

function getMagicImageSrc(magicName){
  // Se arrivano varianti tipo "Fuoco [Rara]" -> torna "Fuoco"
  const base = (typeof baseNameFromVariant === 'function')
    ? baseNameFromVariant(magicName)
    : String(magicName || '').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');

  // immagini magie: PNG
  return `magics/${encodeURIComponent(String(base || '').trim())}.png`;
}

function getCreatureImageSrc(creatureName){
  const base = (typeof baseNameFromVariant === 'function')
    ? baseNameFromVariant(creatureName)
    : String(creatureName||'').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');
  return `Creatures/${encodeURIComponent(String(base || '').trim())}.png`;
}


function getPotionImageSrc(potionName){
  // IMPORTANTISSIMO: encodeURIComponent gestisce spazi e caratteri speciali nel filename
  const base = String(potionName || '').trim();

  // default PNG (poi facciamo fallback a JPG nell'<img onerror=...>)
  return `potions/${encodeURIComponent(base)}.png`;
}


function getArmorImageSrc(armorName){
  // Se arrivano varianti tipo "Corazza [Rara]" -> torna "Corazza"
  const base = (typeof baseNameFromVariant === 'function')
    ? baseNameFromVariant(armorName)
    : String(armorName || '').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');

  return `armors/${encodeURIComponent(String(base || '').trim())}.png`;
}


function getGuildSecretImageSrc(item){
  const name = item?.name || '';
  const cat  = item?.category || '';

  if (cat === 'weapon'   && typeof getWeaponImageSrc   === 'function') return getWeaponImageSrc(name);
  if (cat === 'armor'    && typeof getArmorImageSrc    === 'function') return getArmorImageSrc(name);
  if (cat === 'magic'    && typeof getMagicImageSrc    === 'function') return getMagicImageSrc(name);
  if (cat === 'creature' && typeof getCreatureImageSrc === 'function') return getCreatureImageSrc(name);

  return '';
}

function getWeaponImageSrc(weaponName){
  // Se arrivano varianti tipo "Spada [Rara]" -> torna "Spada"
  const base = (typeof baseNameFromVariant === 'function')
    ? baseNameFromVariant(weaponName)
    : String(weaponName||'').replace(/\s\[(Rara|Epica|Leggendaria|Mitica)\]$/i, '');

  // IMPORTANTISSIMO: encodeURIComponent gestisce spazi e caratteri speciali nel filename
  const safe = encodeURIComponent(base);

  // default png (poi mettiamo fallback jpg/webp direttamente nell'<img onerror=...>)
  return `weapons/${safe}.png`;
}

// Aggiorna tutte le label armi nel profilo/hero
function updateEquippedWeaponsUI() {
  const right = userStore.get('rightHand') || null;
  const left  = userStore.get('leftHand')  || null;

  const r1 = document.getElementById('right-hand-display'); // nel profilo
  const l1 = document.getElementById('left-hand-display');
  const r2 = document.getElementById('hero-weapon-right');  // nel riquadro hero
  const l2 = document.getElementById('hero-weapon-left');

  if (r1) r1.textContent = formatWeaponName(right);
  if (l1) l1.textContent = formatWeaponName(left);
  if (r2) r2.textContent = formatWeaponName(right);
  if (l2) l2.textContent = formatWeaponName(left);
}

function normalizeAbilitiesObject() {
  const a = getAbilities();
  const norm = {};
  ABILITIES_LIST.forEach(n => { norm[n] = Number(a?.[n]) || 0; });
  setAbilities(norm);
}
function getHeroPower() {
  // Usa la stessa potenza eroe del profilo / PvP, con fallback al livello
  try {
    if (typeof computeHeroPower === 'function') {
      const p = Number(computeHeroPower() || 0);
      if (!isNaN(p) && p > 0) return Math.round(p);
    }
  } catch (_) {}

  // Fallback sicuro: livello come prima
  return Number(getNum('level', 1)) || 1;
}

// --- Potenza Eroe di un altro utente (per sfide PvP) ---
function getHeroPowerOfUser(username) {
  // Se esiste un helper di comodo, usalo
  if (typeof getHeroLevelOfUser === 'function') {
    return Number(getHeroLevelOfUser(username)) || 1;
  }
  // Fallback: prendo il livello dalla "Sala degli Eroi" se presente
  try {
    const list = (typeof getHeroDirectory === 'function') ? getHeroDirectory() : [];
    const entry = list.find(h => h && h.name === username);
    return Number(entry?.level || 1);
  } catch (_) {
    return 1;
  }
}
// === Pergamene laterali (3) ‚Äî solo quando si √® nel gioco ===
(function rightScrolls(){
  const IMG_SRC = 'pergamena.png';
  let panel = document.getElementById('scrolls-panel');

  function ensurePanel(){
    if (!panel) {
      panel = document.createElement('aside');
      panel.id = 'scrolls-panel';
      panel.innerHTML = `
  <div class="scroll-box">
    <img src="${IMG_SRC}" alt="Pergamena 1" class="scroll-img">
    <div class="scroll-text" id="rank-scroll">
      <!-- il contenuto viene iniettato via JS -->
    </div>
  </div>
  <div class="scroll-box">
    <img src="${IMG_SRC}" alt="Pergamena 2" class="scroll-img">
    <div class="scroll-text" id="wins-scroll">
      <!-- il contenuto viene iniettato via JS -->
    </div>
  </div>
    <div class="scroll-box">
    <img src="${IMG_SRC}" alt="Pergamena 3" class="scroll-img">
    <div class="scroll-text" id="guilds-scroll">
      <!-- il contenuto viene iniettato via JS -->
    </div>
  </div>
`;
      document.body.appendChild(panel);
    }
  }
// Render "Classifica Rank" (top 3 per punti) nella pergamena #1
function renderRankScroll(){
  if (!panel) return;
  const box = panel.querySelector('#rank-scroll');
  if (!box) return;

  // Prendo la directory degli eroi e ordino per punti decrescenti
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const top3 = dir.slice()
    .sort((a, b) => (Number(b?.points || 0) - Number(a?.points || 0)))
    .slice(0, 3);

  // Costruisco la lista "1) Nome (pts)" con font medioevale
  let listHtml = '<ol class="rank-list">';
  if (top3.length === 0){
    listHtml += '<li class="muted">Nessun eroe registrato.</li>';
  } else {
    top3.forEach((h, i) => {
      const pos = (i + 1) + ')';
      const name = (typeof escapeHtml === 'function') ? escapeHtml(h?.name || '') : (h?.name || '');
      const pts = Number(h?.points || 0);
      listHtml += `<li>${pos} ${name} <span class="pts">(${pts} pt)</span></li>`;
    });
  }
  listHtml += '</ol>';

  box.innerHTML = `
    <div class="rank-title"><strong>Rank</strong></div>
    ${listHtml}
  `;
}
// Render "Classifica Sfide Vinte" (top 3 per vittorie) nella pergamena #2
function renderWinsScroll(){
  if (!panel) return;
  const box = panel.querySelector('#wins-scroll');
  if (!box) return;

  // Directory eroi, ordina per VITTORIE ‚Üì, poi PUNTI ‚Üì, poi NOME ‚Üë
  const dir = (typeof getHeroDirectory === 'function') ? (getHeroDirectory() || []) : [];
  const top3 = dir.slice()
    .sort((a,b)=>{
      const aw = Number(a?.wins||0), bw = Number(b?.wins||0);
      if (bw !== aw) return bw - aw;
      const ap = Number(a?.points||0), bp = Number(b?.points||0);
      if (bp !== ap) return bp - ap;
      return (a?.name||'').localeCompare(b?.name||'');
    })
    .slice(0,3);

  let listHtml = '<ol class="rank-list">';
  if (top3.length === 0){
    listHtml += '<li class="muted">Nessun eroe.</li>';
  } else {
    top3.forEach((h,i)=>{
      const pos  = (i+1) + ')';
      const name = (typeof escapeHtml === 'function') ? escapeHtml(h?.name||'') : (h?.name||'');
      const w    = Number(h?.wins||0);
      listHtml += `<li>${pos} ${name} <span class="pts">(${w} vinte)</span></li>`;
    });
  }
  listHtml += '</ol>';

  box.innerHTML = `
    <div class="rank-title"><strong>Sfide Vinte</strong></div>
    ${listHtml}
  `;
}
// Render "Classifica Gilde" (top 3 per punti gilda) nella pergamena #3
function renderGuildsScroll(){
  if (!panel) return;
  const box = panel.querySelector('#guilds-scroll');
  if (!box) return;

  try{
    const all = (typeof getGuilds === 'function') ? (getGuilds() || {}) : {};
    const ids = Object.keys(all);
    const rows = ids.map(id => {
      const g = all[id] || {};
      const pts = (typeof computeGuildPoints === 'function') ? computeGuildPoints(id) : 0;
      return { id, name: String(g.name||''), tag: String(g.tag||''), points: pts };
    });

    rows.sort((a,b)=> b.points - a.points || a.name.localeCompare(b.name));
    const top3 = rows.slice(0,3);

    let listHtml = '<ol class="rank-list">';
    if (!top3.length){
      listHtml += '<li class="muted">Nessuna gilda.</li>';
    } else {
      top3.forEach((g,i)=>{
  const pos = (i+1) + ')';
  listHtml += `<li>${pos} ${escapeHtml(g.name)} <span class="pts">(${g.points} pt)</span></li>`;
});
    }
    listHtml += '</ol>';

    box.innerHTML = `
      <div class="rank-title"><strong>Classifica Gilde</strong></div>
      ${listHtml}
    `;
  } catch(_) {
    box.innerHTML = `
      <div class="rank-title"><strong>Classifica Gilde</strong></div>
      <ol class="rank-list"><li class="muted">‚Äî</li></ol>`;
  }
}


  function sizeAndPlace(){
  if (!panel) return;
  const container = document.querySelector('.container');
  if (!container) return;

  const rect = container.getBoundingClientRect();

  // distanza dal container (ti piace 18 -> lasciamo 18)
  const spacing = 14; // px

  // posizione orizzontale: ancorata al bordo destro del container
  const panelLeft = Math.round(rect.right + spacing); // coordinate viewport (position:fixed)
  panel.style.left = panelLeft + 'px';
  panel.style.right = 'auto';

  // larghezza: fissa (pi√π ampia) ma con un tetto per non uscire dallo schermo
const desiredW = 320; // ‚Üê aumentala pure a 340/360 se vuoi ancora pi√π largo
panel.style.width = desiredW + 'px';
panel.style.maxWidth = (window.innerWidth - panelLeft - 8) + 'px'; // non oltre il bordo destro

  // altezza per immagine: un po' pi√π alta ma senza superare l'altezza del container
  const gap = 12;
  const perImgH = Math.max(110, Math.floor((rect.height - gap*2) / 3) + 20); // ‚Üë +20px circa
  panel.querySelectorAll('.scroll-img').forEach(img => {
    img.style.maxHeight = perImgH + 'px';
  });

  // centro verticale rispetto al container (position:fixed => niente scrollY)
  const centerY = Math.round(rect.top + rect.height / 2);
  panel.style.top = centerY + 'px';
  panel.style.transform = 'translateY(-50%)';
}

// refresh periodico "soft" (copre update punti durante la sessione)
let rankTimer = null;
function startRankTimer(){
  if (rankTimer) clearInterval(rankTimer);
  rankTimer = setInterval(()=>{ renderRankScroll(); renderWinsScroll(); renderGuildsScroll(); }, 1500);
}
function stopRankTimer(){
  if (rankTimer) { clearInterval(rankTimer); rankTimer = null; }
}

// quando la pergamena √® visibile, facciamo partire il timer
function updateVisibility(){
  const loggedIn = (typeof currentUser === 'string' && currentUser);
  if (!loggedIn) {
    if (panel) panel.style.display = 'none';
    stopRankTimer();
    return;
  }
  ensurePanel();
  panel.style.display = '';
sizeAndPlace();
renderRankScroll();
renderWinsScroll();
renderGuildsScroll();
startRankTimer();
}

// se cambia qualcosa nello storage (punti/classifica), rinfresca
window.addEventListener('storage', () => { renderRankScroll(); renderWinsScroll(); renderGuildsScroll(); });

  // Prima valutazione
  updateVisibility();

  // Riesegui quando cambia layout o scroll
  window.addEventListener('resize', updateVisibility);
  window.addEventListener('scroll', updateVisibility);

  // Piccolo watcher: quando passa dal login al gioco, currentUser diventa truthy
  let lastUser = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
  setInterval(() => {
    const now = (typeof currentUser === 'string' && currentUser) ? currentUser : '';
    if (now !== lastUser) {
      lastUser = now;
      updateVisibility();
    }
  }, 500);
})();

// === Messaggio Collettivo: apri/chiudi + invio ==============================
function ensureGuildBroadcastScreen(){
  const screen = document.getElementById('guild-broadcast-screen');
  return {
    screen,
    textarea: document.getElementById('guild-broadcast-text'),
    sendBtn: document.getElementById('guild-broadcast-send'),
    backBtn: document.getElementById('guild-broadcast-back')
  };
}

function openGuildBroadcastScreen(){
  const { screen, textarea, sendBtn, backBtn } = ensureGuildBroadcastScreen();
  const guildBox = document.getElementById('guild-screen'); // schermata gilda

  const gid = (typeof getUserGuildId === 'function') ? getUserGuildId() : null;
  if (!gid){
    if (typeof showToast === 'function') showToast('Non sei in una gilda.', 'warn', 2200);
    return;
  }

  // mostra schermata "Messaggio Collettivo"
  if (guildBox) guildBox.classList.add('hidden');
  if (screen)  screen.classList.remove('hidden');
  if (textarea) textarea.value = '';

  // ‚Üê Torna indietro ‚Üí torna alla schermata Gilda (renderMyGuild)
  if (backBtn){
    backBtn.onclick = ()=>{
      if (screen)  screen.classList.add('hidden');
      if (guildBox) guildBox.classList.remove('hidden');
      if (typeof renderMyGuild === 'function') renderMyGuild(); // ‚Üê tuo nome funzione
    };
  }

  // Invia a tutti i membri
  if (sendBtn){
    sendBtn.onclick = ()=>{
      const text = (textarea?.value || '').trim();
      if (!text){
        if (typeof showToast === 'function') showToast('Scrivi un messaggio prima di inviare.', 'warn', 2200);
        return;
      }

      const members = (typeof getGuildMembers === 'function') ? (getGuildMembers(gid) || []) : [];
      const sender  = (typeof currentUser === 'string' && currentUser) ? currentUser : 'Capogilda';

      // Spedisce a ogni membro usando la tua inbox per-utente
      members.forEach(m => {
        if (!m || !m.user) return;
        if (typeof deliverMessageToUser === 'function'){
          deliverMessageToUser(m.user, {
            id: 'm' + Date.now() + '_' + Math.floor(Math.random()*1e6),
            title: 'Messaggio Collettivo',
            body: text,
            type: 'guild_broadcast',
            from: sender,
            when: Date.now(),
            unread: true
          });
        }
      });

      if (typeof showToast === 'function') showToast('Messaggio inviato a tutti i membri.', 'ok', 2400);

      // chiudi schermata e torna alla Gilda
      if (screen)  screen.classList.add('hidden');
      if (guildBox) guildBox.classList.remove('hidden');
      if (typeof renderMyGuild === 'function') renderMyGuild(); // ‚Üê tuo ritorno
    };
  }
}

// opzionale: esponi globalmente
window.openGuildBroadcastScreen = openGuildBroadcastScreen;

// üîÑ Aggiornamento UI automatico quando cambia lo Scudo
window.addEventListener('shield:updated', () => {
  // aggiorna liste se visibili
  try {
    if (typeof renderHeroHall === 'function') renderHeroHall();
  } catch(_) {}

  try {
    if (typeof renderSfideList === 'function') renderSfideList();
  } catch(_) {}

  // aggiorna popup se aperto
  const modal = document.getElementById('shield-modal');
  if (modal && !modal.classList.contains('hidden')) {
    try { _renderShieldPopup(); } catch(_) {}
  }
});

</script>
<!-- Popup dettaglio creatura -->
<div id="creature-overlay" class="hidden overlay-common" onclick="closeCreatureDetail()"></div>

<div id="creature-detail" class="hidden modal-common">
  <h3 id="creature-detail-title">Creatura</h3>
  <div id="creature-detail-body"></div>
 <div class="modal-actions--stack">
  <button id="creature-detail-buy" class="magic-button">Acquista</button>
  <button class="magic-button" onclick="closeCreatureDetail()">Chiudi</button>
</div>


</div>

<!-- Popup selezione creatura -->
<div id="creature-select-overlay" class="hidden overlay-common" onclick="closeCreatureSelect()"></div>

<div id="creature-select-popup" class="hidden modal-common" role="dialog" aria-modal="true" aria-labelledby="creature-select-title">
  <h3 id="creature-select-title">Seleziona Creatura</h3>

  <div id="creature-choice-list" class="scroll-area"></div>

  <!-- Azioni in colonna, bottoni full-width e centrati -->
  <div class="modal-actions--stack">
  <button class="magic-button btn-danger" onclick="unequipCreature()">Elimina</button>
  <button onclick="closeCreatureSelect()">Chiudi</button>
</div>

</div>
<!-- Popup: dettaglio armatura -->
<div id="armor-overlay" class="hidden overlay-common" onclick="closeArmorDetail()"></div>

<div id="armor-detail" class="hidden modal-common" role="dialog" aria-modal="true" aria-labelledby="armor-detail-title">
  <h3 id="armor-detail-title">Armatura</h3>
  <div id="armor-detail-body"></div>
  <div class="modal-actions modal-actions--stack">
    <button id="armor-detail-buy" class="magic-button">Acquista</button>
    <button class="magic-button" onclick="closeArmorDetail()">Chiudi</button>
  </div>
</div>

<!-- Popup: dettaglio arma -->
<div id="weapon-overlay" class="hidden overlay-common"></div>

<div id="weapon-detail" class="hidden modal-common" role="dialog" aria-modal="true" aria-labelledby="weapon-detail-title">
  <h3 id="weapon-detail-title">Arma</h3>
  <div id="weapon-detail-body"></div>
  <div class="modal-actions modal-actions--stack">
    <button id="weapon-detail-buy" class="magic-button">Acquista</button>
    <button class="magic-button btn-secondary" onclick="closeWeaponDetail()">Chiudi</button>
  </div>
</div>

<!-- Popup selezione Armatura -->
<div id="armor-select-overlay" class="hidden" style="
  position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:999;"
  onclick="closeArmorSelect()"></div>

<div id="armor-select-popup" class="hidden" style="
  position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
  background:#f5f1e1; border:3px solid #6b4226; padding:20px; border-radius:12px;
  box-shadow:0 0 15px #00000088; z-index:1000; width:320px; text-align:left;">
  <h3 style="text-align:center;">Seleziona Armatura</h3>
  <div id="armor-choice-list" style="margin-top:10px;"></div>

  <div style="margin-top:12px;">
    <button class="magic-button" onclick="unequipArmor()" style="background-color:#b03030;">Elimina</button>
    <button class="magic-button" onclick="closeArmorSelect()">Chiudi</button>
  </div>
</div>
<!-- Popup Magia -->
<div id="magic-overlay" class="hidden overlay-common" onclick="closeMagicDetail()"></div>

<div id="magic-detail" class="hidden modal-common" role="dialog" aria-modal="true" aria-labelledby="magic-detail-title">
  <h3 id="magic-detail-title">Magia</h3>
  <div id="magic-detail-body" class="scroll-area"></div>
  <div class="modal-actions modal-actions--stack">
    <button id="magic-detail-buy" class="magic-button">Acquista</button>
    <button class="magic-button" onclick="closeMagicDetail()">Chiudi</button>
  </div>
</div>

<!-- Overlay globale riusabile per tutti i popup "semplici" -->
<div id="generic-overlay" class="hidden overlay-common"></div>
<!-- ==== Overlay: Battaglia in corso ==== -->
<div id="dungeon-battle-overlay">
  <div class="dbo-card">
    <div class="dbo-icon">‚öîÔ∏è</div>
    <div class="dbo-title">Battaglia in corso‚Ä¶</div>
    <div id="dbo-random-text" class="dbo-sub">Preparati! Stiamo risolvendo lo scontro‚Ä¶</div>
  </div>
</div>
<!-- ==== /Overlay ==== -->

<script>
// === Conferma personalizzata riutilizzabile (popup) ===
function ensureConfirmModal(){
  let ov = document.getElementById('confirm-overlay');
  if (!ov) {
    ov = document.createElement('div');
    ov.id = 'confirm-overlay';
    ov.className = 'hidden overlay-common';
    ov.style.zIndex = 5000; // sopra tutti gli altri overlay/popup
    ov.addEventListener('click', closeConfirmModal);
    document.body.appendChild(ov);
  }
  let md = document.getElementById('confirm-modal');
  if (!md) {
    md = document.createElement('div');
    md.id = 'confirm-modal';
    md.className = 'hidden modal-common';
    md.style.zIndex = 5001; // sopra il popup messaggi (che sta a 2001)
    md.innerHTML = `
      <h3 id="confirm-title">Conferma</h3>
      <div id="confirm-body" class="muted" style="margin-top:6px;"></div>
      <div class="modal-actions" style="margin-top:12px;">
        <button id="confirm-cancel" class="magic-button">Annulla</button>
        <button id="confirm-ok" class="btn-danger">Conferma</button>
      </div>
    `;
    document.body.appendChild(md);
  }
  return { ov, md };
}

function closeConfirmModal(){
  document.getElementById('confirm-overlay')?.classList.add('hidden');
  document.getElementById('confirm-modal')?.classList.add('hidden');
}

// API: showConfirmDialog({ title?, text?, okText?, cancelText?, onConfirm?, onCancel? })
function showConfirmDialog(opts){
  const { ov, md } = ensureConfirmModal();
  const titleEl   = document.getElementById('confirm-title');
  const bodyEl    = document.getElementById('confirm-body');
  const okBtn     = document.getElementById('confirm-ok');
  const cancelBtn = document.getElementById('confirm-cancel');

  titleEl.textContent   = (opts && opts.title)     || 'Conferma';
  // ‚¨áÔ∏è UNICA riga cambiata: permetti <br> e <strong> solo nel corpo
  const raw = (opts && opts.text) || 'Confermi l‚Äôoperazione?';
  bodyEl.innerHTML = raw.replace(/<(?!br\s*\/?|\/?strong\b)[^>]*>/gi, '');

  okBtn.textContent     = (opts && opts.okText)    || 'Conferma';
  cancelBtn.textContent = (opts && opts.cancelText)|| 'Annulla';

  okBtn.onclick = () => {
    try { opts && typeof opts.onConfirm === 'function' && opts.onConfirm(); }
    finally { closeConfirmModal(); }
  };
  cancelBtn.onclick = () => {
    try { opts && typeof opts.onCancel === 'function' && opts.onCancel(); }
    finally { closeConfirmModal(); }
  };

  ov.classList.remove('hidden');
  md.classList.remove('hidden');
}

// Usa la stessa finestra di conferma quando si preme "Elimina" dentro un messaggio aperto
function deleteOpenMessage(){
  if (!_openMsgId) { closeMessagePopup?.(); closeMessageDetail?.(); return; }
  showConfirmDialog({
    title: 'Elimina messaggio',
    text: 'Sei sicuro di voler eliminare questo messaggio?',
    okText: 'Conferma',
    cancelText: 'Annulla',
    onConfirm: () => {
  deleteMessagesByIds([_openMsgId]);
  _openMsgId = null;
  closeMessagePopup?.();
  closeMessageDetail?.();  // <‚Äî AGGIUNTA
  const after = getMessages().length;
  const newTotalPages = Math.max(1, Math.ceil(after / MSGS_PER_PAGE));
  if (_msgPage > newTotalPages) _msgPage = newTotalPages;
  renderMessageList(_msgPage);
}
  });
}
</script>

</body>
</html>
